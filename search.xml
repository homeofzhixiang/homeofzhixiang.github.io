<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习笔记——感知机（Perceptron)与自适性线性单元（Adaline)学习笔记</title>
      <link href="/2023/01/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA-%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/2023/01/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA-%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="感知机（Perceptron-与自适性线性单元（Adaline-学习笔记"><a href="#感知机（Perceptron-与自适性线性单元（Adaline-学习笔记" class="headerlink" title="感知机（Perceptron)与自适性线性单元（Adaline)学习笔记"></a>感知机（Perceptron)与自适性线性单元（Adaline)学习笔记</h1><p>说明：作为小白机器学习的笔记与记录，本博客主要参考借鉴以下书籍和文章：<br>文章：</p><ol><li><a href="https://www.cnblogs.com/huangyc/p/9706575.html#_label1_2">感知机原理（Perceptron）</a></li><li><a href="https://www.pkudodo.com/2018/11/18/1-4/">统计学习方法|感知机原理剖析及实现</a></li><li><a href="https://michael.blog.csdn.net/article/details/104537083">感知机（Perceptron)</a></li><li><a href="https://blog.csdn.net/wkj1026639175/article/details/79827923?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160856470616780277841266%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=160856470616780277841266&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-79827923.nonecase&utm_term=%E6%84%9F%E7%9F%A5%E6%9C%BA%E5%AF%B9%E5%81%B6%E5%BD%A2%E5%BC%8F">感知机（原始形式和对偶形式）的理解和实现</a></li><li><a href="https://www.cnblogs.com/Determined22/p/6507329.html">机器学习 —— 基础整理（六）线性判别函数：感知器、松弛算法、Ho-Kashyap 算法</a></li><li><a href="https://max.book118.com/html/2019/0605/7166011156002031.shtm">自适应线性单元-机器学习系列</a></li><li><a href="https://blog.csdn.net/sanmaopep/article/details/78542361">李航第二章课后习题</a></li></ol><p>书籍：</p><ol><li>《统计学习方法》</li><li>《机器学习》</li><li>《神经网络设计》</li><li>《机器学习实战：基于Scikit-Learn、Keras和TensorFlow》</li><li>《深度学习入门：基于Python理论与实践》</li><li>《神经网络与深度学习》</li></ol><hr><p>##文章目录<br>&amp;emsp;&amp;emsp;<a href="#1">1.感知机简介</a><br>&amp;emsp;&amp;emsp;<a href="#2">2.感知机模型</a><br>&amp;emsp;&amp;emsp;<a href="#3">3.感知机学习策略</a><br>&amp;emsp;&amp;emsp;<a href="#4">4.最初的感知机算法与其问题</a><br>&amp;emsp;&amp;emsp;<a href="#5">5.自适性线性单元(ADALINE)及LMS算法</a><br>&amp;emsp;&amp;emsp;<a href="#6">6.统计学习方法中的感知机学习算法</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="#6.1">6.1 原始形式</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="#6.2">6.2 算法收敛</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="#6.3">6.3 对偶形式</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="#6.4">6.4 原始形式与对偶形式的简单比较与选择</a><br>&amp;emsp;&amp;emsp;<a href="#5">7.算法实现</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="#7.1">7.1 基于感知机 Perceptron 的鸢尾花分类实践</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="#7.2">7.2 基于感知机 Perceptron 的乳腺癌数据集分类</a></p><p>&amp;emsp;&amp;emsp;<a href="#8">8.总结思考</a><br>感知机的历史<br>线性回归与对规律的认知<br>数学角度的分类问题与感知机<br>MP神经元模型——逻辑运算的实现<br>联结主义对学习的理解<br>Rosenblatt 对记忆与感知的理解<br>感知机的学习观</p><hr><p><font size=5><center>正确的判断来自于经验，而经验来自于错误的判断。</center></font><br><font size=3><p align="right">弗雷德里克·布鲁克斯（Frederick P. Brooks）<br/>1999 年图灵奖获得者<br/>引自《神经网络与深度学习》</p><font></p><hr><hr><p>由于符号函数的不连续性，如果采用标准的均方误差，所得误差函数必然是不连续的，因而基于梯度的学习算法也就不能被使用。</p><hr><p>迭代思想</p><hr><h6 id='1'></h6><h2 id="1-感知机简介"><a href="#1-感知机简介" class="headerlink" title="1.感知机简介"></a>1.感知机简介</h2><h4 id="维基百科介绍"><a href="#维基百科介绍" class="headerlink" title="维基百科介绍:"></a>维基百科介绍:</h4><p>感知器（英语：Perceptron）是 Frank Rosenblatt 在 1957 年就职于康奈尔航空实验室（Cornell Aeronautical Laboratory）时所发明的一种人工神经网络。它可以被视为一种最简单形式的前馈神经网络，是一种二元线性分类器。</p><p>Frank Rosenblatt 给出了相应的感知机学习算法，常用的有感知机学习、最小二乘法和梯度下降法。譬如，感知机利用梯度下降法对损失函数进行极小化，求出可将训练数据进行线性划分的分离超平面，从而求得感知机模型。</p><p>感知机是生物神经细胞的简单抽象。神经细胞结构大致可分为：树突、突触、细胞体及轴突。单个神经细胞可被视为一种只有两种状态的机器——激动时为‘是’，而未激动时为‘否’。神经细胞的状态取决于从其它的神经细胞收到的输入信号量，及突触的强度（抑制或加强）。当信号量总和超过了某个阈值时，细胞体就会激动，产生电脉冲。电脉冲沿着轴突并通过突触传递到其它神经元。为了模拟神经细胞行为，与之对应的感知机基础概念被提出，如权量（突触）、偏置（阈值）及激活函数（细胞体）。<br><span><div style="text-align: center;"><br><img src="/%E7%94%9F%E7%89%A9%E7%A5%9E%E7%BB%8F.png" alt="生物神经"></p></div></span><p><span><div style="text-align: center;"><br><img src="/%E6%84%9F%E7%9F%A5%E6%9C%BA.png" alt="感知机"></p></div></span><p>在人工神经网络领域中，感知机也被指为单层的人工神经网络，以区别于较复杂的多层感知机（Multilayer Perceptron）。作为一种线性分类器，（单层）感知机可说是最简单的前向人工神经网络形式。尽管结构简单，感知机能够学习并解决相当复杂的问题。感知机主要的本质缺陷是它不能处理线性不可分问题。</p><h4 id="模型简述："><a href="#模型简述：" class="headerlink" title="模型简述："></a>模型简述：</h4><p>感知机（perceptron）是 二类分类的线性分类模型</p><ul><li>输入：实例的特征向量</li><li>输出：实例的类别，取 +1 和 -1 二值</li><li>类别：感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面，属于判别模型</li><li>目标：求出将训练数据进行线性划分的分离超平面，为此，导入基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型。</li><li>感知机学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。</li><li>预测：对新的输入进行分类</li></ul><p>感知机 1957 年由 Rosenblatt（罗森布拉特）提出，是神经网络与支持向量机的基础。</p><hr><h6 id='2'></h6><h2 id="2-感知机的历史"><a href="#2-感知机的历史" class="headerlink" title="2. 感知机的历史"></a>2. 感知机的历史</h2><p>摘自<a href="https://www.cnblogs.com/Determined22/p/6507329.html">机器学习 —— 基础整理（六）线性判别函数：感知器、松弛算法、Ho-Kashyap 算法</a></p><ul><li><p>1890 年，美国生物学家 W. James 出版了《Physiology》（生理学）一书，讲述有关人脑结构和功能，以及学习、记忆等基本规律，指出当两个基本处理单元同时活动，或两个单元靠得很近时，一个单元的兴奋状态会传递给另一单元，并且一个单元的活动程度与其周围的活动数量和密度成正比。</p></li><li><p>1943 年，Warren McCulloach, Walter Pitts 提出了著名的 MP 神经元模型，认为单元的输入存在兴奋边、抑制边两种，如果没有抑制边输入并且兴奋边的数量超过一个阈值，则神经元处于兴奋，否则处于抑制——这个模型给出了神经元的结构，使用阈值函数来输出，但所有输入边的权重都为 1，并且只要有一条抑制边输入那么就不可能兴奋。</p></li><li><p>1949 年，心理学家 Hebb 提出用于确定输入边权重的 Hebb 规则，该规则认为两个具有相同状态的神经元之间的权重要大。</p></li><li><p>1957 年，Frank Rosenblatt 提出感知器（Perceptron），随后在 IBM704 计算机上进行模拟从而证明了该模型有能力通过调整权重的学习达到正确分类的效果，第一次把神经网络从纯理论推到工程实践，掀起了研究高潮；在 1962 年感知器算法被证明是收敛的。</p></li><li><p>1960 年，Bernard Widrow 和 Ted Hoff 提出自适应线性单元（Adaptive linear neuron，ADALINE），学习规则也由 Hebb 规则转向 Delta 规则：利用实际输出与期望输出的误差来指导学习，即 LMS filter。</p></li><li><p>1969 年，Minsky 出版《Perceptron》，但同时指出感知器的两个问题：一个就是著名的“单层感知器无法解决异或（XOR，相异取真，相同取假）这样的线性不可分问题”，另外一个是这种局限在复杂结构中依然存在。不只是神经网络，整个 AI 都迎来寒冬。那时候晶体管还没有普及，大多是电子管（真空管），支持不了大规模计算。</p></li><li><p>1974 年，Paul Werbos 的博士论文里提出了 BP 算法（后被称为广义 Delta 规则），但是没有引起重视。<br>在 70 年代，据说全球只有几十个人在研究，但还是有一些成果：1976 年 Stephen Crossberg 的共振自适应理论（Adaptive resonance theory，ART 网络）、1979 年日本 Fukusima 的神经认知机（Neocognitron，将感受野应用到 NN）、80 年代芬兰 Kohonen 的自组织竞争神经网络等。</p></li><li><p>1982 年，物理学家 John Hopfield 提出 Hopfield 网络，基本思路是对于一个给定的神经网络，设计一个正比于每个神经元的活性和权重的能量函数，活性的改变算法向能量函数减小的方向进行，直到达到极小值。神经网络开始复兴。</p></li><li><p>1986 年，Rumelhart、Hinton、Williams 将 BP 应用到神经网络；1987 年，第一届世界神经网络大会在美国召开，千人参会。</p></li><li><p>1989 年，使用 sigmoid 激活的单隐层神经网络被证明可以逼近任意非线性函数；LeCun 的 CNN 用在文本识别；1990 年，RNN；1997 年，LSTM；2006 年，DBN，深度学习的概念被提出；2011 年，语音识别领域首先取得突破；2012 年，AlexNet 在 ImageNet 夺冠，引爆这个领域；2016 年，Alphago战胜世界围棋冠军李世石······</p></li></ul><h3 id="如何学习？"><a href="#如何学习？" class="headerlink" title="如何学习？"></a>如何学习？</h3><hr><h6 id='3'></h6><h2 id="3-线性回归与对规律的认知"><a href="#3-线性回归与对规律的认知" class="headerlink" title="3. 线性回归与对规律的认知"></a>3. 线性回归与对规律的认知</h2><h3 id="线性回归——函数近似机-x2F-逼近器"><a href="#线性回归——函数近似机-x2F-逼近器" class="headerlink" title="线性回归——函数近似机&#x2F;逼近器"></a>线性回归——函数近似机&#x2F;逼近器</h3><p>给出两个点我们就能确定一条线，即一个线性函数。进而我们可以用这个线性函数判断其他任意给出的点是否在此直线上。这一过程可以抽象一般化，理解为我们可以直接通过具体实例来倒推出一般函数，并可借助该函数进行判断和预测。在统计学中，这种类似的方法被称为线性回归。<br>所谓线性回归，是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。简单来说，线性回归就是指从几对输入值(x)和对应输出值(y)的实例中概括出一个一般函数。<br>线性回归是一个有着两百年历史的从一些输入输出对组中推断出一般函数的技巧。<strong>它的价值和意义在于很多函数难以给出明确的方程表达，但是，却很容易在现实世界搜集到输入值和输出值实例</strong>——比如，将说出来的词的音频作为输入，词本身作为输出的映射函数。</p><h3 id="由线性回归思考何为规律？"><a href="#由线性回归思考何为规律？" class="headerlink" title="由线性回归思考何为规律？"></a>由线性回归思考何为规律？</h3><h4 id="对规律性存在的假设"><a href="#对规律性存在的假设" class="headerlink" title="对规律性存在的假设"></a>对规律性存在的假设</h4><p>线性回归之所以可行，是因为假设存在一个线性模型作为规则决定着所有样本数据，并可通过具体数据逆推拟合出该线性模型。<br>线性回归可以抽象出一个重要的认知启示，即世界万物是存在其规律性的，规律无处不在，并蕴含在具体实例中、借由具体实例展现。</p><h4 id="规律的本质"><a href="#规律的本质" class="headerlink" title="规律的本质"></a>规律的本质</h4><p>规律的本质是函数，即不同事物间的映射关系</p><h4 id="规律的学习"><a href="#规律的学习" class="headerlink" title="规律的学习"></a>规律的学习</h4><p>规律不是虚无的，规律蕴含在具体特例中。因而规律是可以被归纳学习的，可以从具体的例子中学习。</p><hr><h6 id='4'></h6><h2 id="数学角度的分类问题与感知机"><a href="#数学角度的分类问题与感知机" class="headerlink" title="数学角度的分类问题与感知机"></a>数学角度的分类问题与感知机</h2><p>模式识别</p><h3 id="对分类问题的认知"><a href="#对分类问题的认知" class="headerlink" title="对分类问题的认知"></a>对分类问题的认知</h3><p>分类问题其实就是模式识别。我会容易将分类与比较混淆，但其实比较只是分类的方法而不是本质。分类的本质在于“识别”，在于研究并把握事物所具有的特有的属性的规律。事实上，我们在分类时，首先通过样例抽象总结出事物各属性特征的规律并建立对应的“类”的模型，当我们对新的个体分类时，我们将其特征与抽象模型相对比，进而将其分类。在此意义上，“比较”只是为了在抽象模型时能抓住核心属性特征而使用的方法，而不是“分类”本身。分类的核心是对特征规律——“模式”的识别与建模（表示）过程。<br>例如，图像识别是一种分类，从猫狗识别到人脸识别到自动驾驶中的交通标志检测都属于“认知”并“判断”的分类问题。<br><strong>因而分类可被理解为对事物的某一或某些性质进行研究，挖掘对比其中的规律性不同并进行划分。</strong><br>在机器学习中，这意味着寻找<strong>决策边界</strong>。</p><p>为什么要分类？<br>我们分类除了为了认知世界&#x2F;事物，更重要的是改造世界&#x2F;事物，是为了应用。要想理解分类问题，我们就要搞懂分类的目的与需求。<strong>实际上我们之所以分类是为了针对不同种类事物具有的特定规律&#x2F;特征，对它们采取不同的应对和处理策略。我们不仅对事物的类别本身进行抽象建模，我们也对其对应的特有的应对和处理策略建立对应的模式行为。这是因为不同事物由于其特征不同，其价值、功能、用途、需求等也对应着不同。</strong></p><p>在机器学习中，广告点击行为预测、O2O优惠券使用预测、基于文本内容的垃圾短信识别等应用就是为了更好个性化应对不同类别的人&#x2F;事物而进行的分类问题。</p><h3 id="数学角度的分类问题"><a href="#数学角度的分类问题" class="headerlink" title="数学角度的分类问题"></a>数学角度的分类问题</h3><p>超平面。</p><h4 id="何为函数"><a href="#何为函数" class="headerlink" title="何为函数"></a>何为函数</h4><h3 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h3><p>所谓模型是指为了某个特定目的将原型的某一部分信息简缩、提炼而构造的原型替代物。可以发现，为了研究事物与问题，我们往往必须通过建模的方式来处理复杂信息、了解事物。建模可谓是研究实际问题的必备方法。</p><p>而数学作为精确描述数量关系、空间形式的语言、逻辑推理的载体，是精确研究事物的必要条件。因而，我们需要在研究问题时建立适当的数学模型，将实际问题与数学工具连接起来。一般地说，数学建模可以描述，对于现实世界的一个特定对象，为了一个特定目的，根据特有的内在规律，做出一些必要的简化假设，运用适当的数学工具，得到的一个数学结构。</p><p>数学建模中两种基本方法：机理分析与测试分析。机理分析是根据对客观事物特性的认识，找出反应内部机理的数量规律，建立的模型常有明确的物理或现实意义。<strong>测试分析是将研究对象看作一个“黑箱”系统（意思是它的内部机理看不清楚），通过对系统输入、输出数据的测量和统计分析，按照一定的准则找出与数据拟合得最好的模型</strong>。</p><p>对于许多实际问题还常常将两种方法结合起来建模，即<strong>用机理分析建立模型的结构，用测试分析确定模型的参数</strong>。</p><p>上述内容大多摘自《数学模型》一书。我觉得非常有趣的是，这基本就是在描述机器学习中的构建方法。</p><h3 id="从数学建模角度理解感知机"><a href="#从数学建模角度理解感知机" class="headerlink" title="从数学建模角度理解感知机"></a>从数学建模角度理解感知机</h3><p>正如上文所说机器学习中所谓模型的构建过程基本上就是数学建模的过程——通过机理分析建立模型的结构，通过测试分析确定模型的参数。只不过在数学建模中，我们是通过最小二乘法、凸优化的人工进行拟合，而在机器学习中我们设计优化算法，让计算机自己进行拟合和参数确定。</p><p>在此意义上，感知机不过是通过机理分析确定一个线性超平面模型，并设计了一个学习规则&#x2F;优化算法，借助训练实例，让计算机来确定超平面的权重和偏置参数。</p><hr><h6 id='4'></h6><h2 id="4-MP-神经元模型——逻辑运算的实现"><a href="#4-MP-神经元模型——逻辑运算的实现" class="headerlink" title="4. MP 神经元模型——逻辑运算的实现"></a>4. MP 神经元模型——逻辑运算的实现</h2><p>1943 年，沃伦·麦卡洛克（Warren McCulloch）和沃尔特·皮茨（Walter Pitts）在研究生物神经元时指出，具有二进制阈值激活功能的神经元能够实现一阶逻辑推理，并抽象出 MP 神经元模型。</p><h4 id="原始的-MP-神经元模型"><a href="#原始的-MP-神经元模型" class="headerlink" title="原始的 MP 神经元模型"></a>原始的 MP 神经元模型</h4><p>早期的 MP 神经元具有一个或多个二进制（开&#x2F;关）输入和一个二进制输出。当超过一定数量的输入处于激活状态时，人工神经元将激活其输出。McCulloch 和 Pitts 的论文表明即使使用这样的简化模型，也可以构建一个人工神经元来计算所需的任何逻辑命题。</p><p><span><div style="text-align: center;"></p><p><img src="/%E6%97%A9%E6%9C%9FMP%E7%A5%9E%E7%BB%8F%E5%85%83.png" alt="早期MP神经元.png"></p></div></span><p>例如，如上图，我们可以构建一些神经元，假设神经元至少有两个输入处于激活状态时，神经元就会被激活，则我们可实现多种逻辑运算：</p><ol><li>左边的第一个网络是一个简单的恒等函数：如果神经元 A 被激活，那么神经元 C 也被激活（因为它从神经元 A 接受到两个输入信号），如果神经元 A 关闭，那么神经元 C 也关闭。<br>值得注意的是，在这里，每个神经元可以有多个信号相同的输出。</li><li>第二个网络计算逻辑“与”（AND)：只有当神经元 A 和 B 都处于激活状态，神经元 C 才会激活（单独的一个输入信号并不足以激活神经元 C）。</li><li>第三个网络计算逻辑“或”（OR)：如果神经元 A 或 B 中有一个（或者两者都）处于激活状态时，神经元 C 就会被激活。</li><li>最后，如果我们假设输入连接可以抑制神经元的活动（正如生物神经网络中那样），那么第四个网络计算的就是一个比较复杂的逻辑命题：只有在神经元 A 是激活而且神经元 B 是关闭时，神经元 C 才会处于激活状态。如果神经元 A 一直处于激活状态，那你就得到了逻辑“非”（NOT)：神经元关闭时神经元 C 处于激活状态，反之亦然。</li></ol><h4 id="原始-MP-神经元的问题——权重的缺失"><a href="#原始-MP-神经元的问题——权重的缺失" class="headerlink" title="原始 MP 神经元的问题——权重的缺失"></a>原始 MP 神经元的问题——权重的缺失</h4><p>早期 MP 神经元没有引入“权重概念”，模型过于简单、只能输入相同的激活信号或抑制信号并结合阈值来控制，这显然是无法解决复杂问题的，因为究其本质，它不过只能处理一些离散的、整数形式的简单加减运算而已。由于信号全是相同的，只能通过调节输入数量来调节输出，这显然要预先人工设计且没什么实际功用。</p><p>因而，我们必须引入每个指标对不同输入信号进行区别对待与处理，使每个信号都不同。</p><h4 id="引入权重概念的-MP-神经元"><a href="#引入权重概念的-MP-神经元" class="headerlink" title="引入权重概念的 MP 神经元"></a>引入权重概念的 MP 神经元</h4><p>伴随着感知机的出现，MP 神经元被引入权重概念。在这个模型中，神经元接收到来自 n 个其他神经元传递过来的输入信号，这些输入信号通过带权重的连接(connection)进行传递神经元接收到的总输入值将与神经元的阙值进行比较，然后通过 “激活函数” (activation function)处理以产生神经元的输出。MP 神经元采用的激活函数是阶跃函数，它将输入值映射为输出值“0”或“1”,显然“1”对应于神经元兴奋，“0”对应于神经元抑制。</p><p>引入权重概念是具有实际意义的，一方面通过权重每个输入信号都是独特的，并且不再只能取“激活”“抑制”两个定性整数值，每个信号都能定量化为任意大小的数值，这种差异性、数值的任意性才能用来表示各种不同的信息；同时权重起到了对信号重要性的评估作用，以及控制信号流动难度和信息处理、筛选、压缩的作用。</p><p><span><div style="text-align: center;"></p><p><img src="/MP%E7%A5%9E%E7%BB%8F%E5%85%83.png" alt="MP神经元"></p></div></span><p>引入权重的 MP 神经元模型能更方便的实现一阶逻辑“与”“或”“非”运算，如：</p><ul><li>逻辑“与”($x_1\land x_2$)：令$\omega_1&#x3D;\omega_2&#x3D;1,\theta&#x3D;2$，则$y&#x3D;f(1\cdot x_1+1\cdot x_2-2)$，仅在$x_1&#x3D;x_2&#x3D;1$时，$y&#x3D;1$；<br/></li><li>逻辑“或”($x_1\lor x_2$)：令$\omega_1&#x3D;\omega_2&#x3D;1,\theta&#x3D;0.5$，则$y&#x3D;f(1\cdot x_1+1\cdot x_2-0.5)$，$x_1&#x3D;1$或$x_2&#x3D;1$时，$y&#x3D;1$；<br/></li><li>逻辑“非”($x_1\lnot x_2$)：令$\omega_1&#x3D;-0.6,\omega_2&#x3D;0,\theta&#x3D;-0.5$，则$y&#x3D;f(-0.6\cdot x_1+0\cdot x_2+0.5)$，当$x_1&#x3D;1$时$y&#x3D;0$；当$x_1&#x3D;0$时，$y&#x3D;1$；</li></ul><h3 id="MP-神经元的问题——逻辑运算并不能实现学习"><a href="#MP-神经元的问题——逻辑运算并不能实现学习" class="headerlink" title="MP 神经元的问题——逻辑运算并不能实现学习"></a>MP 神经元的问题——逻辑运算并不能实现学习</h3><p>在人工智能的早期时代，主流思想认为，如果计算机能够做正式的逻辑推理，则将本质上解决人工智能问题。然而，事实证明，只实现简单逻辑推理并不能解决智能问题。所谓逻辑运算不过是简单的离散线性运算而已，由于权重的值都是预先设置的，因而这种线性运算只能用于预先人工设置好权重值的特定问题，没有推广能力。</p><p>简单来说，权重固定的 MP 神经元不具有学习能力。</p><p>而为了让神经元具有学习能力，我们应该思考的是学习为何、学习有哪些方法、我们通过何种方法能表征学习的过程。下面我们将介绍1949年Hebb对这一问题的一些见解以及联结主义思想。</p><hr><h6 id='5'></h6><h2 id="5-如何学习——联结主义对学习的理解"><a href="#5-如何学习——联结主义对学习的理解" class="headerlink" title="5. 如何学习——联结主义对学习的理解"></a>5. 如何学习——联结主义对学习的理解</h2><p>联结主义是 20 世纪初美国心理学家 E.L.桑代克在对动物实验研究的基础上提出的一种学习心理学理论。认为情境感觉和动作冲动反应之间形成的联结是学习的基础，也是心理行为的基本单位。“联结”一词，意指实验动物对笼内情境的感觉和反应动作的冲动之间形成的联系或联想。</p><p>在联结主义中，Hebb的观点直接启发了感知机的诞生。</p><h4 id="桑代克的研究"><a href="#桑代克的研究" class="headerlink" title="桑代克的研究"></a>桑代克的研究</h4><p>桑代克的联结主义以经验论为理论基础。</p><p>桑代克认为，联结是行为的基本单元。他把行为区分为先天的反应趋势和习得的反应趋势两类：前一类的反应趋势或联结主要是本能，后一类的反应趋势或联结主要是习惯。本能是不经学习的先天联结，习惯是后天习得的联结。</p><p>桑代克根据对动物学习实验的研究，认为学习的基本方式是尝试错误式的学习。动物由多次“尝试错误与偶然成功”形成联结而完成学习；桑代克并具体提出练习律、效果律、准备律等学习定律(参见“试误学习”)。桑代克对这些学习定律进行了修订和补充。他提出“相属原则”修订练习律，认为相属的容易造成联结，不相属的不容易造成联结。另外指出赏和惩的效果并不相等，奖赏比惩罚更为有效，这就用奖赏补充了效果律。</p><h4 id="赫布规则"><a href="#赫布规则" class="headerlink" title="赫布规则"></a>赫布规则</h4><p>1949 年， 心理学家唐纳德·赫布（Donald Hebb）在研究神经元的基础上提出了一个关于学习观念的出人意料并影响深远的想法。在他的《行为的组织》一书中，赫布声称知识和学习发生在大脑主要是依靠神经元间突触的形成与变化，简要表述为赫布规则：</p><p><strong>当细胞 A 的轴突足以接近以激发细胞 B，并反复持续地对细胞放电，一些生长过程或代谢变化将发生在某一个或这两个细胞内（如激活阈值减小，联系增强），以致 A 作为对 B 放电的细胞中的一个，效率增加。</strong></p><p>赫布认为这种活动是学习和记忆所必需的基本操作之一。</p><h4 id="赫布规则的启示"><a href="#赫布规则的启示" class="headerlink" title="赫布规则的启示"></a>赫布规则的启示</h4><p>赫布规则认为学习与记忆不是直接映射性的编码，而是储存在网络的连接中。</p><p>赫布规则同时也启示了神经网络中的Hebb学习规则，可用于无监督学习和有监督学习。</p><h4 id="认知心理学中的联结主义"><a href="#认知心理学中的联结主义" class="headerlink" title="认知心理学中的联结主义"></a>认知心理学中的联结主义</h4><p>20 世纪 80 年代初，认知心理学中兴起的一种认知研究范式，亦即网络模型。联结主义的指导性启示和主要灵感来自大脑或神经系统，<strong>它把认知看成是网络的整体活动</strong>。网络是个动态的系统，它由类似于神经元的基本单元和结点构成，每个单元都有不同的活性。随着时间的衰减，外部输入和其他单元的活性传递都会使一个单元的静息活性发生动态的改变。联结主义赋予网络以核心性的地位，采纳<strong>分布表征和并行加工理论</strong>，强调的是网络的并行分布加工，注重的是网络加工的数学基础。20 世纪 80 年代以来，网络取向的联结主义取代了符号取向的认知主义，成为现代认知心理学的理论基础。</p><p>关于赫布理论和联结主义的更多内容可见以下链接：</p><ol><li><a href="https://baike.baidu.com/item/%E8%B5%AB%E5%B8%83%E7%90%86%E8%AE%BA/8347084?fr=aladdin">百度百科 赫布理论</a></li><li><a href="https://zhuanlan.zhihu.com/p/89446215">长文干货！联结主义大百科</a></li><li><a href="https://baijiahao.baidu.com/s?id=1633799033897948093&wfr=spider&for=pc">符号主义和联结主义 AI，都是什么鬼？</a></li><li><a href="https://zhuanlan.zhihu.com/p/20648971">顾险峰：人工智能中的联结主义和符号主义</a></li><li><a href="http://www.360doc.com/content/16/0613/12/16295112_567379244.shtml">认知神经的可塑性：赫布理论的哲学意蕴</a></li><li><a href="https://zhuanlan.zhihu.com/p/19939960">三大神经科学基本定律</a></li></ol><hr><h6 id='5'></h6><h2 id="5-Rosenblatt-对记忆与感知的理解"><a href="#5-Rosenblatt-对记忆与感知的理解" class="headerlink" title="5. Rosenblatt 对记忆与感知的理解"></a>5. Rosenblatt 对记忆与感知的理解</h2><p>罗森布拉特在 1957 年的论文中开篇便以比较的方式阐述了他对记忆与感知的基于生物学假设的认知。</p><p>由于本人英语和生物学、数学水平浅薄，对该论文只进行了粗略阅读，但仍很受启发。在这里，我简单列举出其中简单内容，完整内容见《Rosenblatt, Frank. x. (1958), The Perceptron: A Probabilistic Model for Information Storage and Organization in the Brain》</p><h4 id="关于记忆与感知的两种观点————硬式编码与联结主义"><a href="#关于记忆与感知的两种观点————硬式编码与联结主义" class="headerlink" title="关于记忆与感知的两种观点————硬式编码与联结主义"></a>关于记忆与感知的两种观点————硬式编码与联结主义</h4><p>在论文开篇，Rosenblatt 首先提出了三个问题：</p><ol><li>物质世界的信息是如何被生物系统感知或探测到的？</li><li>信息以何种形式储存或记忆？</li><li>储存或记忆中的信息是如何影响认知和行为的？<br>他针对第二、三问列举了当时两个不同立场的观点：</li></ol><ul><li>第一种观点是机械式的编码记忆与硬式存储，认为感官信息的储存是以编码形式或图像的形式存在的，在感官刺激之间存在某种一对一映射关系和存储模式，因而原则上这种记忆是可以进行还原、重建与复制的。围绕这一假设，当时发展出围绕编码、符号逻辑的大脑模型。表征记忆的概念发展起来。<br>这一观点必然得出这样的结论：对任何刺激的识别都涉及到将存储的内容与进入的感觉模式进行匹配或系统的比较，以便确定当前的刺激是否在之前被看到过，并确定机体的适当反应。因而这种识别需要一个单独的系统与进程。</li><li>另一种观点则是联结主义。联结主义认为感官刺激的信息或图片可能并没有被真正直接记录和存储。信息被包含在连接或关联中。刺激不会被简单地映射到记忆中，信息被以某种方式存储为对特定响应地偏好。而新的刺激会在原有连接基础上自动激活适当的响应、形成新的连接而不需要一个单独的系统与进程进行识别。因而，在这一观点下，智能系统的识别功能的一般化、普适化的，而不局限于特定的、需要已知的条件。</li></ul><h4 id="Rosenblatt-的观点"><a href="#Rosenblatt-的观点" class="headerlink" title="Rosenblatt 的观点"></a>Rosenblatt 的观点</h4><p>Rosenblatt 的感知机模型采用后一种观点。用他的原话说：“感知机的设计是为了说明一般智能系统的一些基本特性，而不是过于深入地沉浸在特殊的、通常是未知的条件中。”</p><p>他把感知机描述为“在一个随机刺激的环境中，一个由随机连接的单元组成的系统，受上面讨论的参数约束，可以学会将特定的反应与特定的刺激联系起来。即使许多刺激与每一种反应相关，它们仍然可以被更好的概率识别，尽管它们可能彼此非常相似，并可能激活许多相同的感官输入到系统。”</p><p>他把感知机的学习归结为一种建立在概率基础上的迭代试错学习。</p><h4 id="采用概率语言而非符号逻辑"><a href="#采用概率语言而非符号逻辑" class="headerlink" title="采用概率语言而非符号逻辑"></a>采用概率语言而非符号逻辑</h4><p>感知机模型构建的一个问题是表示语言的选用。当时神经网络研究的一个主要问题是对于一个包含许多随机连接的不完善的神经网路，如何能够可靠地执行那些可能由理想化的接线图所表示的功能。然而当时研究人工智能最常用的符号逻辑和布尔代数语言不太适合这样的研究。需要一种合适的语言来对系统中的事件进行数学分析。在这些系统中，只有总体的组织可以被描述出来，而精确的结构是未知的，这导致 Rosenblatt 选用概率论而不是符号逻辑来制定感知机模型。<br>（不同于现在我们学到的感知机算法，在他当时的论文中，Rosenblatt 是使用概率来解释感知机的。之所以强调这一点，只因为这恰恰呼应了后来统计学习方法相关理论的发展，采用概率构建学习模型。这是很有趣的。）</p><hr><h6 id='6'></h6><h2 id="6-感知机的学习观"><a href="#6-感知机的学习观" class="headerlink" title="6. 感知机的学习观"></a>6. 感知机的学习观</h2><h3 id="感知机背后涉及的一些学习方法"><a href="#感知机背后涉及的一些学习方法" class="headerlink" title="感知机背后涉及的一些学习方法"></a>感知机背后涉及的一些学习方法</h3><h4 id="归纳推理——基于例子的学习"><a href="#归纳推理——基于例子的学习" class="headerlink" title="归纳推理——基于例子的学习"></a>归纳推理——基于例子的学习</h4><p>归纳推理是一种由个别到一般的推理。由一定程度的关于个别事物的观点过渡到范围较大的观点，由特殊具体的事例推导出一般原理、原则的解释方法。自然界和社会中的一般，都存在于个别、特殊之中，并通过个别而存在。一般都存在于具体的对象和现象之中，因此，只有通过认识个别，才能认识一般。人们在解释一个较大事物时，从个别、特殊的事物总结、概括出各种各样的带有一般性的原理或原则，然后才可能从这些原理、原则出发，再得出关于个别事物的结论。这种认识秩序贯穿于人们的解释活动中，不断从个别上升到一般，即从对个别事物的认识上升到对事物的一般规律性的认识。例如，根据各个地区、各个历史时期生产力不发展所导致的社会生活面貌落后，可以得出结论说，生产力发展是社会进步的动力，这正是从对于个别事物的研究得出一般性结论的推理过程，即归纳推理。显然，归纳推理是从认识研究个别事物到总结、概括一般性规律的推断过程。在进行归纳和概括的时候，解释者不单纯运用归纳推理，同时也运用演绎法。在人们的解释思维中，归纳和演绎是互相联系、互相补充、不可分割的。<br><a href="https://baike.baidu.com/item/%E5%BD%92%E7%BA%B3%E6%8E%A8%E7%90%86?fromtitle=%E5%BD%92%E7%BA%B3%E6%B3%95&fromid=120098">百度百科链接</a></p><h4 id="试错法——逐步调整"><a href="#试错法——逐步调整" class="headerlink" title="试错法——逐步调整"></a>试错法——逐步调整</h4><p>通过不断试验和消除误差，探索具有黑箱性质的系统的方法。这种方法在动物的行为中是不自觉地应用的，在人的行为中则是自觉的。试错法是纯粹经验的学习方法。应用试错法的主体通过间断地或连续地改变黑箱系统的参量，试验黑箱所作出的应答，以寻求达到目标的途径。主体行为的成败是用它趋近目标的程度或达到中间目标的过程评价的。趋近目标的信息给主体，主体就会继续采取成功的行为方式；偏离目标的信息反馈给主体，主体就会避免采取失败的行为方式。通过这种不断的尝试和不断的评价，主体就能逐渐达到所要追求的目标。<br><a href="https://baike.baidu.com/item/%E8%AF%95%E9%94%99%E6%B3%95">百度百科链接</a></p><h4 id="迭代法——重复执行，逐步优化"><a href="#迭代法——重复执行，逐步优化" class="headerlink" title="迭代法——重复执行，逐步优化"></a>迭代法——重复执行，逐步优化</h4><p>迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程，跟迭代法相对应的是直接法(或者称为一次解法)，即一次性解决问题。迭代算法是用计算机解决问题的一种基本方法，它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令(或一定步骤)进行重复执行，在每次执行这组指令(或这些步骤)时，都从变量的原值推出它的一个新值，迭代法又分为精确迭代和近似迭代。比较典型的迭代法如“二分法”和”牛顿迭代法”属于近似迭代法。<br><a href="https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3%E6%B3%95/10913188">百度百科链接</a></p><h3 id="感知机的大胆假设"><a href="#感知机的大胆假设" class="headerlink" title="感知机的大胆假设"></a>感知机的大胆假设</h3><p>我们如果能够掌握大量例子，我们就能掌握规律本身。而掌握规律可以用试错的方法进行。概率中的大数定理等都映照着这种假设。照应于前文，显然，这种假设结合了经验主义、归纳学习、迭代试错逐步调整等思想。</p><p>这个假设使我认为感知机所隐含的很基础的不足为奇的假设。然而作为初学者，这一观点对于我仍是很有趣的，因为我从没有思考过相关的认知的问题，并且就像费曼所说的那样，太多太多时候我总陷入概念的世界里而并不了解背后的真实事物本身及其内在机理。</p><p>另一方面，这一假设显然是有问题的。比如在学习EM算法时我就了解到还有“隐变量”这一概念，显然，直接学习大量例子是不能很好应对这一问题的，换句话说学习实例也是需要相关的数学方法与技巧的。又如例子的代表性、先验分布等。</p><p>但我仍觉得这一观点是值得强调的。</p><h3 id="感知机与传统方法的区别"><a href="#感知机与传统方法的区别" class="headerlink" title="感知机与传统方法的区别"></a>感知机与传统方法的区别</h3><p>传统方法试图直接求解函数的参数而感知机以迭代的方法让计算机自己学习函数的参数</p><h3 id="试错的方法与试错的效率问题"><a href="#试错的方法与试错的效率问题" class="headerlink" title="试错的方法与试错的效率问题"></a>试错的方法与试错的效率问题</h3><hr><h6 id='7'></h6><h2 id="7-感知机模型"><a href="#7-感知机模型" class="headerlink" title="7.感知机模型"></a>7.感知机模型</h2><p>感知机定义：</p><ul><li>输入空间： $X\subseteq  R^n$</li><li>输出模型： $Y &#x3D; {+1,-1}$</li><li>$x \subset X$表示实例的特征向量，$y \subset Y$表示实例类别</li><li>输入空间到输出空间的函数（感知机模型）：<br>$$f(x) &#x3D; sign(\omega\cdot x + b)$$</li><li>参数：$\omega权重向量，b偏置$</li><li>$sign()$是符号函数,属于阶跃函数：<br>$$sign(x) &#x3D; \begin{cases}+1, x\geq0\-1,x&lt;0\\end{cases}$$</li><li>感知机是线性分类模型，判别模型</li><li>几何解释：线性方程$$\omega\cdot x + b$$对应 n 为空间的一个超平面，$\omega$是其法向量，b 是其截距。<br>超平面将特征向量划分为两个部分，位于两部分的点（特征向量）分别被分成正、负两类<br><span><div style="text-align: center;"><br><img src="/%E8%B6%85%E5%B9%B3%E9%9D%A2.png" alt="超平面"></div></span></li></ul><p>####问题思考<br><a href="">对于超平面的理解？</a></p><hr><h6 id='3'></h6><h2 id="3-感知机学习策略"><a href="#3-感知机学习策略" class="headerlink" title="3.感知机学习策略"></a>3.感知机学习策略</h2><h4 id="数据集的线性可分行："><a href="#数据集的线性可分行：" class="headerlink" title="数据集的线性可分行："></a>数据集的线性可分行：</h4><ul><li>给定数据集$T &#x3D; {(x_1,y_1),(x_2,y_2)\cdots(x_N,y_N)}$,如果存在一个超平面$$\omega\cdot x + b$$能够将数据集的所有正实例点和负实例点完全正确地划分在平面两侧，则其线性可分，称 T 为线性可分数据集，否则线性不可分</li><li>感知机只能处理线性可分问题 ####感知机学习的假设</li><li>感知机学习的重要前提假设是训练数据集是线性可分的。</li></ul><h4 id="感知机的学习策略"><a href="#感知机的学习策略" class="headerlink" title="感知机的学习策略"></a>感知机的学习策略</h4><p>感知机的学习目标是正确分类，即为了找到将正负实例正确分开的分离超平面。为了找到这样的超平面,即确定感知机模型参数$\omega,b$，觉需要确定参数的评价指标，确定学习策略</p><ul><li>策略：定义（经验）损失函数（误分类点到超平面 S 的总距离），并将其极小化 ####感知机的损失函数</li><li>损失函数的一个自然选择是误分类点的总数，但是这样的损失函数不是参数$\omega,b$的连续可导函数，不易优化。</li></ul><p>（这里的详细理解要结合感知机损失函数的最优化方法——梯度下降法的原理来理解，详见<a href="">感知机进一步解释</a>）</p><ul><li><p>由上，我们选择误分类点到超平面 S 的总距离这一连续可导量作为损失函数</p></li><li><p>任意一点$x_0$到超平面 S 的距离：$\frac{1}{||\omega||}|\omega\cdot x_0 + b|$, 其中$||\omega||_2$是$\omega$的$L_2$范数</p></li><li><p>所有误分类的点记得集合为 M，所有误分类点到超平面 S 的总距离为：<br>$$L(\omega,b) &#x3D; - \frac{1}{||\omega||}\sum_{x_i \in M}y_i(\omega\cdot x_i + b)$$</p></li><li><p>损失函数：不考虑分母范数$\frac{1}{||\omega||}$，错误的点 $y_i(\omega\cdot x_i+b) &lt; b$，取距离为正，则感知机的损失函数（经验风险函数）为：<br>$$L(\omega,b) &#x3D; - \sum_{x_i \in M}y_i(\omega\cdot x_i + b)$$</p></li><li><p>显然损失函数$L(\omega,b)$是非负的。如果没有误分类点，损失函数值是 0。而且误分类点越少，误分类点离超平面越近，损失函数值就越小。</p></li><li><p>对于一个特定样本点的损失函数：在误分类时是参数$\omega,b$的线性函数，在正确分类时是 0。因此给定训练数据集 T，损失函数$L(\omega,b)$是$\omega,b$的连续可导函数</p></li><li><p>此时感知机学习问题转化为损失函数的最优化，即选择使上面损失函数最小的模型参数$\omega,b$</p></li></ul><h4 id="问题思考："><a href="#问题思考：" class="headerlink" title="问题思考："></a>问题思考：</h4><p><a href="">为什么能不考虑分母范数?<br>以距离作为损失函数很巧妙，但感知机能否还有其他损失函数？</a></p><hr><h6 id='4'></h6><h2 id="4-最初的感知机算法与其问题"><a href="#4-最初的感知机算法与其问题" class="headerlink" title="4.最初的感知机算法与其问题"></a>4.最初的感知机算法与其问题</h2><p>值得注意的是感知机学习规则、Hebb学习规则、以LMS算法、BP算法为代表的随机梯度下降法三者在应用在感知机模型上是形式上相似，加上现在感知机学习规则已不再被使用，一般书籍介绍都直接使用随机梯度下降法，故对于初学者容易混淆。实际上最初的感知机算法虽然采用迭代的方法，但没有采用随机梯度下降法，而使用感知机学习规则。这一点我觉得在《神经网络设计》这本书中讲解较为清楚，可参阅。</p><hr><h6 id='4.1'></h6><h3 id="4-1-最初感知机的学习思路"><a href="#4-1-最初感知机的学习思路" class="headerlink" title="4.1 最初感知机的学习思路"></a>4.1 最初感知机的学习思路</h3><p>发展了一种迭代、试错、类似于人类学习过程的学习算法——感知机学习。除了能够识别出现较多次的字母，感知机也能对不同书写方式的字母图像进行概括和归纳。</p><p>通过调整输出值的权重来学函数。对于每个实例，若感知机的输出值比实际值低太多，则增加它的权重若输出值比实际值高太多，则减小它的权重。</p><hr><h6 id='4.2'></h6><h3 id="4-2-最初的感知机算法"><a href="#4-2-最初的感知机算法" class="headerlink" title="4.2 最初的感知机算法"></a>4.2 最初的感知机算法</h3><p>基于感知机学习规则</p><ul><li>最原始状态</li></ul><ol><li>随机选择$\omega$和$b$</li><li>取一个训练样本$(x_i,y_i)$<br>若$\omega \cdots x+b&gt;0$且$y&#x3D;-1$，则：$$\omega&#x3D;\omega-x b&#x3D; b-1$$<br>若$\omega \cdots x+b&lt;0$且$y&#x3D;+1$，则：$$\omega&#x3D;\omega+x b&#x3D; b+1$$</li><li>再取另一个$(x_j,y_j)$，回到步骤 2</li><li>终止条件：直到所有输入输出对都不满足步骤 2 中两种情况，退出循环</li></ol><ul><li>在《机器学习》一书中也写作以下方式：<br>对训练样例$(x,y)$，若当前感知机的输出为$\hat{y}$，则感知机权重将这样调整：$$\begin{array}{l}\omega\leftarrow\omega_i+\Delta\omega_i,\\\Delta\omega_i&#x3D;\eta(y-\hat{y})x_i\end{array}$$其中，$\eta$称为学习率。从此算法可以看出，若感知机对训练样例$(x,y)$预测正确，即$\hat{y}&#x3D;y$，则感知机不发生变化，否则将根据错误的程度进行权重调整。</li></ul><hr><h6 id='4.3'></h6><h3 id="4-3-最初感知机算法的问题"><a href="#4-3-最初感知机算法的问题" class="headerlink" title="4.3 最初感知机算法的问题"></a>4.3 最初感知机算法的问题</h3><hr><h6 id='5'></h6><h2 id="5-自适性线性单元（ADALINE-与LMS算法——更加结合优化理论的模型"><a href="#5-自适性线性单元（ADALINE-与LMS算法——更加结合优化理论的模型" class="headerlink" title="5.自适性线性单元（ADALINE)与LMS算法——更加结合优化理论的模型"></a>5.自适性线性单元（ADALINE)与LMS算法——更加结合优化理论的模型</h2><p>罗森布莱特在阐述感知机时更强调其生物上的可解释性，而 1960 年，Bernard Widrow和Tedd Hoff探索的新模型——自适性线性单元在数学方法上对感知机进行了更深入的改进。<br>在自适性线性单元中，他们将阈值阶跃激活函数改为连续可导的线性函数，并引入均方误差损失函数和随机梯度下降法。这样的模型在数学上更美，因为<font color='red'>这样神经元的学习机制就变为了基于将误差最小化的微积分。</font></p><hr><h6 id='5.1'></h6><h3 id="5-1-自适性线性单元（ADALINE"><a href="#5-1-自适性线性单元（ADALINE" class="headerlink" title="5.1 自适性线性单元（ADALINE)"></a>5.1 自适性线性单元（ADALINE)</h3><p>这个输出是输入特征的线性组合，所以自适性线性单元解决的问题与线性回归解决的问题完全相同，但解决问题的方法完全不同：线性回归用最小二乘法求解，不太适合于计算机的求解：而自适性线性单元是基于detla法则（即随机梯度下降法）使用LMS算法迭代求解的。</p><hr><h3 id="delta学习法则"><a href="#delta学习法则" class="headerlink" title="delta学习法则"></a>delta学习法则</h3><p>delta法则的思想：基于训练集构造一个损失函数，将感知机的训练问题转化为求损失函数的最小化问题，从而利用梯度下降法等迭代方法去逐步逼近最佳参数。</p><h3 id="均方误差——损失函数的建立"><a href="#均方误差——损失函数的建立" class="headerlink" title="均方误差——损失函数的建立"></a>均方误差——损失函数的建立</h3><p>在样本集中，数据的标签是$y$，而模型预测值是$\hat{y}$，两者之间存在误差$y-\hat{y}$,而为了是模型预测准确，我们的目标自然是使误差最小，于是我们建立目标函数&#x2F;损失函数——均方误差$$E&#x3D;\frac{1}{2}\sum\limits_k(y_k-t_k)^2$$其中，$y_k$表示神经网络的输入，$t_k$表示监督数据，$k$表示数据的维数。</p><p>学习的目标就是使均方误差最小。</p><p>在统计学的贝叶斯推断中就涉及贝叶斯最小均方估计和线性最小均方估计，并且我们知道在所有基于X的$\Theta$的估计量$g(x)$中，条件期望$g(x)&#x3D;E(\Theta|X)$是使条件均方误差$E[(\Theta-\hat{\theta})^2|X&#x3D;x]$达到最小的量。同时，当$\Theta$的后验分布是关于（条件）均值对称并且是单峰的时（如正态分布），最大后验分布和条件期望估计量相同。而在经典统计推断中，我们称均方误差为残差平方和。</p><p>不同于统计学，在机器学习中我们更常用数值计算的方法（如梯度下降）求解最优解。</p><h3 id="为什么要建立损失函数的概念？——学习效果与模型性能需要评价指标"><a href="#为什么要建立损失函数的概念？——学习效果与模型性能需要评价指标" class="headerlink" title="为什么要建立损失函数的概念？——学习效果与模型性能需要评价指标"></a>为什么要建立损失函数的概念？——学习效果与模型性能需要评价指标</h3><p>”学习“是指训练数据中自动获取最优权重参数进而对测试数据做出更好预测的过程。为了评价模型的学习效果，使其正确的学习，就需要引入一个评价指标用来度量模型预测性能的好坏。只有评价指标建立了，学习的指导方向就确立了，进而才方便调整与改进。<br>因而我们引入损失函数和风险函数的概念。它们都是表示和评价模型性能的“恶劣程度”的指标。其中损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。<br>我们通过这些指标表示模型当前的学习状态，并以该指标为基准，进一步寻找最优权重参数。此时，学习问题就转化为损失函数的最优化问题，寻找使损失函数的值尽可能小的参数。</p><h3 id="3-为什么不是直接度量学习性能有多好而是有多坏？又为什么不计算失败个数"><a href="#3-为什么不是直接度量学习性能有多好而是有多坏？又为什么不计算失败个数" class="headerlink" title="3.为什么不是直接度量学习性能有多好而是有多坏？又为什么不计算失败个数"></a>3.为什么不是直接度量学习性能有多好而是有多坏？又为什么不计算失败个数</h3><p>为什么我们不直接以预测成功率或图像识别精度作为评价指标？成功率是以成功的实例的个数为丈量的，因而在训练数据的数量有限时，成功率的值只能以不连续的，离散的形式变化（类比于阶跃函数）。因而如果以其作为指标时，则参数的导数在绝大多数地方都会变成0。这将导致成功率对微小的参数变化基本没有什么反应（没有敏感性），即便有反应，它的值也是不连续地、突然变化的，不利于最优化学习。</p><h6 id='5.2'></h6><h3 id="5-2-梯度下降法（BGD"><a href="#5-2-梯度下降法（BGD" class="headerlink" title="5.2 梯度下降法（BGD)"></a>5.2 梯度下降法（BGD)</h3><p>根据微积分的知识：$\omega_{opt},b_{opt}$为函数$L(\omega,b)$的极值点的必要条件是$\eta L(\omega_{opt},b_{opt}))&#x3D;0$。所以，理论上可以通过求解这个方程来求无约束优化问题的最优解$\omega_{opt},b_{opt}$。然而，解方程不是计算机的长处，但计算机有强大的计算能力，可否通过算法一步步地去逼近问题的最优解$\omega_{opt},b_{opt}$?我们知道函数的梯度方向是函数值上升最快的方向，反方向就是函数值下降最快的方向了。因此，我们可以先给出$\omega,b$的一组初始值，然后沿着函数$L(\omega,b)$的负梯度方向不断地修改$\omega,b$的值，使函数值$L(\omega,b)$逐步逼近其最小值，这就是梯度下降法（BGD)的思想。</p><h3 id="对梯度的理解"><a href="#对梯度的理解" class="headerlink" title="对梯度的理解"></a>对梯度的理解</h3><p>机器学习的主要任务是在学习时寻找最优参数。这里的最优参数是指损失函数取最小值时的参数。然而损失函数很复杂，参数空间庞大，我们不知道它在何处能取得最小值。因而要寻找使损失函数的值尽可能小的地方，我们就需要借助导数来研究最值问题。因而需要计算参数的导数（确切地讲是梯度），然后以这个导数为指引，逐步更新参数。<br>此时，对权重参数的损失函数的求导，表示的是“如果稍微改变这个权重参数的值，损失函数的值会如何变化”。如果导数的值为负，通过该权重参数向正方向改变，可以减小损失函数的值；反过来，如果导数的值为正，则通过是该权重参数向负方向改变，可以减小损失函数的值。当导数的值为0时，无论权重参数向哪个方向变化，损失函数的值都不会改变，此时该权重参数的更新会停留在此处。</p><h3 id="为什么不采用解析求解？"><a href="#为什么不采用解析求解？" class="headerlink" title="为什么不采用解析求解？"></a>为什么不采用解析求解？</h3><p>正如前面所说线性回归可以使用最小二乘法直接解析求解。然而当特征数量比较大时，这种方法的计算量巨大，复杂度在$O(n^2)$以上（此处不详细说明）。所以我们采用迭代的方法。</p><h3 id="随机梯度下降法（SGD"><a href="#随机梯度下降法（SGD" class="headerlink" title="随机梯度下降法（SGD)"></a>随机梯度下降法（SGD)</h3><p>梯度下降法的每次迭代要遍历训练集的所有样本，如果训练集很大，计算量也将很大的。所以，实际上人们使用改进型的随机梯度下降法（Stochastic Gradient Desent,SGD）算法来训练。SGD算法每次迭代只计算一个样本，效率大大提升。由于样本的噪音和随机性，每次迭代并不一定按照函数值减少的方向。虽然存在一定的随机性，大量的迭代总体上沿着函数减少的方向前进，因此最后也能收敛到最小值附近。</p><p>随机梯度下降法的另一个优势是，当损失函数非常不规则时，随机梯度下降法其实可以帮助算法跳出局部最小值。所以相比批量随机梯度下降法，它对找到全局最小值更有优势，</p><h3 id="梯度下降法的问题"><a href="#梯度下降法的问题" class="headerlink" title="梯度下降法的问题"></a>梯度下降法的问题</h3><p>梯度表示的是各点处的函数值减小最多的方向。因此，无法保证梯度所指的方向就是函数的最小值或着真正应该前往的方向所在的方向。函数的极小值、最小值以及被称为鞍点的地方梯度为0。极小值是局部最小值。鞍点是从某个方向上看是极小值，从另一个方向上看则是极小值点。虽然梯度法是要寻找梯度为0的地方，但是那个地方不一定就是最小值（也可能是极小值或者鞍点）。<br>此外，当函数很复杂且呈扁平状时，学习可能会进入一个（几乎）平坦的地区，陷入被称为“学习高原”的无法前进的停滞期。</p><h3 id="LMS算法（Least-Mean-Square-最小均方）"><a href="#LMS算法（Least-Mean-Square-最小均方）" class="headerlink" title="LMS算法（Least Mean Square,最小均方）"></a>LMS算法（Least Mean Square,最小均方）</h3><p>LMS算法比感知机学习规则要强大得多。感知机规则能保证将训练模式收敛到一个可正确分类的解上，但得到的网络对噪声敏感，因为训练模式非常接近网络的判定边界。而LMS算法使均方误差最小化，从而使网络的判定边界尽量远离训练模式。</p><h4 id="LMS算法与原始感知机算法的比较"><a href="#LMS算法与原始感知机算法的比较" class="headerlink" title="LMS算法与原始感知机算法的比较"></a>LMS算法与原始感知机算法的比较</h4><p>Adaline与感知机很相似，两者具有相同的基本限制：它们只能对线性可分的数据集进行分类。然而，LMS算法仍比感知机学习规则更有效。因为它使均方误差最小化，所以算法能产生比感知机学习规则受噪声影响小的判定边界。</p><p>另外，LMS算法也因为它是反向传播BP算法的前驱而显得很重要。像BP算法也使用损失函数误差最小的随机梯度下降法。两算法唯一的区别在于导数的计算方式。BP算法是LMS算法的推广，可以用于多层感知机神经网络。而这些更复杂的网络能解决包括非线性问题在内的任意分类问题。</p><hr><h6 id='6'></h6><h2 id="6-借鉴自适性线性单元改进后的感知机算法——基于delta学习规则（随机梯度下降法）"><a href="#6-借鉴自适性线性单元改进后的感知机算法——基于delta学习规则（随机梯度下降法）" class="headerlink" title="6.借鉴自适性线性单元改进后的感知机算法——基于delta学习规则（随机梯度下降法）"></a>6.借鉴自适性线性单元改进后的感知机算法——基于delta学习规则（随机梯度下降法）</h2><h3 id="引入损失函数"><a href="#引入损失函数" class="headerlink" title="引入损失函数"></a>引入损失函数</h3><p>感知机学习算法是对于上述损失函数进行极小化，求得$\omega$和 b。这里使用随机梯度下降法(SGD)，因为误分类的 M 集合里面的样本才能参加损失函数的优化,即感知机算法是误分类驱动的。<br>目标函数如下:<br>$$L(\omega,b) &#x3D; arg\min_{\omega,b} \bigg(- \sum_{x_i \in M}y_i(\omega\cdot x_i + b) \bigg)$$<br>感知机学习算法有两种，一种是原始形式，一种是对偶形式，下面分别介绍:</p><hr><h6 id='6.1'></h6><h3 id="6-1-原始形式"><a href="#6-1-原始形式" class="headerlink" title="6.1 原始形式"></a>6.1 原始形式</h3><p>损失函数的最优化问题：误分类驱动，随机梯度下降法：</p><ul><li>损失函数的梯度<br>$$\nabla_\omega L(\omega,b) &#x3D; - \sum_{x_i \in M}y_i x_i$$<br>$$\nabla_b L(\omega,b) &#x3D; - \sum_{x_i \in M}y_i $$</li><li>给定$\eta(0 &lt; \eta \le 1)$作为步长(学习率)</li><li>目标：输出$\omega,b$,感知机模型$f(x) &#x3D; sign(\omega\cdot x_i + b)$ 1.任意选取初值$\omega_0,b_0$ 2.在训练集中随机选取数据（一个误分类点） $(x_i,y_i)$进行更新 3.如果$y_i(\omega\cdot x_i+b) \le b$,<br>$$\omega \leftarrow \omega + \eta y_i x_i$$$$b \leftarrow b + \eta y_i$$<br>式中的$\eta(0&lt;\eta\le1)$是步长，在统计学习中又称为 <strong><em>学习率</em></strong> 4.转到 2，直到没有误分类点，即损失函数减小为 0</li></ul><p>注意点:</p><ol><li>损失函数的极小化过程中不是一次使 M 中所有误分类点的梯度下降，而是一次随机选取一个误分类点是其梯度下降</li><li>感知机采用不同的初值或选取不同的误分类点，解可以不同</li></ol><p>####直观解释<br>当一个实例点被误分类,即位于分离超平面的错误一侧时,则调整$\omega ，b$的值，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面间的距离，直至超平面越过该误分类点使其被正确分类</p><p>####问题思考：<br><a href="">如何理解梯度，梯度下降法，随机梯度下降法，学习率?</a></p><hr><h6 id='6.2'></h6><h3 id="6-2-Novikoff-感知机算法的收敛证明"><a href="#6-2-Novikoff-感知机算法的收敛证明" class="headerlink" title="6.2 Novikoff 感知机算法的收敛证明:"></a>6.2 Novikoff 感知机算法的收敛证明:</h3><p>现在证明，对于线性可分数据集感知机学习算法原始形式收敛，即经过有限次迭代可以得到一个将训练数据集完全正确划分的分离超平面及感知机模型。<br>为了便于叙述与推导，将偏置b并入权重向量$\omega$，记作$\hat{\omega}&#x3D;(\omega^T,b)^T$，同样也将输入向量加以扩充，加进常数1，记作$\hat{x}&#x3D;(x^T,1)^T$。这样，$\hat{x}\in R^{n+1},\hat{\omega}\inR^{n+1}$。显然，$\hat{omega}\cdot\hat{x}&#x3D;\omega\cdot x+b$。<br>感知机收敛定理：</p><ul><li>（1）存在满足条件$||\hat{\omega}<em>{opt}||&#x3D;1$的超平面$\hat{\omega}</em>{opt}\cdot\hat{x}&#x3D;\omega_{opt}\cdot x+b_{opt}&#x3D;0$将训练数据集完全正确分开；且存在$\gamma&gt;0$，对所有$i&#x3D;1,2,\cdots,N$$$y_i(\hat{\omega}\cdot\hat{x}<em>i)&#x3D;y_i(} \cdot x_i+b</em>{opt})\geqslant\gamma$$</li><li>（2）令$R&#x3D;\max\limits_{1\leqslant i\leqslant N}||\hat{x}_i||$，则感知机算法在训练数据集上的误分类次数$k$满足不等式$$k\leqslant(\frac {R}{\gamma})^2$$</li></ul><p>证明：</p><ul><li><p>（1）由于训练数据集是线性可分的，按照线性可分的定义，存在超平面可将训练数据集完全正确分开，取此超平面为$\hat{\omega}<em>{opt}\cdot\hat{x}<em>i&#x3D;\omega</em>{opt}\cdot x_i+b</em>{opt}&#x3D;0$，使$||\hat{\omega}<em>{opt}||&#x3D;1$。由于对有限的$i&#x3D;1,2,\cdots,N$，均有$$y_i(\hat{\omega}\cdot\hat{x}<em>i)&#x3D;y_i(} \cdot x_i+b</em>{opt})&gt;0$$所以存在$$\gamma&#x3D;\min\limits_i\lbrace{y_i(\omega</em>{opt}\cdot x_i + b_{opt}\rbrace)}$$使$$\hat{\omega}<em>{opt}\cdot\hat{x}<em>i&#x3D;\omega</em>{opt}\cdot x_i+b</em>{opt}\geqslant\gamma$$</p></li><li><p>（2）感知机算法从$\hat{\omega}<em>0&#x3D;0$开始，如果实例被误分类，则更新权重。令$\hat{\omega}</em>{k-1}$是第$k$个误分类实例之前的扩充权重向量，即$$\hat{\omega}{k-1}&#x3D;(\omega^T_{k-1},b_{k-1})^T$$则第$k$个误分类实例的条件是$$\hat{\omega}<em>{k-1}\cdot\hat{x}_i&#x3D;\omega</em>{k-1}\cdot x_i+b_{opt}\leqslant0$$若$(x_i,y_i)$是被$\hat{\omega}<em>{k-1}&#x3D;(\omega^T</em>{k-1},b_{k-1})^T$误分类的数据，则$\omega$和$b$的更新是$$\omega_k\leftarrow\omega_{k-1}+\eta y_ix_i$$$$b_k\leftarrow b_{k-1} + \eta y_i$$即$$\hat{\omega}<em>k\leftarrow\hat{\omega}</em>{k-1}+\eta y_i\hat{x}_i$$<br>下面推导两个不等式：$$(1)\quad \hat{\omega}<em>k\cdot\hat{\omega}</em>{opt}\geqslant k\eta\gamma$$</p><p align="right"></p>证明过程的有趣性：证明中的一处比较有趣的地方在于，与学习算法的思路相同，数学证明时也采用迭代的方法。</li></ul><p>结论：</p><ul><li>误分类次数$k$有上界，经过有限次搜索可以找到将训练数据完全正确分开的超平面。</li><li>当训练数据集线性可分时，感知机学习算法原始形式迭代是收敛的。</li><li>当训练集线性不可分时，感知机学习算法不收敛，迭代结果会发生震荡。</li><li><font color="red">感知机学习算法存在许多解，既依赖于初值，也依赖于迭代过程中误分类点的选择顺序。为了得到唯一的超平面，需要对分离超平面增加约束条件。这就是第 7 章将要讲的<strong>线性支持向量机</strong>的想法。</font></li></ul><p>反思：学习不要被动接受死知识，而要主动提前去思考，当第一次得知感知机解的不唯一性时，我就应该意识到到这是一个问题并思考为什么会出现这种情况，如何优化与解决。这其实与上文求距离时不考虑分母范数的问题是相关联的，都是由感知机的所选择的损失函数所导致的</p><p>实际上在接触支持向量机相关内容后就会对现在的问题有比较清楚的理解</p><h3 id="判断样本集线性可分的充要条件"><a href="#判断样本集线性可分的充要条件" class="headerlink" title="判断样本集线性可分的充要条件"></a>判断样本集线性可分的充要条件</h3><p>证明以下定理：<strong>样本集线性可分的充分必要条件是正实例点所构成的凸壳与负实例点所构成的凸壳互不相交</strong>。</p><hr><h6 id='6.3'></h6><h3 id="6-3-对偶形式"><a href="#6-3-对偶形式" class="headerlink" title="6.3 对偶形式"></a>6.3 对偶形式</h3><p>基本想法：将$\omega,b$表示成实例$x_i$和标记$y_i$的线性组合形式。</p><ul><li>取初始值$\omega_0,b_0$均为 0</li><li>经过 n 次修改$\omega,b,\ \ \omega,b$关于$(x_i,y_i)$的增量分别是$\alpha_iy_ix_i$和$\alpha_iy_i$,这里$\alpha_i &#x3D; \eta_i\eta$，$\eta_i$是点$(x_i,y_i)$被误分类的次数</li><li>最后学到的$\omega,b$可表示成：<br>$$\omega &#x3D; \sum_{i&#x3D;1}^N\alpha_iy_ix_i$$$$b &#x3D; \sum_{i&#x3D;1}^N\alpha_i y_i$$</li><li>这里，$\alpha_i \ge 0,i&#x3D;1,2,3,\cdots,N$</li><li>当$\eta &#x3D; 1$时,$\alpha_i$表示第$i$个实例点由于误分类进行更新的次数，次数越多，意味着它距离分离超平面越近，很难正确分类，这样的实例对学习结果影响很大 ####对偶算法<br>目标：求$\alpha,b$,感知机模型$f(x) &#x3D; sign \bigg( \sum\limits_{j&#x3D;1}^N \alpha_jy_jx_j \cdot x+b\bigg)$，其中$\alpha &#x3D; (\alpha_1,\alpha_2,…,\alpha_N)^T$ 1.$\alpha &#x3D; 0, b &#x3D;0$ 2.选取训练集数据$(x_i,y_i)$ 3.如果$y_i \bigg( \sum\limits_{j&#x3D;1}^N \alpha_jy_jx_j \cdot x_i+b\bigg) \leq 0$<br>$$\alpha_i \leftarrow \alpha_i + \eta$$$$b \leftarrow b + \eta y_i$$ 4.转至 2，直到没有误分数据<br>对偶形式可以预先将训练集中的实例间的内积计算出来并以矩阵形式存储，该矩阵称为 Gram 矩阵$$ \mathbf G &#x3D; [x_i \cdot x_j]_{N \times N}$$</li></ul><hr><h6 id='6.4'></h6><h3 id="6-4-原始形式与对偶形式的简单比较与选择"><a href="#6-4-原始形式与对偶形式的简单比较与选择" class="headerlink" title="6.4 原始形式与对偶形式的简单比较与选择"></a>6.4 原始形式与对偶形式的简单比较与选择</h3><h4 id="产生两种形式的原因"><a href="#产生两种形式的原因" class="headerlink" title="产生两种形式的原因:"></a>产生两种形式的原因:</h4><ul><li>感知机之所以有两种形式，是因为采用的随机梯度下降，随机梯度下降每次迭代的是一个点，而不是整体，因此对于迭代的点有次数的概念。 ####选择与比较:</li><li>在向量维数（特征数）过高时，计算内积非常耗时，应选择对偶形式算法加速。</li><li>在向量个数（样本数）过多时，每次计算累计和就没有必要，应选择原始算法。</li></ul><h4 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考:"></a>问题思考:</h4><p>  <a href="">对于对偶形式的进一步思考</a></p><hr><h3 id="感知机的问题："><a href="#感知机的问题：" class="headerlink" title="感知机的问题："></a>感知机的问题：</h3><h4 id="梯度下降法的问题-局部最优与全局最优"><a href="#梯度下降法的问题-局部最优与全局最优" class="headerlink" title="梯度下降法的问题:局部最优与全局最优"></a>梯度下降法的问题:局部最优与全局最优</h4><h6 id='7'></h6><h2 id="7-算法实现"><a href="#7-算法实现" class="headerlink" title="7.算法实现"></a>7.算法实现</h2><hr><h6 id='7.1'></h6><h3 id="7-1-基于感知机-Perceptron-的鸢尾花分类实践"><a href="#7-1-基于感知机-Perceptron-的鸢尾花分类实践" class="headerlink" title="7.1 基于感知机 Perceptron 的鸢尾花分类实践"></a>7.1 基于感知机 Perceptron 的鸢尾花分类实践</h3><p>详见<a href="">算法实现</a></p><hr><h6 id='7.2'></h6><h3 id="7-2-基于感知机-Perceptron-的乳腺癌数据集分类"><a href="#7-2-基于感知机-Perceptron-的乳腺癌数据集分类" class="headerlink" title="7.2 基于感知机 Perceptron 的乳腺癌数据集分类"></a>7.2 基于感知机 Perceptron 的乳腺癌数据集分类</h3><p>详见<a href="">算法实现</a></p><hr><h6 id='8'></h6><h2 id="8-总结思考"><a href="#8-总结思考" class="headerlink" title="8.总结思考"></a>8.总结思考</h2><p>我们是如何认知的，是如何学习的，有哪些普适的底层方法？如果我们掌握了这些方法，我们能否使其他具有接受和处理信息及计算能力的事物如机器也掌握这些认知和学习方法。感知机在某种程度上简单思考了这个问题。</p><p>正如本学习笔记开篇引述的 1999 年图灵奖获得者弗雷德里克·布鲁克斯（Frederick P. Brooks）的这句话：“<strong>正确的判断来自于经验，而经验来自于错误的判断</strong>。”在生物神经元中，通过增加突触形成经验。而在感知算法中我们通过训练实例进行学习，并借助损失函数与随机梯度下降法迭代试错、更新参数来形成经验，进而进行正确的判断。</p><h3 id="8-1-“学习观的理解”和“数学建模”"><a href="#8-1-“学习观的理解”和“数学建模”" class="headerlink" title="8.1 “学习观的理解”和“数学建模”"></a>8.1 “学习观的理解”和“数学建模”</h3><p>作为神经网络和支持向量机的基础，理解感知机，我们可以从对“学习观的理解”和“数学建模”两个角度进行理解。</p><p>从“学习观的理解”角度，我们要理解归纳学习与逻辑演绎、从具体实例中学习、迭代试错学习、经验主义、感知机的生物学解释、机械学习硬式记忆与联结主义不同等。</p><p>从“数学建模”角度，我们要理解线性回归与最小二乘法背后的思想、规律的本质——函数、分类问题的本质——分离超平面&#x2F;超曲面、损失函数与随机梯度下降法、全局最优与局部最优、特征的数学化与向量表示等。</p><h3 id="8-2-理解感知机的具体三个层面"><a href="#8-2-理解感知机的具体三个层面" class="headerlink" title="8.2 理解感知机的具体三个层面"></a>8.2 理解感知机的具体三个层面</h3><h4 id="1-如何理解和处理“智能”——从学习能力到寻找超平面"><a href="#1-如何理解和处理“智能”——从学习能力到寻找超平面" class="headerlink" title="1.如何理解和处理“智能”——从学习能力到寻找超平面"></a>1.如何理解和处理“智能”——从学习能力到寻找超平面</h4><p>智能是一个抽象而空泛的概念，要想实现智能就必须将其具体化、实际化。首先，我们要认知到智能的核心与关键是<strong>学习能力</strong>。进一步，学习有各种方面，我们要意识到在人类生活中一个广泛而核心的学习能力是<strong>识别并归纳出事物规律的能力，即模式识别能力</strong>。再进行简化，我们可以尝试处理最简单的二元状态的模式识别问题，此时识别等价于<strong>一种判断问题，等价于二元分类问题</strong>。为了精确描述和解决问题，于是我们要设法引入数学语言，进行数学建模。借助于几何图像，我们发现二元分类问题可以归结于<strong>寻找一个超平面或超曲面</strong>。为了简化问题，感知机寻找的是超平面。</p><h4 id="2-从线性回归理解如何学习规律——从具体例子归纳学习"><a href="#2-从线性回归理解如何学习规律——从具体例子归纳学习" class="headerlink" title="2.从线性回归理解如何学习规律——从具体例子归纳学习"></a>2.从线性回归理解如何学习规律——从具体例子归纳学习</h4><p>既然问题变成了寻找超平面的数学问题，我们自然联想到统计数学中一个类似的问题——线性回归问题。在线性回归问题中，我们通过具体的样本点拟合一个线性函数，进而判断其他点相对于该线性函数的位置关系等。</p><p>线性回归给予我们如下启示：</p><ol><li>规律的本质是函数、映射关系。规律不是虚无的，规律无处不在并蕴含在具体实例中。</li><li>我们可以通过对具体事例和数据的归纳学习来得到函数，学习并掌握规律，而不必进行直接的解析式求解。</li></ol><p>感知机采用了这些观点，并大胆假设如果我们能够掌握大量例子，我们就能掌握规律本身。</p><h4 id="3-如何学习具体例子——联结主义的记忆与学习观——知识的储存与表示"><a href="#3-如何学习具体例子——联结主义的记忆与学习观——知识的储存与表示" class="headerlink" title="3.如何学习具体例子——联结主义的记忆与学习观——知识的储存与表示"></a>3.如何学习具体例子——联结主义的记忆与学习观——知识的储存与表示</h4><p>线性回归启示我们从具体例子学习规律的思路，然而我们仍然不知道如何学习具体例子。另一方面，统计学中的大数定理虽然印证着从具体例子学习的思路，但它也对训练事例的数量提出了要求，而我们应该如何从有限事例中总结出规律呢？</p><p>一种学习方法是机械式的学习，即将所有例子都存储起来，当遇到新事物时就与储存的例子进行比较，通过计算相似度来进行判断。且不论这种方法能否实现，这种方法的最大问题在于没有迁移能力，无法举一反三、随机应变。其实，我们可以发现本质上，这不是学习。从记忆的角度，这真的只是死记硬背。从信息的角度，这些信息虽然被储存，但并没有被处理、提取、综合，进而无法得到规律。</p><p>另一种思路联结主义。联结主义认为学习与记忆不是硬式存储，而是通过改变神经网络的连接结构与连接强度来实现的。这种从具体例子到连接强度的转化本身就是一种信息处理与提取的过程，进而整个神经网络的连接就是一个函数，是对规律的映射与表示。</p><p>Rosenblatt采取后一种观点来学习具体例子，因而他没有去储存和记忆具体例子，而是建立一个含未知参数的线性模型，并通过迭代试错的方法，用具体例子一个个地来调整未知参数，这样规律信息就从具体实例中转化、提取到参数中。而当学到的参数模型能够正确判断所有训练数据，我们就说它近似掌握了规律。进一步的，我们可以通过建立作为评价标准的损失函数并借助梯度下降法等数学方法来自动进行迭代试错，实现自动学习，而这就得到了感知机模型。</p><h3 id="8-3-感知机的美与局限"><a href="#8-3-感知机的美与局限" class="headerlink" title="8.3 感知机的美与局限"></a>8.3 感知机的美与局限</h3><p>我觉得感知机的美妙之处在于它是认知哲学与数学统计的巧妙结合，它虽然简陋，但却汇集了最核心的思想。它的每一处问题又恰恰引出机器学习的相关概念与后续发展。深度学习的基础模型——神经网络和统计学习的经典方法——支持向量机竟都起源于此，这本身就是十分有趣的。</p><p>感知机虽然能解决线性可分问题，然而它却无法处理非线性问题。同时感知机求出的分离超平面虽然是可行解，但却不是最优解。并且这种分离极易受噪声干扰，无法处理个别的特异点。</p><p>对我来说，学习感知机的一个最有趣的体验是认知成长的过程。在学习最初我对感知机完全不知所云，逐渐了解其原理、历史与思想后，我为其背后的美妙认知所惊叹，然而在进一步学习其他模型后我又认知到感知机的浅显。感知机的思想对于一个初学者已足够美妙，然而事实证明自然世界是深不可测的，感知机背后思想的美只是大自然无限魅力的渺小的一部分。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法提高课笔记——2.1.1 BFS中的Flood Fill和最短路模型</title>
      <link href="/2023/01/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-2-1-1-BFS%E4%B8%AD%E7%9A%84Flood-Fill%E5%92%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/01/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-2-1-1-BFS%E4%B8%AD%E7%9A%84Flood-Fill%E5%92%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-1-BFS中的Flood-Fill和最短路模型"><a href="#2-1-1-BFS中的Flood-Fill和最短路模型" class="headerlink" title="2.1.1 BFS中的Flood Fill和最短路模型"></a>2.1.1 BFS中的Flood Fill和最短路模型</h1><h2 id="BFS特点"><a href="#BFS特点" class="headerlink" title="BFS特点"></a>BFS特点</h2><ol><li>求最小-&gt;第一次搜到恰为最小距离</li><li>基于迭代，不会爆栈（一般1M，十万层）</li></ol><p>类型<br>最小距离-&gt;从内部一点到另一点的最小距离<br>eg.走迷宫</p><p>最小步数-&gt;整体视为一个状态，状态的变换的最小步数(状态本身作为一个点，每次变换视为一步，问题是状态之间的逻辑关系)<br>eg.八数码</p><h2 id="Flood-Fill"><a href="#Flood-Fill" class="headerlink" title="Flood Fill"></a>Flood Fill</h2><p>可以在线性时间复杂度内，找到某个点所在的连通块</p><p>使用BFS的过程模拟洪水覆盖的过程–从四周开始扩散–填充整个连通块</p><p>连通类型<br>四连通<br>八连通</p><h3 id="1-AcWing-1097-池塘计数"><a href="#1-AcWing-1097-池塘计数" class="headerlink" title="1. AcWing 1097. 池塘计数"></a>1. <a href="https://www.acwing.com/problem/content/1099/">AcWing 1097. 池塘计数</a></h3><p>注意双层逻辑：<br>先遍历每个格子，每个格子再进行BFS搜索过程。需进行标记–判重。</p><p>BFS使用队列实现，队列中存储下标，二维时可以使用pair</p><p>注意是否开始搜索的判断条件要想清楚</p><p>搜索时注意遍历方法和边界条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS中的Flood Fill——AcWing 1097. 池塘计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图，注意使用char</span></span><br><span class="line">PII q[M]; <span class="comment">// 数组模拟队列时，数组大小为所有元素大小</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 标记是否搜索过，避免重复</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入坐标位置参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span>&#123;</span><br><span class="line">    <span class="comment">// 数组模拟队列。bfs基于迭代，每次调用使用一个队列</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;<span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 分别标记队列要取出结点的位置，存取结点的前一个位置</span></span><br><span class="line">    </span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    <span class="comment">// 初始状态入队列</span></span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 进行标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        PII t = q[hh ++]; <span class="comment">// 取出队头元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展队列元素</span></span><br><span class="line">        <span class="comment">// 枚举所有可能的移动方向</span></span><br><span class="line">        <span class="comment">// 注意区分四连通和八连通</span></span><br><span class="line">        <span class="comment">// 这里要注意八的遍历方式</span></span><br><span class="line">        <span class="comment">// 暴力枚举3 X 3 矩阵并挖掉中间格子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.x - <span class="number">1</span>; i &lt;= t.x + <span class="number">1</span>;++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.y - <span class="number">1</span>; j &lt;= t.y + <span class="number">1</span>; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == t.x &amp;&amp; j == t.y) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 挖掉中间格子</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m)  </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 注意判断是否越界</span></span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;.&#x27;</span> || st[i][j])      </span><br><span class="line">                <span class="comment">// 是否满足条件 </span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q[++ tt] = &#123;i, j&#125;;</span><br><span class="line">                <span class="comment">// 满足条件的入列</span></span><br><span class="line">                st[i][j] = <span class="literal">true</span>; </span><br><span class="line">                <span class="comment">// 标记已搜索过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]); </span><br><span class="line">    <span class="comment">// 注意采用字符串读取方式</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 要记录的量：连通块的数量</span></span><br><span class="line">    <span class="comment">// 从头到尾依次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !st[i][j]) </span><br><span class="line">            <span class="comment">// 是否满足条件</span></span><br><span class="line">            <span class="comment">// 这里的代码的书写的思路是要掌握的，一定不要乱，不要寻求直接找到符合条件的再遍历，而是全部遍历再判断是否符合条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                bfs(i, j);</span><br><span class="line">                <span class="comment">// 符合条件的进行广度优先搜索</span></span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的Flood Fill——AcWing 1097. 池塘计数</span></span><br><span class="line"><span class="comment"># 使用库函数deque，速度更快</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="comment"># 双向队列deque是栈和队列的一种广义实现，是类似于list的容器，可以快速的在队列头部和尾部添加、删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里没有另开查重数组，通过直接改变原数组实现标记</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    d_x = (-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    d_y = (-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 不能使用st = [[False]*m]*n这种写法</span></span><br><span class="line">    <span class="comment"># [[0]*n]*m这种方式是直接将[0]*n复制了m遍，是=号复制（注意不是浅拷贝，=与浅拷贝的list id是不同的），</span></span><br><span class="line">    <span class="comment"># 若[0]*n发生了更改，则m个都发生更改。[0]*n作为一个list被共享。</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q = deque([(sx, sy)])</span><br><span class="line">        g[sx][sy] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> <span class="built_in">zip</span>(d_x, d_y):</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m <span class="keyword">and</span> g[nx][ny] == <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                    q.append((nx, ny))</span><br><span class="line">                    g[nx][ny] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(g):</span><br><span class="line">        <span class="keyword">for</span> j, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(line):</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                bfs(i, j)</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># // BFS中的Flood Fill——AcWing 1097. 池塘计数</span></span><br><span class="line"><span class="comment"># 数组模拟队列    </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    d_x = (-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    d_y = (-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    q = [<span class="number">0</span>] * (n * m)</span><br><span class="line">    st = [[<span class="literal">False</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># 不能使用st = [[False]*m]*n这种写法</span></span><br><span class="line">    <span class="comment"># [[0]*n]*m这种方式是直接将[0]*n复制了m遍，是=号复制（注意不是浅拷贝，=与浅拷贝的list id是不同的），</span></span><br><span class="line">    <span class="comment"># 若[0]*n发生了更改，则m个都发生更改。[0]*n作为一个list被共享。</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        hh, tt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        q[<span class="number">0</span>] = (sx, sy)</span><br><span class="line">        st[sx][sy] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> hh &lt;= tt:</span><br><span class="line">            x, y = q[hh]</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> <span class="built_in">zip</span>(d_x, d_y):</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m <span class="keyword">and</span> g[nx][ny] == <span class="string">&#x27;W&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> st[nx][ny]:</span><br><span class="line">                    tt += <span class="number">1</span></span><br><span class="line">                    q[tt] = (nx, ny)</span><br><span class="line">                    st[nx][ny] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> g[i][j] == <span class="string">&#x27;W&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                bfs(i, j)</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-1098-城堡问题"><a href="#2-AcWing-1098-城堡问题" class="headerlink" title="2. AcWing 1098. 城堡问题"></a>2. <a href="https://www.acwing.com/problem/content/1100/">AcWing 1098. 城堡问题</a></h3><p>四连通遍历</p><p>取二进制中第k位<br>x &gt;&gt; k &amp; 1<br>本题注意二进制解码的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS中的Flood Fill——AcWing 1098. 城堡问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 四连通时的写法</span></span><br><span class="line">    <span class="comment">// 常用技巧：使用偏移量表示移动方向</span></span><br><span class="line">    <span class="comment">// 注意这里的方向顺序必须和西北东南的顺序相对应</span></span><br><span class="line">    <span class="comment">// 只是为了方便后面进行二进制解码</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 分别标记队列要取出结点的位置，存取结点的前一个位置</span></span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    <span class="comment">// 初始状态入队</span></span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        PII t = q[hh ++];</span><br><span class="line">        area ++; </span><br><span class="line">        <span class="comment">// 可以在出队时统计，可以在入队时统计</span></span><br><span class="line">        <span class="comment">// 这里为了避免第一个忘统计，在出队时统计</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展队列元素</span></span><br><span class="line">        <span class="comment">// 枚举所有可能的移动方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 越界判断</span></span><br><span class="line">            <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[t.x][t.y] &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 使用位运算，解码二进制</span></span><br><span class="line">            <span class="comment">// x &gt;&gt; i &amp; 1 取出x二进制的第i位</span></span><br><span class="line">            <span class="comment">// 根据第i位是否为1判断是否有墙</span></span><br><span class="line">            <span class="comment">// 这里的顺序能成立是因为按照了西北东南的顺序，</span></span><br><span class="line">            <span class="comment">//且题目规定用1表示西墙，2表示北墙，4表示东墙，8表示南墙</span></span><br><span class="line">            q[++ tt] = &#123;a, b&#125;;</span><br><span class="line">            <span class="comment">// 符合条件的元素入队</span></span><br><span class="line">            st[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, area = <span class="number">0</span>; <span class="comment">// 要记录的量：连通块数量和大小（面积）</span></span><br><span class="line">    <span class="comment">// 全部遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])&#123;</span><br><span class="line">                area = max(area, bfs(i, j));</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; area &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的Flood Fill——AcWing 1098. 城堡问题</span></span><br><span class="line"><span class="comment"># 使用库函数deque</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    d_x = [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    d_y = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    st = [[<span class="literal">False</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q = deque([[sx, sy]])</span><br><span class="line">        st[sx][sy] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 不能使用st = [[False]*m]*n这种写法</span></span><br><span class="line">        <span class="comment"># [[0]*n]*m这种方式是直接将[0]*n复制了m遍，是=号复制（注意不是浅拷贝，=与浅拷贝的list id是不同的），</span></span><br><span class="line">        <span class="comment"># 若[0]*n发生了更改，则m个都发生更改。[0]*n作为一个list被共享。</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            area += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                nx, ny = x + d_x[i], y + d_y[i]</span><br><span class="line">                <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= n <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> ny &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> st[nx][ny]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> g[x][y] &gt;&gt; i &amp; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                q.append([nx, ny])</span><br><span class="line">                st[nx][ny] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> area</span><br><span class="line">    </span><br><span class="line">    cnt, area = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                area = <span class="built_in">max</span>(area, bfs(i, j))</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line">    <span class="built_in">print</span>(area)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的Flood Fill——AcWing 1098. 城堡问题</span></span><br><span class="line"><span class="comment"># 数组模拟队列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    d_x = [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    d_y = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    st = [[<span class="literal">False</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    q = [<span class="number">0</span>] *(m*n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q[<span class="number">0</span>] = [sx, sy]</span><br><span class="line">        st[sx][sy] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 不能使用st = [[False]*m]*n这种写法</span></span><br><span class="line">        <span class="comment"># [[0]*n]*m这种方式是直接将[0]*n复制了m遍，是=号复制（注意不是浅拷贝，=与浅拷贝的list id是不同的），</span></span><br><span class="line">        <span class="comment"># 若[0]*n发生了更改，则m个都发生更改。[0]*n作为一个list被共享。</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        hh, tt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> hh &lt;= tt:</span><br><span class="line">            x, y = q[hh]</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">            area += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                nx, ny = x + d_x[i], y + d_y[i]</span><br><span class="line">                <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= n <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> ny &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> st[nx][ny]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> g[x][y] &gt;&gt; i &amp; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                tt += <span class="number">1</span></span><br><span class="line">                q[tt] = [nx, ny]</span><br><span class="line">                st[nx][ny] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> area</span><br><span class="line">    </span><br><span class="line">    cnt, area = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                area = <span class="built_in">max</span>(area, bfs(i, j))</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line">    <span class="built_in">print</span>(area)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="3-AcWing-1106-山峰和山谷"><a href="#3-AcWing-1106-山峰和山谷" class="headerlink" title="3. AcWing 1106. 山峰和山谷"></a>3. <a href="https://www.acwing.com/problem/content/1108/">AcWing 1106. 山峰和山谷</a></h3><p>本题要判断每个方格和周围方格的关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS中的Flood Fill——AcWing 1106. 山峰和山谷</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy, <span class="type">bool</span> &amp; has_higher, <span class="type">bool</span> &amp; has_lower)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span> ,tt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 分别标记队列要取出结点的位置，存取结点的前一个位置</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    <span class="comment">// 初始状态入队</span></span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        PII t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.x - <span class="number">1</span>; i &lt;= t.x + <span class="number">1</span>; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.y - <span class="number">1</span>; j &lt;= t.y + <span class="number">1</span>; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 判断是否越界</span></span><br><span class="line">                <span class="keyword">if</span> (h[i][j] != h[t.x][t.y])&#123;</span><br><span class="line">                    <span class="comment">// 判断与周围方格的高度关系</span></span><br><span class="line">                        <span class="keyword">if</span> (h[i][j] &gt; h[t.x][t.y]) has_higher = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span> has_lower = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 不能提前结束遍历</span></span><br><span class="line">                        <span class="comment">// 要把整个连通块都遍历一遍，防止重复</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!st[i][j])&#123;</span><br><span class="line">                        q[++ tt] = &#123;i, j&#125;;</span><br><span class="line">                        <span class="comment">// 入队列</span></span><br><span class="line">                        st[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 注意这里不能先写if(st[i][j]) continue;</span></span><br><span class="line">                <span class="comment">// 只有未遍历过的才能入队列，但在判断四周是否有高低点时与四周点是否遍历过无关</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> peak = <span class="number">0</span>, valley = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用来记录山峰和山谷数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有方格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n;++ j)</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])&#123;</span><br><span class="line">                <span class="type">bool</span> has_higher = <span class="literal">false</span>, has_lower = <span class="literal">false</span>;</span><br><span class="line">                bfs(i, j, has_higher, has_lower);</span><br><span class="line">                <span class="keyword">if</span> (!has_higher) peak ++;</span><br><span class="line">                <span class="keyword">if</span> (!has_lower) valley ++;</span><br><span class="line">                <span class="comment">// 这里注意不能使用else，一片区域可能同时成为山峰和山谷</span></span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, peak, valley);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的Flood Fill——AcWing 1106. 山峰和山谷</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    h = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    st = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q = deque([[sx, sy]])</span><br><span class="line">        st[sx][sy] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        has_higher, has_lower = <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x - <span class="number">1</span>, x + <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y - <span class="number">1</span>, y + <span class="number">2</span>):</span><br><span class="line">                    <span class="keyword">if</span> i == x <span class="keyword">and</span> j == y: </span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> h[i][j] &gt; h[x][y]:</span><br><span class="line">                        has_higher = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> h[i][j] &lt; h[x][y]:</span><br><span class="line">                        has_lower = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                        q.append([i, j])</span><br><span class="line">                        st[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> has_higher, has_lower</span><br><span class="line">                  </span><br><span class="line">    peak, valley = <span class="number">0</span>, <span class="number">0</span>   </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                has_higher, has_lower = bfs(i, j)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_higher: peak += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_lower: valley += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(peak, valley)</span><br><span class="line">                </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="最短路模型"><a href="#最短路模型" class="headerlink" title="最短路模型"></a>最短路模型</h2><h3 id="1-AcWing-1076-迷宫问题"><a href="#1-AcWing-1076-迷宫问题" class="headerlink" title="1. AcWing 1076. 迷宫问题"></a>1. <a href="https://www.acwing.com/problem/content/1078/">AcWing 1076. 迷宫问题</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1076. 迷宫问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line">PII pre[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">    pre[sx][sy] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        PII t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; ++ i)&#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (pre[a][b].x != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            q[++ tt] = &#123;a, b&#125;;</span><br><span class="line">            pre[a][b] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);</span><br><span class="line">    </span><br><span class="line">    bfs(n - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    PII <span class="title function_">end</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, end.x, end.y);</span><br><span class="line">        <span class="keyword">if</span> (end.x == n - <span class="number">1</span>&amp;&amp; end.y == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        end = pre[end.x][end.y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-AcWing-188-武士风度的牛"><a href="#2-AcWing-188-武士风度的牛" class="headerlink" title="2. AcWing 188. 武士风度的牛"></a>2. <a href="https://www.acwing.com/problem/content/190/">AcWing 188. 武士风度的牛</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 188. 武士风度的牛</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sx, sy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">    </span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        PII t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span> ;i &lt; <span class="number">8</span>; ++ i)&#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[a][b] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;H&#x27;</span>) <span class="keyword">return</span> dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">            q[++ tt] = &#123;a, b&#125;;</span><br><span class="line">            dist[a][b] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, bfs());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-AcWing-1100-抓住那头牛"><a href="#3-AcWing-1100-抓住那头牛" class="headerlink" title="3. AcWing 1100. 抓住那头牛"></a>3. <a href="https://www.acwing.com/problem/content/1102/">AcWing 1100. 抓住那头牛</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1100. 抓住那头牛</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bfs</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[n] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t == k) <span class="keyword">return</span> dist[k];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t + <span class="number">1</span> &lt; N &amp;&amp; dist[t + <span class="number">1</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">            q[++ tt] = t + <span class="number">1</span>;</span><br><span class="line">            dist[t + <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; dist[t - <span class="number">1</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">            q[++ tt] = t - <span class="number">1</span>;</span><br><span class="line">            dist[t - <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * t &lt; N &amp;&amp; dist[<span class="number">2</span> * t] == <span class="number">-1</span>)&#123;</span><br><span class="line">            q[++ tt] = <span class="number">2</span> * t;</span><br><span class="line">            dist[<span class="number">2</span> * t] = dist[t] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, bfs());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/23/hello-world-copy/"/>
      <url>/2023/01/23/hello-world-copy/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/23/hello-world/"/>
      <url>/2023/01/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to my blog!</p><p>我希望通过这个小站记录自己学习与生活的点点滴滴。</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
