<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>蓝桥杯备赛 树状数组与线段树</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组与线段树">树状数组与线段树</h1><h2 id="树状数组">树状数组</h2><p>线段树使用范围更广，完全包含树状数组的应用范文。但树状数组相较于线段树，有以下好处</p><ul class="lvl-0"><li class="lvl-2"><p>代码非常简短，好些</p></li><li class="lvl-2"><p>运行效率很高，常数很小，一般比线段树快10倍左右</p></li></ul><p><img src="https://mdpic.dreamgo.fun/img/image-20230305171228318.png" alt="image-20230305171228318"></p><p>树状数组的<strong>核心用途是动态快速地求解前缀和</strong>，有时也用于求最大值</p><p>树状数组可以在$O(log(n))$的复杂度内进行以下两个操作：</p><ol><li class="lvl-3"><p>单点修改：将某个位置上的数加上一个数</p><p>要将x变成v的话，可以加上v-x</p></li><li class="lvl-3"><p>区间查询：求某一个前缀和</p></li></ol><p><img src="https://mdpic.dreamgo.fun/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-05%20171933.png" alt="屏幕截图 2023-03-05 171933"></p><p>前缀和算法在序列不用修改时区间查询效率为$O(1)$效率更高，但涉及修改会很麻烦</p><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">单调修改</th><th style="text-align:center">区间插叙</th><th style="text-align:center">总体时间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">前缀和</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">$O(n)$</td></tr><tr><td style="text-align:center">树状数组</td><td style="text-align:center">$O(logn)$</td><td style="text-align:center">$O(logn)$</td><td style="text-align:center">$O(logn)$</td></tr></tbody></table><p>树状数组<strong>本质上只能用于单点修改和区间查询</strong>，其他问题要使用树状数组要<strong>先进行转化</strong>，如单点查询、区间修改，这两种操作都要借助<strong>差分思想</strong>进行转化。</p><p><strong>数据结构的选择要看具体需要什么操作，而不是题型</strong></p><p><img src="https://mdpic.dreamgo.fun/img/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.jpg" alt="树状数组"></p><h3 id="具体实现">具体实现</h3><p>树状数组是一个一维数组，下标从1开始，每个位置存储的都是一段数的和，存储规则如下：</p><ul class="lvl-0"><li class="lvl-2"><p>第0层：所有奇数（不能整除$2^1$）的下标的位置作为第0层，直接存原数组对应数值</p></li><li class="lvl-2"><p>第1层：所有能够整除$2<sup>1$但不能整除$2</sup>2$的下标的位置作为第1层，存储最接近的一个第0层值和本身位置对应的值的和</p></li><li class="lvl-2"><p>第2层：所有能够整除$2<sup>2$但不能整除$2</sup>3$的下标的位置作为第1层，存储最接近的一个第0、1层值和本身位置对应的值的和</p></li><li class="lvl-2"><p>第n层：所有能够整除$2<sup>n$但不能整除$2</sup>{n+1}$的下标的位置作为第1层，存储下面所有层下标小于且最接近当前下标的位置的树状数组存储值和本身位置对应的原数组值的和</p></li></ul><p>层数定义规则：下标对应二进制表示的末尾有几个0就在第几层</p><p>区间范围规则：若x的二进制表示最后有k个0，则其存储区间$[x-2^k+1, x]$范围内的和，<br>$$<br>\begin{align}<br><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">&amp; = \sum [x-2^k+1, x] \\</label><br>&amp; = \sum [x-lowbit(x)+1, x] \\<br>\end{align}<br>$$<br>此公式是树状数组核心公式！</p><p>求解二进制末尾有几个0可以使用$lowbit$位运算，<br>$$<br>lowbit(x) = x \ &amp; -x = 2^k<br>$$<br>$2^k$对应于末尾的<code>1</code>对应的数值大小，<code>k</code>对应于末尾<code>0</code>的个数</p><p>树状数组的性质：</p><ol><li class="lvl-4"><p>每个内部节点<code>c[x]</code>保存以它为根的子树中的所有叶节点的和</p></li><li class="lvl-4"><p>每个内部节点<code>c[x]</code>的子节点个数等于<code>lowbit(x)</code>的位数，eg.<code> lowbit(16) = 10000 = 5</code></p></li><li class="lvl-4"><p>除树根外, 每个内部节点<code>c[x]</code>的父节点是<code>c[x+lowbit(x)]</code>，eg. c[7]–&gt; c[7+1] = c[8]`</p></li><li class="lvl-4"><p>树的深度为$O(logN)$</p><p>如果N不是2的整次幂, 那么树状数组就是一个具有同样性质的森林结构</p></li><li class="lvl-4"><p><code>c[x]</code>存的是原序列<code>a</code>的区间[x-lowbit(x)+1, x]`中所有数的和</p></li></ol><p><strong>每个节点都有唯一的父节点$x+lowbit(x)$</strong></p><h3 id="操作实现">操作实现</h3><ol><li class="lvl-3"><p>单点修改：</p><p>每修改一个点，会影响$logn$个点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A[x] + v</span></span><br><span class="line"><span class="comment">// 正向修改，每个节点都有唯一的父节点x+lowbit(x)</span></span><br><span class="line"><span class="comment">// 只有c[x]和它所有的祖宗节点保存的&quot;区间和&quot; 包含a[x]</span></span><br><span class="line"><span class="comment">// 在x位置加上v，并将后面相关联的位置也加上v</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(x)) c[x] += v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>区间查询（求某一个前缀和）：</p><p><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2">+ C[x - lowbit(x)] + \ldots $</label></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 询问x的前缀和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qurey</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 逆序递归求和</span></span><br><span class="line"><span class="keyword">for</span> (i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i)) res += c[i];</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>初始化</p><p>执行所有操作之前, 我们需要对树状数组做初始化——针对原始序列a, 初始化一个树状数组c。</p><ul class="lvl-2"><li class="lvl-5"><p>一般的方法：建立一个全为0的数组c, 然后对每个x执行add(x, a[x])， 时间复杂度为$O(NlogN)$ ，通常采用这种初始化就已经足够</p></li><li class="lvl-5"><p>更加高效的做法: 从小到大依次考虑每一个节点x, 借助lowbit运算扫描他的子节点并求和, 上述树形结构的每条边只会被遍历一次，时间复杂度为$ O(N) $</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">预处理一个前缀和数组 pre</span><br><span class="line"><span class="comment">// 初始化树状数组 c</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">c[i] = pre[i] - pre[i-<span class="built_in">lowbit</span>(i)];   <span class="comment">// O(N);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="AcWing-1264-动态求连续区间和"><a href="https://www.acwing.com/problem/content/1266/">AcWing 1264. 动态求连续区间和</a></h3><h3 id="C">C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状数组——AcWing 1264. 动态求连续区间和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], tr[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// x的二进制表示最后有k个0，则树状数组中结点c[x]存储(x - 2^k, x]即(x - lowbit(x), x]这一区间的和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x; <span class="comment">// 位运算，返回x最右端一位的1所代表的大小（最后有k个0，则求得值为2^k）</span></span><br><span class="line">    <span class="comment">// 寻找树状数组中的父结点或子结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端点修改</span></span><br><span class="line"><span class="comment">// x表示修改下标，v表示加上的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 树状数组下标从1开始，所以要 &lt;= n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += v;</span><br><span class="line">    <span class="comment">// 树状数组中每个结点i的父节点为i + lowbit(i)</span></span><br><span class="line">    <span class="comment">// 要改变一个结点的值，还要改变其所有祖先节点的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 求解[1, x]的前缀和</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 将当前结点和其所以子孙节点相加即求得前缀和</span></span><br><span class="line">    <span class="comment">// 由于不能被2整除（最右端的1在最后一位）的数都放在了叶子结点，所以最终会加上它和它前面的元素的和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// 树状数组下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">add</span>(i, a[i]);</span><br><span class="line">    <span class="comment">// 默认刚开始树状数组所有元素为0，使用add()函数自动进行初始化（将初始化等同于单点修改）</span></span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="type">int</span> k, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="comment">// 区间查询</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x - <span class="number">1</span>)); <span class="comment">// 差分求解任意区间</span></span><br><span class="line">        <span class="comment">// 单点修改</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span> (x, y);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 树状数组——AcWing 1264. 动态求连续区间和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    tr = [<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="comment"># 树状数组下标从1开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowbit</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, v</span>):</span><br><span class="line">        <span class="keyword">while</span> x &lt;= n:</span><br><span class="line">            tr[x] += v</span><br><span class="line">            x += lowbit(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">x</span>):</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            res += tr[x]</span><br><span class="line">            x -= lowbit(x)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化树状数组，可以看做原数组a是全0数组，每次改变a数组一位的值</span></span><br><span class="line">    <span class="comment"># 树状数组下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        add(i, a[i - <span class="number">1</span>]) <span class="comment"># 由于a从0开始，所以是i - 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        k, a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 区间查询</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> k:</span><br><span class="line">            <span class="built_in">print</span>(query(b) - query(a - <span class="number">1</span>)) <span class="comment"># 前缀和形式的查询，注意是a-1</span></span><br><span class="line">        <span class="comment"># 单点修改</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            add(a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="AcWing-1265-数星星"><a href="https://www.acwing.com/problem/content/1267/">AcWing 1265. 数星星</a></h3><p>本题的一个关键是抓住题目的特殊性冷静分析，不要被题目吓住。要抓住本质进行分析。</p><p>本题看上去很复杂，需要用二维数据结构，使用二维数组存储。但是认真读题可以发现，输入的格式是按y坐标的增序给出的，这意味着在其后出现的点都与其无关，只用关心其前面的点。换句话说，只要我们边读入边处理，而不是全读入再处理，问题就能大大化简。由于y坐标相同的按x坐标增序给出，所以不用考虑y坐标的问题（y坐标一定满足在其左下方）。因而只用考虑x坐标的问题。这就实现了问题的降维简化，将二维将降成一维。这里降成一维的意思是我们不用使用二维数组来存储，而只需统计每个x坐标当前有的星星数。而当前星星的级数就是x下标小于其的前缀和。</p><p>具体来说，级数k等于前面所有点中x坐标小于等于其的所有点数之和。这显然可以转化为一个前缀和问题，由于每个x坐标对应的点数不是固定不变的，而是随着输入而循环增加。这就涉及单点修改的问题，可以使用树状数组。</p><p><img src="https://mdpic.dreamgo.fun/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-05%20214259.png" alt="屏幕截图 2023-03-05 214259"></p><p>我们计算一个点 $(x_i, y_i)$ 的优先级，就是计算满足$x \le x_i$ 且 $y \le y_i$ 的点的数量</p><p>因为 $y$ 按照从小到大顺序输入的，因此对于新加入的元素 $(x_i, y_i)$，$\forall y \in [y_0, y_{i - 1}]$，都有 $y_i &gt; y$</p><p>于是对于新加入的元素 $(x_i, y_i)$，他的优先级，就是在他之前加入的所有元素中 $x &lt; x_i$ 的点的个数。观察到一个边<code>插入</code>边<code>求前缀和</code>的数据结构，想到了<code>树状数组</code></p><h4 id="C-2">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 树状数组——AcWing 1265. 数星星</span></span><br><span class="line"><span class="comment">// 本题关键在于</span></span><br><span class="line"><span class="comment">// 1.边读取边处理，将问题降维化简 </span></span><br><span class="line"><span class="comment">// 2. 认识到数据所需的本质操作——单点修改和区间查询，从而选择树状数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">32010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tr[N], level[N];</span><br><span class="line"><span class="comment">// tr存储树状数组，</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;<span class="comment">// 位运算，返回x最右端一位的1所代表的大小（最后有k个0，则求得值为2^k）</span></span><br><span class="line">    <span class="comment">// 寻找树状数组中的父结点或子结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意这里是到N而不是n，n是节点数量，但树状数组范围是x坐标的范围</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= N; i += <span class="built_in">lowbit</span>(i)) tr[i] += v;</span><br><span class="line">    <span class="comment">// 树状数组中每个结点i的父节点为i + lowbit(i)</span></span><br><span class="line">    <span class="comment">// 要改变一个结点的值，还要改变其所有祖先节点的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算每个x坐标对应的级别</span></span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        x ++; <span class="comment">// 注意前缀和存储时一般从1开始，因为整体后移一位</span></span><br><span class="line">        <span class="comment">// 先求级数再插入，防止把自身算入</span></span><br><span class="line">        level[<span class="built_in">query</span>(x)] ++; <span class="comment">// 边读取边处理，并记录每个级别的数量</span></span><br><span class="line">        <span class="built_in">add</span>(x, <span class="number">1</span>); <span class="comment">// 级别增加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,level[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-2">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 树状数组——AcWing 1265. 数星星</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">32010</span></span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    tr, level = [<span class="number">0</span>] * N, [<span class="number">0</span>] * n</span><br><span class="line">    <span class="comment"># 树状数组范围是x坐标的范围，为N而不是n</span></span><br><span class="line">    <span class="comment"># 级数范围0~n-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowbit</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, v</span>):</span><br><span class="line">        <span class="comment"># 树状数组范围是x坐标的范围，为N而不是n</span></span><br><span class="line">        <span class="keyword">while</span> x &lt;= N:</span><br><span class="line">            tr[x] += v</span><br><span class="line">            x += lowbit(x)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">x</span>):</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            res += tr[x]</span><br><span class="line">            x -= lowbit(x)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"> <span class="comment"># 转换为树状数组问题的一个关键是定义树状数组的下标和存储含义   </span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        x += <span class="number">1</span> <span class="comment"># 注意前缀和存储时一般从1开始，因为整体后移一位</span></span><br><span class="line">        level[query(x)] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 先求级数再插入，防止把自身算入</span></span><br><span class="line">        add(x, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, level)))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="AcWing-1215-小朋友排队"><a href="https://www.acwing.com/problem/content/1217/">AcWing 1215. 小朋友排队</a></h3><p>这道题比较困难，一方面考察了对逆序对和冒泡排序的理解，另一方面要真正理解树状数组。</p><h4 id="逆序对">逆序对</h4><p>设 A 为一个有 n 个数字的有序集 (n&gt;1)，如果存在正整数 i, j 使得$1 ≤ i &lt; j ≤ n$而且$A[i] &gt; A[j]$，则$&lt;A[i], A[j]&gt;$这个有序对称为A的一个逆序对，也称作逆序数。</p><p>理解冒泡排序的本质：冒泡排序对相邻两项进行处理，一旦逆序就进行互换。而从整体上看，冒泡排序就是对所有逆序对进行处理，且每次处理一个逆序对，因而冒泡排序的交换次数等于逆序对个数k。</p><p>如果只能相邻项交换时，冒泡排序是一种最优的处理方法。每次处理一个，不会有无效操作。因为从贪心的角度，我们只需处理k个逆序对就可以了。</p><p>然而我们真的有需要先进行冒泡排序才求解吗？如果这样做就太麻烦了。本实质上完全不需要具体排序。</p><p>我们进一步研究，题目要本质上求解的是每个数的交换次数，只要求出次数自然就能求不高兴程度。而对于如何使所有人的不高兴程度之和最小，有两种可能：</p><ol><li class="lvl-3"><p>本题不满足最优子结构，不能使所有人的不高兴程度同时最小，涉及分配问题</p></li><li class="lvl-3"><p>本题满足最优子结构，每个人的交换次数都有一个最小值，且可同时取到，此时只要找到一种方法得出每个人的最小交换次数即可</p></li></ol><p>对于问题的思考显然要从第2个先进行尝试。</p><p>而由于冒泡排序就是最优解，我们可以逆向思考，分析冒泡排序中究竟对应哪种情况。可以发现，顺着冒泡排序的思路，只用k次整体就能排好。而具体到每个数，由于不会有多于步骤，在过程中其实只会和自己的逆序对进行交换。换句话说，最优解时每个数的交换次数都是一个固定的最小值且可同时取到。</p><p>问题由此就转化为具体每个数对应的逆序对数量。此时我们将其分成两部分，这个数前面比它大的数的个数和这个数后面比它小的数的个数，这和《数星星》这道题就相同了——可以用树状数组边存入边处理，<strong>树状数组可以解决求解一个数前面/后面大于/小于它的数的个数</strong>。本题分前后分别求解一次即可。（本质是先排序，再求前缀和，排序的过程通过读取时按下标存储解决了）。</p><p>边输入边处理</p><p>将数字作为下标，如果范围过大需要离散化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1215. 小朋友排队</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], tr[N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;<span class="comment">// 位运算，返回x最右端一位的1所代表的大小（最后有k个0，则求得值为2^k）</span></span><br><span class="line">    <span class="comment">// 寻找树状数组中的父结点或子结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= N; i += <span class="built_in">lowbit</span>(i)) tr[i] += v;</span><br><span class="line">    <span class="comment">// 树状数组中每个结点i的父节点为i + lowbit(i)</span></span><br><span class="line">    <span class="comment">// 要改变一个结点的值，还要改变其所有祖先节点的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]), h[i] ++;</span><br><span class="line">    <span class="comment">// 注意为了处理前缀和要从1开始存储的问题，把每个值后移一位</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 求每个数前面有多少个数比它大 --&gt; 排序 + 前缀和</span></span><br><span class="line">    <span class="comment">// 边存储（利用下标自动排序）边求解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        sum[i] = <span class="built_in">query</span>(N - <span class="number">1</span>) - <span class="built_in">query</span>(h[i]);</span><br><span class="line">        <span class="built_in">add</span>(h[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求每个数后面有多少个数比它小 --&gt;排序 + 前缀和</span></span><br><span class="line">    <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">    <span class="comment">// 先清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)&#123; </span><br><span class="line">        <span class="comment">// 反向处理</span></span><br><span class="line">        sum[i] += <span class="built_in">query</span>(h[i] - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(h[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">0</span>; <span class="comment">// 注意会爆int</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) res += (LL)sum[i] * (sum[i] + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 等差数列公式求和</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-3">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用数字作为下标</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lowbit</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, v</span>):</span><br><span class="line">    <span class="keyword">while</span> x &lt;= N:</span><br><span class="line">        tr[x] += v</span><br><span class="line">        x += lowbit(x)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">x</span>):</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        res += tr[x]</span><br><span class="line">        x -= lowbit(x)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">N = <span class="number">1000010</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">h = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">h = [<span class="number">0</span>] + [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> h]</span><br><span class="line"><span class="built_in">sum</span> = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">tr = [<span class="number">0</span>] * N</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">sum</span>[i] += query(N - <span class="number">1</span>) - query(h[i])</span><br><span class="line">    add(h[i], <span class="number">1</span>)</span><br><span class="line">tr = [<span class="number">0</span>] * N</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">sum</span>[i] += query(h[i] - <span class="number">1</span>)</span><br><span class="line">    add(h[i], <span class="number">1</span>)</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    res += <span class="built_in">sum</span>[i] *(<span class="built_in">sum</span>[i] + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h2 id="线段树">线段树</h2><p>树状数组的应用范围完全包含于线段树，且线段树的应用范围要广很多。</p><p>线段树是一种<strong>基于分治思想的二叉树结构</strong>，且除了最后一行其余行都是完全二叉树。用于<strong>在区间上进行信息维护和统计</strong>。</p><p>线段树的结构如下：</p><ol><li class="lvl-3"><p>线段树的每个节点都代表一个区间</p></li><li class="lvl-3"><p>线段树具有唯一的根节点，代表的区间是整个统计范围，如[1, N]，存储整个区间的信息</p></li><li class="lvl-3"><p>线段树的每个叶节点都代表一个长度为1的元区间[x, x]</p></li><li class="lvl-3"><p>对于每个内部节点$[L, R]$，区间长度不唯一且会进行二分并放到下一层。它的左子节点是$[L, mid]$，右子节点是$[mid + 1, R]$， $，其中mid = \lfloor \frac{L+R}{2} \rfloor$（向下取整）</p></li></ol><p><img src="https://mdpic.dreamgo.fun/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-03-05%20222449.png" alt="屏幕截图 2023-03-05 222449"></p><p>也是维护一个序列，可以进行的操作非常多。</p><ol><li class="lvl-3"><p>单点修改：修改信息需要变化的相关节点，修改的过程是一个<strong>递归+回溯</strong>的过程，时间复杂度为 O(logn)</p></li><li class="lvl-3"><p>区间查询：也是一个<strong>递归</strong>的过程，可以求和、最大值、最小值等（取决节点中存啥）。查询时，不断往下递归，知道当前结点范围被带查询区间完全覆盖时停止。时间复杂度为 O(logn)</p></li><li class="lvl-3"><p>区间修改： 使用懒标记，“延迟更新”</p></li></ol><p>一般数据范围要在$10<sup>5$到$10</sup>6$能过</p><p>节点结构：</p><p>线段树需要维护节点信息，节点一般用结构体或类实现。一般维护以下信息：</p><ul class="lvl-0"><li class="lvl-2"><p>区间范围：包括左右端点L，R</p></li><li class="lvl-2"><p>区间对应的统计信息：由题目决定，包括区间和、区间最大值、区间最小值等</p></li></ul><p>五个核心函数：</p><ol><li class="lvl-3"><p><code>pushup</code>:用子节点信息更新当前节点信息(求和、取最大最小值等)</p></li><li class="lvl-3"><p><code>build</code>:在一段区间上初始化线段树</p><p>给定一个长度为N的序列A, 我们可以在区间 [1,N]上建立一颗线段树, 每个叶节点[i, i]保存A[i]的值。线段树的二叉树结构, 可以很方便地从下往上传递信息</p></li><li class="lvl-3"><p><code>modify</code>:单点修改单点修改是形如 “C x v” 的指令, 表示把A[x]的值修改为v。在线段树中, 根节点(编号从为1的节点) 是执行各种指令的入口。我们需要从根节点出发, 递归找到代表区间[x,x]的叶节点, 然后从下往上更新[x,x]以及他的所有祖先节点上保存的信息, 时间复杂度为 O(logN)</p></li><li class="lvl-3"><p><code>query</code>:区间查询</p><p>区间查询是一条形如&quot;Q l r&quot;的指令, 例如查询序列 A在区间[l,r]上的最大值, 即max(l&lt;=i&lt;=r){A[i]}:我们只需要从根节点开始, 递归执行一下过程:</p><ol><li class="lvl-6"><p>若[l, r]完全覆盖了当前节点代表的区间, 则立即回溯, 并且该节点的data值为候选答案</p></li><li class="lvl-7"><p>若左子节点与[l,r]有重叠部分, 则递归访问左子节点</p></li><li class="lvl-7"><p>若右子节点与[l,r]有重叠部分, 则递归访问右子节点</p></li></ol></li><li class="lvl-3"><p><code>pushdown</code>:懒标记时使用</p></li></ol><p>线段树的总结点数最多为4n，所以要保证线段树的数组长度不小于4N才能保证不会越界。线段树是二叉树，采用数组存储，对于任意结点，其父节点为$\lfloor\frac{x}{2}\rfloor$或<code>x &gt;&gt; 1</code>，左节点为<code>2x</code>或<code>x&lt;&lt;1</code>，右节点为<code>2x+1</code>或<code>x &lt;&lt; 1 | 1</code>，使用堆的存储方式</p><p><img src="https://mdpic.dreamgo.fun/img/%E7%BA%BF%E6%AE%B5%E6%A0%91.jpg" alt="线段树.jpg"></p><h3 id="AcWing-1264-动态求连续区间和-2"><a href="https://www.acwing.com/problem/content/1266/">AcWing 1264. 动态求连续区间和</a></h3><h4 id="C-3">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线段树——AcWing 1264. 动态求连续区间和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// 存储原序列值</span></span><br><span class="line"><span class="comment">// 线段树节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r; <span class="comment">// 结点所存储的区间范围</span></span><br><span class="line">    <span class="type">int</span> sum; <span class="comment">// 区间的和，根据题意可以维护区间最大值、最小值、和等</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 注意线段树的总结点数最多为4n，要大于此才能防止越界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用左右子节点信息更新当前节点信息</span></span><br><span class="line"><span class="comment">// u为节点编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">    <span class="comment">// 左儿子u &lt;&lt; 1 == 2 * u，右儿子u &lt;&lt; 1 | 1 == 2 * u + 1(| 1的作用是加1，因为右移后个位一定为0，或1后变为1)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一段区间上初始化线段树，递归建立并在回溯时更新信息</span></span><br><span class="line"><span class="comment">// 初始化时传入三个参数：节点编号，左右区间端点；节点编号即为在tr中下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件：叶子节点，l==r的原区间</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r]&#125;; <span class="comment">// 叶子节点的值即为原数组对应位置值</span></span><br><span class="line">    <span class="comment">// 区间长度为1，则为叶子结点，直接赋值即可，sum的值为自己本身</span></span><br><span class="line">    <span class="comment">// 注意这里不是w[u]而是w[r]</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 区间长度不为1，要进行递归二分</span></span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="comment">// 区间二分，递归赋根节点左右边界初值</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 区间划分点</span></span><br><span class="line">        <span class="comment">// 初始化左右儿子结点</span></span><br><span class="line">        <span class="comment">// 递归二分处理，直到变为叶子结点</span></span><br><span class="line">        <span class="comment">// 左节点编号2x(x &lt;&lt; 1)，区间[l, mid]</span></span><br><span class="line">        <span class="comment">// 右节点编号2x+1(x &lt;&lt; 1 | 1)，区间[mid + 1, r]；x &lt;&lt; 1后二进制末尾一定是0，此时与1即加1</span></span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l , mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 回溯更新祖先结点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="comment">// 求和时传三个参数：根结点编号，要查询区间的左右端点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 当前结点已被待求区间完全覆盖，直接返回其值即可</span></span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="comment">// 当前结点没有被待求区间完全覆盖</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>; <span class="comment">// 当前区间的中点</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// l &lt;= mid 说明左子结点区间有交集，递归求解</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="comment">// r &gt; mid 说明右子结点区间有交集，递归求解</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="comment">// 查询是一个递归的过程，可以求和、最大值、最小值等（取决节点中存啥）</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 单点修改</span></span><br><span class="line"><span class="comment">// 修改时传三个参数：根结点编号，插入的位置，插入的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == tr[u].r) tr[u].sum += v;</span><br><span class="line">    <span class="comment">// 叶子节点说明已经找到x的位置，直接修改即可</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 求区间中点，深入下一层进行修改，一直要深度到对应子区间</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v); <span class="comment">// 左子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v); <span class="comment">// 右子节点</span></span><br><span class="line">        <span class="comment">// 修改的过程是一个递归+回溯的过程</span></span><br><span class="line">        <span class="comment">// 需要修改对应子区间及其所有祖先节点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">        <span class="comment">// 注意更新祖先节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="comment">// 初始化时传入三个参数：根节点编号，左右区间端点</span></span><br><span class="line">    <span class="comment">// 初始化时把区间范围确定好</span></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k, a, b;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, a, b));</span><br><span class="line">        <span class="comment">// 求和时传三个参数：根结点编号，左右区间端点</span></span><br><span class="line">        <span class="comment">// 节点编号从0开始</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">1</span>, a, b);</span><br><span class="line">        <span class="comment">// 修改时传三个参数：根结点编号，插入的位置，插入的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Python-4">Python</h4><p>python线段树做法会TLE</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线段树——AcWing 1264. 动态求连续区间和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.l, self.r, self.<span class="built_in">sum</span> = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pushup</span>(<span class="params">u</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param u: 根节点</span></span><br><span class="line"><span class="string">    :return: 左右儿子之和</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    tr[u].<span class="built_in">sum</span> = tr[u &lt;&lt; <span class="number">1</span>].<span class="built_in">sum</span> + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].<span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">u, l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param u: 当前结点编号</span></span><br><span class="line"><span class="string">    :param l: 左边界（区间左端点）</span></span><br><span class="line"><span class="string">    :param r: 右边界*（区间右端点）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果该节点是叶子节点，那就知道它的值为该点的权值，该点编号就是l=r</span></span><br><span class="line">    <span class="keyword">if</span> l == r: 、</span><br><span class="line">        tr[u].l, tr[u].r, tr[u].<span class="built_in">sum</span> = l, r, w[r]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果不是叶子节点，那就需要先构造子树</span></span><br><span class="line">    <span class="comment"># 左二子是u * 2，区间是[l, mid]；右儿子是u * 2 + 1，区间是[mid + 1, r]</span></span><br><span class="line">    <span class="comment"># 构造好两个儿子后，用两个儿子的sum再求和得到父亲的sum</span></span><br><span class="line">        tr[u].l, tr[u].r = l, r</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">        build(u &lt;&lt; <span class="number">1</span>, l, mid), build(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r)</span><br><span class="line">        pushup(u)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">u, l, r</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param u: 根节点编号</span></span><br><span class="line"><span class="string">    :param l: 查询左端点</span></span><br><span class="line"><span class="string">    :param r: 查询右端点</span></span><br><span class="line"><span class="string">    :return: 区间和（返回节点u的区间[tr[u].l, tr[u].r]被区间[l, r]覆盖的数的和）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 如果编号为u的节点的左右端点都在[l, r]内，被完全覆盖，那就直接返回该值</span></span><br><span class="line">    <span class="keyword">if</span> tr[u].l &gt;= l <span class="keyword">and</span> tr[u].r &lt;= r:</span><br><span class="line">        <span class="keyword">return</span> tr[u].<span class="built_in">sum</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 否则返回左二子被该区间覆盖的数的和 + 右儿子被该区间覆盖的数的和</span></span><br><span class="line">        mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 如果区间[l, r]和左二子有交点，那就是mid &gt;= r，就要加上左二子被区间[l, r]覆盖的区域和</span></span><br><span class="line">        <span class="keyword">if</span> l &lt;= mid: <span class="built_in">sum</span> += query(u &lt;&lt; <span class="number">1</span>, l, r)</span><br><span class="line">        <span class="comment"># 如果区间[l, r]和右二子有交点，那就是r &gt;= mid + 1，就要加上右二子被区间[l, r]覆盖的区域和</span></span><br><span class="line">        <span class="keyword">if</span> r &gt; mid: <span class="built_in">sum</span> += query(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 在编号为u的节点区间[tr[u].l, tr[u].r]中找到i，并修改一系列的值        </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">u, x, v</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param u: 根节点编号</span></span><br><span class="line"><span class="string">    :param x: 插入位置</span></span><br><span class="line"><span class="string">    :param v: 插入的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 该点是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> tr[u].l == tr[u].r:</span><br><span class="line">        tr[u].<span class="built_in">sum</span> += v</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 该点不是叶子节点，如果i在左二子，那就更新左二子，如果i在右儿子中，那就更新右儿子</span></span><br><span class="line">    <span class="comment"># 然后再用儿子的新sum来更新父节点的新sum</span></span><br><span class="line">        mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x &lt;= mid:</span><br><span class="line">            modify(u &lt;&lt; <span class="number">1</span>, x, v)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            modify(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v)</span><br><span class="line">        pushup(u)</span><br><span class="line">        </span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">w = [<span class="number">0</span>] * (n + <span class="number">2</span>)</span><br><span class="line">w[<span class="number">1</span>:] = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># 为什么要开4n的区间呢，因为最后叶子节点可能不在一层，即可以理解为多加了一层吧，因为只## 要用到一层，就会用到该层的坐标</span></span><br><span class="line"><span class="comment"># 比如，1~5的区间，只用了9个节点，却不是一颗满二叉树，最后一层有一个叶子节点，所以还是# # 用到了4层，即需要开2**4 = 16个节点</span></span><br><span class="line">tr = [Node() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span> * n + <span class="number">5</span>)]</span><br><span class="line"><span class="comment"># 不能写tr = [Node()] * (4 * n + 5)</span></span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n) <span class="comment"># 根节点是一号点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    k, a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> k:</span><br><span class="line">        <span class="built_in">print</span>(query(<span class="number">1</span>, a, b))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        modify(<span class="number">1</span>, a, b)</span><br></pre></td></tr></table></figure><h3 id="AcWing-1270-数列区间最大值"><a href="https://www.acwing.com/problem/content/description/1272/">AcWing 1270. 数列区间最大值</a></h3><h4 id="C-4">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线段树——AcWing 1270. 数列区间最大值</span></span><br><span class="line"><span class="comment">// 也可使用RMQ，会更快，但不支持修改操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="comment">// INT_MAX int 最大值</span></span><br><span class="line"><span class="comment">// INT_MIN int 最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> maxv;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 注意线段树的总结点数最多为4n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用左右子节点信息更新当前节点信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].maxv = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].maxv, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一段区间上初始化线段树</span></span><br><span class="line"><span class="comment">// 初始化时传入三个参数：节点编号，左右区间端点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件：叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r]&#125;;</span><br><span class="line">    <span class="comment">// 区间长度为1，则为叶子结点，直接赋值即可，sum的值为自己本身</span></span><br><span class="line">    <span class="comment">// 注意这里不是w[u]而是w[r]</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 区间长度不为1，要进行递归二分</span></span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="comment">// 赋根节点左右边界初值</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l , mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// 初始化左右儿子结点</span></span><br><span class="line">        <span class="comment">// 递归二分处理，直到变为叶子结点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">        <span class="comment">// 回溯更新祖先结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="comment">// 求和时传三个参数：根结点编号，左右区间端点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    <span class="comment">// 当前结点已被待求区间完全覆盖，直接返回其值即可</span></span><br><span class="line">        <span class="keyword">return</span> tr[u].maxv;</span><br><span class="line">    <span class="comment">// 当前结点没有被待求区间完全覆盖</span></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当前区间的中点</span></span><br><span class="line">    <span class="type">int</span> maxv = INT_MIN; <span class="comment">// 最小值</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) maxv = <span class="built_in">max</span>(<span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r), maxv);</span><br><span class="line">    <span class="comment">// l &lt;= mid 说明左子结点区间有交集，递归求解</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) maxv = <span class="built_in">max</span>(<span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r), maxv);</span><br><span class="line">    <span class="comment">// r &gt; mid 说明右子结点区间有交集，递归求解</span></span><br><span class="line">    <span class="comment">// 是一个递归的过程，可以求和、最大值、最小值等（取决节点中存啥）</span></span><br><span class="line">    <span class="keyword">return</span> maxv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-5">Python</h4><p>会TLE</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线段树——AcWing 1270. 数列区间最大值</span></span><br><span class="line"><span class="comment"># 也可使用RMQ，会更快，但不支持修改操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.l, self.r, self.maxv = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pushup</span>(<span class="params">u</span>):</span><br><span class="line">    tr[u].maxv = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].maxv, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxv)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">u, l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> (l == r):</span><br><span class="line">        tr[u].l, tr[u].r, tr[u].maxv = l, r, w[r]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tr[u].l, tr[u].r = l, r</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">        build(u &lt;&lt; <span class="number">1</span>, l, mid), build(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r)</span><br><span class="line">        pushup(u)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">u, l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> tr[u].l &gt;= l <span class="keyword">and</span> tr[u].r &lt;= r:</span><br><span class="line">        <span class="keyword">return</span> tr[u].maxv</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span></span><br><span class="line">        maxv = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> l &lt;= mid: maxv = query(u &lt;&lt; <span class="number">1</span>, l, r)</span><br><span class="line">        <span class="keyword">if</span> r &gt; mid: maxv = <span class="built_in">max</span>(maxv,query(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r))</span><br><span class="line">        <span class="keyword">return</span> maxv</span><br><span class="line"></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">w = [<span class="number">0</span>] + <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">tr = [Node() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span> * n + <span class="number">1</span>)]</span><br><span class="line">build(<span class="number">1</span>, <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    l, r = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="built_in">print</span>(query(<span class="number">1</span>, l, r))</span><br></pre></td></tr></table></figure><p>类写法</p><p>摘自<a href="https://www.acwing.com/activity/content/code/content/1193711/">AcWing 1270. 数列区间最大值 - AcWing</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线段树——AcWing 1270. 数列区间最大值</span></span><br><span class="line"><span class="comment"># 类写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">treeNode</span>(<span class="title class_ inherited__">object</span>): <span class="comment"># 子节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.left = -<span class="number">1</span></span><br><span class="line">        self.right = -<span class="number">1</span></span><br><span class="line">        self.maxData = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n, data</span>): <span class="comment"># 构建线段树</span></span><br><span class="line">        self.size = n</span><br><span class="line">        self.maxSize = <span class="number">4</span> * n</span><br><span class="line">        self.treeNodes = [treeNode() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.maxSize + <span class="number">1</span>)]</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pushup</span>(<span class="params">self, cur</span>):</span><br><span class="line">        left_node = self.treeNodes[cur &lt;&lt; <span class="number">1</span>].maxData</span><br><span class="line">        right_node = self.treeNodes[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxData</span><br><span class="line">        self.treeNodes[cur].maxData = <span class="built_in">max</span>(left_node, right_node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self, cur, left, right</span>):</span><br><span class="line">        <span class="comment"># 如果说找到了单独的点，那么直接进行赋值</span></span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            self.treeNodes[cur].left = left</span><br><span class="line">            self.treeNodes[cur].right = right</span><br><span class="line">            self.treeNodes[cur].maxData = self.data[left] <span class="comment"># 单独的点的选择</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 说明是找到了一堆点，边界可以确定但是数值不能确定</span></span><br><span class="line">            self.treeNodes[cur].left = left</span><br><span class="line">            self.treeNodes[cur].right = right</span><br><span class="line"></span><br><span class="line">            mid = left + right &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="comment"># 构造左右子树</span></span><br><span class="line"><span class="comment">##            print(cur)</span></span><br><span class="line">            <span class="keyword">if</span> mid &gt;= left: <span class="comment"># 在if中已经略去了这种情况</span></span><br><span class="line">                self.build(cur &lt;&lt; <span class="number">1</span>, left, mid)</span><br><span class="line">            <span class="keyword">if</span> mid + <span class="number">1</span> &lt;= right: <span class="comment"># 在if中已经略去了这种情况</span></span><br><span class="line">                self.build(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, right) <span class="comment"># 可以保证左右子树一定存在吗？</span></span><br><span class="line">            <span class="comment"># 更新父节点的数值, 左右子节点中的较大值</span></span><br><span class="line">            self.pushup(cur)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, cur, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> self.treeNodes[cur].left &gt;= left <span class="keyword">and</span>  self.treeNodes[cur].right &lt;= right:</span><br><span class="line">            <span class="keyword">return</span> self.treeNodes[cur].maxData</span><br><span class="line">        <span class="comment"># print(&#x27;len(treeNodes), cur&#x27;, len(self.treeNodes), cur)</span></span><br><span class="line">        <span class="comment"># 为什么下标会超出边界?说明儿子的找法不够正确，不能保证一定会回溯，因此是构造的问题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果没有完全包含，则查询左右子树</span></span><br><span class="line">        mid = self.treeNodes[cur].left + self.treeNodes[cur].right &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        maxData = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="comment"># 判断是否需要左子树</span></span><br><span class="line">        <span class="keyword">if</span> mid &gt;= left:</span><br><span class="line">            maxData = <span class="built_in">max</span>(maxData, self.query(cur &lt;&lt; <span class="number">1</span>, left, right))</span><br><span class="line">        <span class="keyword">if</span> mid + <span class="number">1</span> &lt;= right: <span class="comment"># 判断是否需要右子树</span></span><br><span class="line">            maxData = <span class="built_in">max</span>(maxData, self.query(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, left, right))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新父节点的数值</span></span><br><span class="line">        <span class="keyword">return</span> maxData</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N, M = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()) <span class="comment"># 输入N个数据，查询M个区间</span></span><br><span class="line">data = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">data[<span class="number">1</span>:] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">tree = Tree(N, data)</span><br><span class="line">tree.build(<span class="number">1</span>, <span class="number">1</span>, N) <span class="comment"># 当前节点标号，左边界和右边界</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">    x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    res = tree.query(<span class="number">1</span>, x, y) <span class="comment"># 从根节点开始询问，从x到y之间的最大值</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="AcWing-1228-油漆面积"><a href="https://www.acwing.com/problem/content/1230/">AcWing 1228. 油漆面积</a></h3><p><a href="https://www.acwing.com/problem/content/description/249/">AcWing 247. 亚特兰蒂斯</a>的简化版，不需要离散化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1228. 油漆面积</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y1, y2;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Segment &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> cnt, len;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].cnt &gt; <span class="number">0</span>) tr[u].len = tr[u].r - tr[u].l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr[u].l == tr[u].r) tr[u].len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].cnt += k;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        seg[m ++ ] = &#123;x1, y1, y2, <span class="number">1</span>&#125;;</span><br><span class="line">        seg[m ++ ] = &#123;x2, y1, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(seg, seg + m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res += tr[<span class="number">1</span>].len * (seg[i].x - seg[i - <span class="number">1</span>].x);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, seg[i].y1, seg[i].y2 - <span class="number">1</span>, seg[i].k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扫描线法">扫描线法</h3><p>类似于积分，使用无限分割思想进行求解。</p><p>处理覆盖问题</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课7 时空复杂度分析</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-7-%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-7-%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="时空复杂度分析">时空复杂度分析</h1><h2 id="由数据范围反推算法复杂度以及算法内容">由数据范围反推算法复杂度以及算法内容</h2><p>一般ACM或者笔试题的时间限制是1秒或2秒。在这种情况下，C++代码中的操作次数控制在 $10<sup>7∼10</sup>8$为最佳。</p><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p><table><thead><tr><th style="text-align:center">数据的大小范围</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">常用算法</th></tr></thead><tbody><tr><td style="text-align:center">$n≤30$</td><td style="text-align:center">指数级别</td><td style="text-align:center">dfs+剪枝，状态压缩dp</td></tr><tr><td style="text-align:center">$n≤10^2$</td><td style="text-align:center">$O(n^3)$</td><td style="text-align:center">floyd，dp，高斯消元</td></tr><tr><td style="text-align:center">$n≤10^3 $</td><td style="text-align:center">$ O(n<sup>2)，O(n</sup>2logn)$</td><td style="text-align:center">dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</td></tr><tr><td style="text-align:center">$n≤10^4$</td><td style="text-align:center">$O(n\sqrt n)$</td><td style="text-align:center">块状链表、分块、莫队</td></tr><tr><td style="text-align:center">$n≤10^5$</td><td style="text-align:center">$ O(nlogn) $</td><td style="text-align:center">各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</td></tr><tr><td style="text-align:center">$n≤10^6$</td><td style="text-align:center">$ O(n), 常数较小的 O(nlogn) 算法$</td><td style="text-align:center">$O(n)算法$: 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机<br/> $常数比较小的 O(nlogn)的算法$：sort、树状数组、heap、dijkstra、spfa</td></tr><tr><td style="text-align:center">$n≤10^7$</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">双指针扫描、kmp、AC自动机、线性筛素数</td></tr><tr><td style="text-align:center">$n≤10^9$</td><td style="text-align:center">$ O(\sqrt n)$</td><td style="text-align:center">判断质数</td></tr><tr><td style="text-align:center">$n≤10^{18}$</td><td style="text-align:center">$ O(logn)$</td><td style="text-align:center">最大公约数，快速幂，数位DP</td></tr><tr><td style="text-align:center">$n≤10^{1000}$</td><td style="text-align:center">$O((logn)^2)$</td><td style="text-align:center">高精度加减乘除</td></tr><tr><td style="text-align:center">$n≤10^{100000}$</td><td style="text-align:center">$ O(logk×loglogk)$</td><td style="text-align:center">k表示位数，高精度加减、FFT/NTT</td></tr></tbody></table><p>比赛中自己估算复杂度是否会超时会爆栈，首先要记住，时间复杂度为10^7即1千万左右在1s内可以稳当地跑出来, 10^8跑1s很勉强, 有的题目可能卡过去, 有的就卡不过去。计算时间复杂度就是分析基本语句的执行次数，所以在套模板前应当先想一想算法的时间复杂度并和题目给的数据套上一套，分析一波再去敲~</p><p>对于空间复杂度，其实一般就是看用到的数组要开多少。怎么算呢？拿int数组举栗，一个int要4字节即4b，然后1kb能开25个int，然后一般的题目要么给32768kb，要么给65536kb，所以前者可以开790w左右大小的数组，后者可以开1580w左右的数组，long long折半(395w, 790w)。float 4字节，double 8字节，能开多少不言而喻。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课6 贪心</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-6-%E8%B4%AA%E5%BF%83/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-6-%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心">贪心</h1><ul class="lvl-0"><li class="lvl-2"><a href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800?fr=aladdin">贪心算法</a></li></ul><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。</p><p>贪心问题<strong>先分析局部情况，寻找局部最优解</strong>，循环求解局部最优解就能得到全局最优解</p><p>贪心问题往往是单极值的凸问题。</p><p>贪心问题往往要<strong>先进行排序</strong>，数据要有序才方便分析，<strong>能迭代的前提是建立某种迭代的标准(迭代顺序和优化测度）</strong>。</p><p>贪心是一种梯度下降的方法，想要求出极值，我们首先要<strong>建立自己的梯度和更新的机制</strong>，然后需要<strong>迭代求解</strong>。</p><p><strong>迭代的起始点往往是有优化测度有关的某一状态属性处于最值的点（局部最优解）</strong>。</p><p>贪心问题首先要有局部情况的研究进行猜想和多种尝试，再证明局部最优即即能得到全局最优</p><p>从问题的某一初始解出发；<br>while 能朝给定总目标前进一步 do<br>　　求出可行解的一个解元素；由所有解元素组合成问题的一个可行解</p><p>贪心的题目跳跃性很强，结论证明较难。首先的思路是转化套类型题，其次时进行猜测。</p><h2 id="算法思路">算法思路</h2><p>贪心算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪心算法采用自顶向下，以<strong>迭代的方法</strong>做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解。</p><p>贪心算法一般按如下步骤进行：</p><ol><li class="lvl-3"><p>建立数学模型来描述问题。要<strong>确定优化测度</strong>。</p></li><li class="lvl-3"><p>把求解的问题<strong>分成若干个子问题（集合划分）</strong>。是<strong>迭代划分</strong>的。</p></li><li class="lvl-3"><p>对每个子问题求解，得到子问题的<strong>局部最优解</strong>。</p></li><li class="lvl-3"><p>把子问题的解局部最优解合成原来解问题的一个解。</p></li></ol><h2 id="算法特性">算法特性</h2><p>贪心算法可解决的问题通常大部分都有如下的特性：</p><ol><li class="lvl-3"><p>有一个以最优方式来解决的问题。为了构造问题的解决方案，<strong>有一个候选的对象的集合</strong>：比如不同面值的硬币。</p></li><li class="lvl-3"><p>随着算法的进行，<strong>将积累起其他两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象</strong>。</p></li><li class="lvl-3"><p>有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。</p></li><li class="lvl-3"><p>还有一个函数检查是否一个候选对象的集合是可行的，即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。</p></li><li class="lvl-3"><p>选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。</p></li><li class="lvl-3"><p>最后，<strong>目标函数给出解的值</strong>。常用技巧：排序、维护最优解</p></li></ol><h3 id="证明方法">证明方法</h3><p>贪心是一种在每次决策时采取当前意义下最优策略的算法，因此，使用贪心法要求问题的整体最优性可以由局部最优性导出。贪心算法的正确性的证明手段有：</p><p>1.微扰(邻项交换)</p><p>证明在任意局面下，任何对局部最优策略的微小改变都会造成整体结果变差。经常用于<strong>以“排序”为贪心策略</strong>的证明。</p><p>2.范围缩放</p><p>证明任何对局部最优策略作用范围的扩展都不会造成整体结果变差。</p><p>3.决策包容性</p><p>证明在任何局面下，作出局部最优决策以后，在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之，这个局部最优策略提供的可能性包含其他所有策略提供的可能性。</p><p>4.反证法</p><p>5.数学归纳法</p><p>6.调整法</p><h4 id="迭代顺序与维护方法的确定">迭代顺序与维护方法的确定</h4><p>贪心问题往往涉及两个对象和一个标准，<strong>对于对象和标准都需要动态维护</strong>，维护的方法包括变量存储、排序、利用堆等数据结构等。有的问题只有一个对象的维护比较复杂，有的则两个都要仔细设计维护方法。</p><p>贪心问题一般<strong>首先要确定候选对象集（可行集、或需处理的对象集合、或使目标函数更新的对象集合），然后再在候选对象集中选择最优对象</strong>。前者需要一个<strong>判断可行性的函数或判断是否需处理的函数</strong>，后者需要确定<strong>最优策略</strong>。同时，要考虑对象之间是否存在替换性，候选对象是否可以被丢弃。有的问题只用在候选对象集中取最优解，其余对象都可以被丢弃（候选对象集每次动态变化）。有的问题则候选对象集就是剩余所有对象，且每个对象都要被处理，不能被丢弃。候选对象是否可丢弃对于迭代顺序影响很大。（会影响如何维护对象）</p><p>采用合适的迭代顺序是为了方便能够在一遍遍历的同时解决问题，因此就必须符合求解的需求。同时迭代的顺序还取决于对象的问题难度。不同问题，迭代顺序的针对的目的是不同的。有些问题必须首先确定候选对象集，因此我们迭代的顺序就最好满足<strong>候选对象和非候选对象（可行与不可行、需处理与不需处理、影响目标函数更新与不影响更新）的二段性</strong>（即临界点以左都是候选，<strong>避免候选和非候选的交错</strong>。由于对象不能随意丢弃，先遍历到的非候选对象在后续处理时可能变成候选对象，这就带来对象的维护难题）。然而有些问题，每个对象都必须进行处理，候选对象集就是剩余所有对象，这时就需要<strong>直接按照所有对象的最优性顺序迭代</strong>（如果不按最优性顺序，就需要对遍历到的其他对象进行维护，不能丢弃，因此就增加维护难度）。往往候选集中其他对象后面可能还会用到，不能丢弃时，就要按照候选集最优性顺序迭代。</p><p>总之，迭代顺序的选取是为了<strong>降低维护候选对象集的难度</strong>，同时方便是否为候选的判断，使问题通过循环遍历直接解决。</p><h3 id="时间复杂度">时间复杂度</h3><p>$10^5$ $O(nlogn)$ 排序</p><p>$10<sup>6-10</sup>7$ $O(n)$ 扫一遍，往往需要推公式等直接求</p><p>$1000$ $O(n^2)$ 两重循环</p><h2 id="区间问题">区间问题</h2><p>区间问题是常见的贪心问题模型。面对复杂问题，我们要尝试去除无关背景，专注本质，尝试转换为区间问题。</p><p>贪心并不是直接就能做的，一些预处理技巧都会被使用。</p><p><strong>区间问题往往需要先进行排序</strong>。进行了排序才方便进行分析和讨论，才能进行求解。为了方便求极值。显然，数据要有序才方便分析，能迭代的前提是建立某种迭代的标准。</p><p>要么按照左端点排序，要么按照右端点进行排序，要么就是双关键字排序。</p><p>证明可以采用反证法、夹逼法、同一法、调整法、归纳法等</p><p>贪心问题往往不需要太过复杂的策略，如果选择标准太过于复杂麻烦，约束太多则往往不对</p><h3 id="1-AcWing-905-区间选点">1. <a href="https://www.acwing.com/problem/content/907/">AcWing 905. 区间选点 </a></h3><p>解决思路：</p><ol><li class="lvl-3"><p>将每个区间按照右端点从小到大排序</p></li><li class="lvl-3"><p>从后往前依次枚举每个区间</p></li></ol><p>首先，我们要确定选择标准。为什么是按照右端点而不是按照左端点。</p><p>贪心的解首先是可行的解，每个区间一定要被选到，即每个区间在其结束之前要被选择到，且最优的选择时刻是其最晚被选择的时刻，即其右端点（结束的时刻）。</p><p>由此我们确定选择标准是右端点在最前面的点，点的位置为右端点。</p><p>而左端点在被选区间右端点前的点也都会被选中，为了避免重复，集合重新划分的标准是将候选集合中区间的左端点与被选区间的右端点进行比较。</p><p>这里候选对象集是需处理的区间的集合，即左端点大于当前最右端点的集合，且候选集中非最优解后续仍可能会被用到，不能丢弃，因此迭代顺序为候选集中最优性顺序，即将每个区间按照右端点从小到大排序。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230326214133811.png" alt="image-20230326214133811"></p><p><img src="https://mdpic.dreamgo.fun/img/image-20230328110910776.png" alt="image-20230328110910776"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——区间选点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载结构体或类的比较运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123; <span class="comment">// 注意这里使用sort进行排序的技巧</span></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; W.r; <span class="comment">// 升序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 定义比较函数</span></span><br><span class="line"><span class="comment">bool mycmp(Range a, Range b)&#123;</span></span><br><span class="line"><span class="comment">    return a.r &lt; b.r;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    <span class="comment">// sort(range, range + n, mycmp);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ed维护标准</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>; <span class="comment">// ed为选择标准和划分标准，表示被选区间右端点，首先初始化为极小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (range[i].l &gt; ed)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++ ;</span><br><span class="line">            ed = range[i].r; <span class="comment">// 标准更新</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sort-函数自定义排序">sort()函数自定义排序</h4><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.cnblogs.com/stones-dream/p/10183210.html">C++ 中的sort()排序函数用法</a></p></li></ul><p>sort() 函数有 2 种用法，其语法格式分别为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对 [first, last) 区域内的元素做默认的升序排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span> <span class="params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域；另外在第 2 种格式中，comp 可以是 C++ STL 标准库提供的排序规则（比如 std::greater<T>从大到小排序），也可以是自定义的排序规则。</p><ul class="lvl-0"><li class="lvl-2"><p>升序：sort(begin,end,less<data-type>())</p></li><li class="lvl-2"><p>降序：sort(begin,end,greater<data-type>())</p></li></ul><h5 id="自定义排序规则的方法">自定义排序规则的方法</h5><p>方法一：定义比较函数（最常用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：数组排列</span></span><br><span class="line"><span class="type">int</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//int为数组数据类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;<span class="comment">//降序排列</span></span><br><span class="line">    <span class="comment">//return a&lt;b;//默认的升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(A,A+<span class="number">100</span>,cmp1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：结构体排序</span></span><br><span class="line">Student Stu[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(Student a,Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id&gt;b.id;<span class="comment">//按照学号降序排列</span></span><br><span class="line">    <span class="comment">//return a.id&lt;b.id;//按照学号升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(Stu,Stu+<span class="number">100</span>,cmp2);</span><br></pre></td></tr></table></figure><p>注：比较方法也可以放在结构体中或类中定义。</p><p>方法二：重载结构体或类的比较运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：在结构体内部重载</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">double</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Student&amp; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id&gt;s.id;<span class="comment">//降序排列</span></span><br><span class="line">        <span class="comment">//return id&lt;s.id;//升序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Student&gt; V;</span><br><span class="line"><span class="built_in">sort</span>(V.<span class="built_in">begin</span>(),V.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：在外部重载 友元函数</span></span><br><span class="line">vector&lt;Student&gt; V;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Student&amp; s1, <span class="type">const</span> Student&amp; s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.id&gt;s2.id;<span class="comment">//降序排列</span></span><br><span class="line">    <span class="comment">//return s1.id&lt;s2.id;//升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(V.<span class="built_in">begin</span>(),V.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>注意：一定要重载&lt;运算符，因为系统默认是降序，用的是&lt;运算符。</p><p>方法三：声明比较类（少用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Less</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Student&amp; s1, <span class="type">const</span> Student&amp; s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.id&lt;s2.id; <span class="comment">//升序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sort</span>(sutVector.<span class="built_in">begin</span>(),stuVector.<span class="built_in">end</span>(),<span class="built_in">Less</span>());</span><br></pre></td></tr></table></figure><p>代码举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    <span class="comment">// std::sort</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="comment">//以普通函数的方式实现自定义排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mycomp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以函数对象的方式实现自定义排序规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mycomp2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt; j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myvector&#123; <span class="number">32</span>, <span class="number">71</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">33</span> &#125;;</span><br><span class="line">    <span class="comment">//调用第一种语法格式，对 32、71、12、45 进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>); <span class="comment">//(12 32 45 71) 26 80 53 33</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">begin</span>() + <span class="number">4</span>, std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">//(71 45 32 12) 26 80 53 33</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第二种语法格式，通过自定义比较规则进行排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(), <span class="built_in">mycomp2</span>());<span class="comment">//12 26 32 33 45 53 71 80</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出 myvector 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = myvector.<span class="built_in">begin</span>(); it != myvector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="comment"># 按右端点大小排序</span></span><br><span class="line">    rg = <span class="built_in">sorted</span>([<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    ed = - <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> l, r <span class="keyword">in</span> rg:</span><br><span class="line">        <span class="keyword">if</span> l &gt; ed:</span><br><span class="line">            ed = r</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-908-最大不相交区间数量">2. <a href="https://www.acwing.com/problem/content/910/">AcWing 908. 最大不相交区间数量</a></h3><p>该题的证明应用到了区间选点的结论，本质两题是等价的：</p><p><strong>最大不相交区间数==最少覆盖区间点数</strong></p><ol><li class="lvl-3"><p>将每个区间按照右端点从小到大进行排序</p></li><li class="lvl-3"><p>初始时，用ed表示当前放置在数轴上的点的位置，开始初始化为无穷小，表示没有放置，此时数轴上没有点</p></li><li class="lvl-3"><p>依次枚举排序好的每个区间。如果区间的左端点大于当前放置点的位置，说明当前点无法覆盖区间，则把点的位置更新成该区间的右端点，表示在该区间的右端点放置一个新的点，同时更新点的个数</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——最大不相交区间数量</span></span><br><span class="line"><span class="comment">// 本题代码与区间选点这题完全一样</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; W.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bool cmp(Range a, Range b)&#123;</span></span><br><span class="line"><span class="comment">    return a.r &lt; l.r;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) cin &gt;&gt; range[i].l &gt;&gt; range[i].r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line">    <span class="comment">// sort(range, range + n, cmp);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, ed = <span class="number">-2e9</span>;<span class="comment">// ed为选择和划分的标准</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (range[i].l &gt; ed)&#123; <span class="comment">// 选择标准——左端点大于已有边界（最大右端点）的第一个区间</span></span><br><span class="line">            ed = range[i].r; <span class="comment">// 标准更新——最大右端点</span></span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Pyhton">Pyhton</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    rg = <span class="built_in">sorted</span>([<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    ed = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> l, r <span class="keyword">in</span> rg:</span><br><span class="line">        <span class="keyword">if</span> l &gt; ed:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            ed = r</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="3-AcWing-906-区间分组">3. <a href="https://www.acwing.com/activity/content/problem/content/1113/">AcWing 906. 区间分组</a></h3><p>本题的划分标准是区间的左端点要大于小组最大右端点才能入组，如果小于所有组的最大右端点就要重新建一个小组。</p><p>而优化的关键在于让哪个区间优先入组，并且当一个区间能够进入多个小组时该如何选择。这里的决策是优先将候选集合中左端点最小的区间入组，并且将其加入到最大右端点最小的小组，这样才能避免冲突。这是因为该小组可能是该区间唯一能进入的小组，如果它不进入，就要另建一个小组，不是最优选择。</p><p>由此，我们要做以下工作：</p><ol><li class="lvl-3"><p>对区间按左端点由小到大排队，在前优先入组</p></li><li class="lvl-3"><p>记录每个小组的最大右端点作为入组标准，并且要维护所有小组中最小的最大右端点</p></li><li class="lvl-3"><p>将候选集合中左端点最小的区间加入到最大右端点最小的小组</p></li></ol><p>这里的一个难点是如何维护最小的最大右端点，维护最大值或最小值往往要采用堆排序的方法。</p><p>不需要真的分组，组的个数等于堆中元素个数。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230327103320721.png" alt="image-20230327103320721"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——区间分组，利用了小根堆维护最大右端点的最小值</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span><span class="comment">// STL中的堆即优先队列</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;<span class="comment">// 按左端点排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span> , vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="comment">// 使用小根堆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="keyword">auto</span> r = range[i];</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= r.l) heap.<span class="built_in">push</span>(r.r); </span><br><span class="line">        <span class="comment">// 划分标准：区间左端点是否大于最小Max_r</span></span><br><span class="line">        <span class="comment">// 先建一个小组 &lt;==&gt; 在堆中直接插入该区间的右端点作为堆的新元素</span></span><br><span class="line">        <span class="comment">// 组的个数等于堆中元素个数</span></span><br><span class="line">        <span class="comment">// 注意取等问题，端点相交也不行</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>(); <span class="comment">// 删除原有标准</span></span><br><span class="line">            heap.<span class="built_in">push</span>(r.r); <span class="comment">// 插入并更新标准</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这里所有元素都一定会被分组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, heap.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 堆的元素数 == 最大右端点数 == 小组数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="C-优先队列">C++优先队列</h4><ul class="lvl-0"><li class="lvl-2"><p><a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">c++优先队列(priority_queue)用法详解</a></p></li></ul><p>优先队列priority_queue即堆，默认是大根堆。在头文件&lt; queue&gt; 中。</p><p>priority_queue与queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。</p><p>优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的</p><p>和队列基本操作相同:</p><ul class="lvl-0"><li class="lvl-2"><p>top() 访问队头元素</p></li><li class="lvl-2"><p>pop() 弹出队头元素</p></li><li class="lvl-2"><p>empty() 队列是否为空</p></li><li class="lvl-2"><p>size() 返回队列内元素个数</p></li><li class="lvl-2"><p>push() 插入元素到队尾 (并排序)</p></li><li class="lvl-2"><p>emplace() 原地构造一个元素并插入队列</p></li></ul><p>和队列一样，没有clear()函数</p><p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><p>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</p><p>改成小根堆的方法：</p><ol><li class="lvl-3"><p>使用负数</p></li><li class="lvl-3"><p>priority_queue&lt;int , vector<int>, greater<int>&gt; heap</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// greater和less是std实现的两个仿函数</span></span><br><span class="line"><span class="comment">//（就是使一个类的使用看上去像一个函数。</span></span><br><span class="line"><span class="comment">// 其实现就是类中实现一个operator()，</span></span><br><span class="line"><span class="comment">// 这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure><h4 id="Python">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq <span class="comment"># 优先队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    rg = <span class="built_in">sorted</span>([<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> l, r <span class="keyword">in</span> rg:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> heap <span class="keyword">or</span> l &lt;= heap[<span class="number">0</span>]:</span><br><span class="line">            heapq.heappush(heap, r)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heapreplace(heap, r)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(heap))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h5 id="Python优先队列">Python优先队列</h5><p>heapq 库是Python标准库之一，提供了构建<strong>小顶堆</strong>的方法和一些对小顶堆的基本操作方法(如入堆，出堆等)，可以用于实现堆排序算法。</p><p>堆是一种基本的数据结构，堆的结构是一棵完全二叉树，并且满足堆积的性质：每个节点(叶节点除外)的值都大于等于(或都小于等于)它的子节点。</p><p>堆结构分为大顶堆和小顶堆，在heapq中使用的是小顶堆：</p><ol><li class="lvl-3"><p>大顶堆：每个节点(叶节点除外)的值都大于等于其子节点的值，根节点的值是所有节点中最大的。</p></li><li class="lvl-3"><p>小顶堆：每个节点(叶节点除外)的值都小于等于其子节点的值，根节点的值是所有节点中最小的。</p></li></ol><p>在heapq库中，heapq使用的数据类型是Python的基本数据类型 list ，要满足堆积的性质，则在这个列表中，索引 k 的值要小于等于索引 2<em>k+1 的值和索引 2</em>k+2 的值(在完全二叉树中，将数据按广度优先插入，索引为k的节点的子节点索引分别为2<em>k+1和2</em>k+2)。在heapq库的源码中也有介绍，可以读一下heapq的源码，代码不多。</p><p>使用Python实现堆排序可以参考：<a href="https://blog.csdn.net/weixin_43790276/article/details/104033696">https://blog.csdn.net/weixin_43790276/article/details/104033696</a></p><p>完全二叉树的特性可以参考：<a href="https://blog.csdn.net/weixin_43790276/article/details/104737870">https://blog.csdn.net/weixin_43790276/article/details/104737870</a></p><p><strong>二、使用heapq创建堆</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">array = [<span class="number">10</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">36</span>, <span class="number">21</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">    heapq.heappush(heap, num)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;array:&quot;</span>, array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap: &quot;</span>, heap)</span><br><span class="line"> </span><br><span class="line">heapq.heapify(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;array:&quot;</span>, array)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array: [<span class="number">10</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">36</span>, <span class="number">21</span>]</span><br><span class="line">heap:  [<span class="number">5</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">45</span>, <span class="number">17</span>, <span class="number">30</span>, <span class="number">36</span>, <span class="number">50</span>]</span><br><span class="line">array: [<span class="number">5</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">36</span>, <span class="number">50</span>]</span><br></pre></td></tr></table></figure><p>heapq中创建堆的方法有两种。</p><p><code>heappush(heap, num)</code>，先创建一个空堆，然后将数据一个一个地添加到堆中。每添加一个数据后，heap都满足小顶堆的特性。</p><p><code>heapify(array)</code>，直接将数据列表调整成一个小顶堆(调整的原理参考上面堆排序的文章，heapq库已经实现了)。</p><p>这里注意heapq不会创建存储变量，而必须将存储变量传入，heap只负责排序。当然也可以有<code>heap = heapq。heapify([])</code>的写法，总之一定要有传入存储变量</p><p>两种方法实现的结果会有差异，如上面的代码中，使用heappush(heap, num)得到的堆结构如下。</p><p><img src="https://mdpic.dreamgo.fun/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5MDI3Ng==,size_16,color_FFFFFF,t_70.png" alt="heappush"></p><p>使用heapify(array)得到的堆结构如下。</p><p><img src="https://mdpic.dreamgo.fun/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5MDI3Ng==,size_16,color_FFFFFF,t_70-1679922268360-1.png" alt="heapify"></p><p>不过，这两个结果都满足小顶堆的特性，不影响堆的使用(堆只会从堆顶开始取数据，取出数据后会重新调整结构)。</p><p><strong>三、使用heapq实现堆排序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">10</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">36</span>, <span class="number">21</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">    heapq.heappush(heap, num)</span><br><span class="line"><span class="built_in">print</span>(heap[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># print(heapq.heappop(heap))</span></span><br><span class="line">heap_sort = [heapq.heappop(heap) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heap))]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap sort result: &quot;</span>, heap_sort)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">heap sort result:  [<span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">30</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">50</span>]</span><br></pre></td></tr></table></figure><p>先将待排序列表中的数据添加到堆中，构造一个小顶堆，打印第一个数据，可以确认它是最小值。然后依次将堆顶的值取出，添加到一个新的列表中，直到堆中的数据取完，新列表就是排序后的列表。</p><p><code>heappop(heap)</code>，将堆顶的数据出堆，并将堆中剩余的数据构造成新的小顶堆。</p><p><strong>四、获取堆中的最小值或最大值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">10</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">30</span>, <span class="number">24</span>, <span class="number">27</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">36</span>, <span class="number">21</span>]</span><br><span class="line">heapq.heapify(array)</span><br><span class="line"><span class="built_in">print</span>(heapq.nlargest(<span class="number">2</span>, array))</span><br><span class="line"><span class="built_in">print</span>(heapq.nsmallest(<span class="number">3</span>, array))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">50</span>, <span class="number">45</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p><code>nlargest(num, heap)</code>，从堆中取出num个数据，从最大的数据开始取，返回结果是一个列表(即使只取一个数据)。如果num大于等于堆中的数据数量，则从大到小取出堆中的所有数据，不会报错，相当于实现了降序排序。</p><p><code>nsmallest(num, heap)</code>，从堆中取出num个数据，从最小的数据开始取，返回结果是一个列表。</p><p>这两个方法除了可以用于堆，也可以直接用于列表，功能一样。</p><p><strong>五、使用heapq合并两个有序列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array_a = [<span class="number">10</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">8</span>]</span><br><span class="line">array_b = [<span class="number">17</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">13</span>]</span><br><span class="line">array_merge = heapq.merge(<span class="built_in">sorted</span>(array_a), <span class="built_in">sorted</span>(array_b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;merge result:&quot;</span>, <span class="built_in">list</span>(array_merge))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">merge result: [<span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure><p><code>merge(list1, list2)</code>，将两个有序的列表合并成一个新的有序列表，返回结果是一个迭代器。这个方法可以用于<strong>归并排序</strong>。</p><p><strong>六、heapq替换数据的方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">array_c = [<span class="number">10</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">8</span>]</span><br><span class="line">heapq.heapify(array_c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;before:&quot;</span>, array_c)</span><br><span class="line"><span class="comment"># 先push再pop</span></span><br><span class="line">item = heapq.heappushpop(array_c, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;after: &quot;</span>, array_c)</span><br><span class="line"><span class="built_in">print</span>(item)</span><br><span class="line"> </span><br><span class="line">array_d = [<span class="number">10</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">8</span>]</span><br><span class="line">heapq.heapify(array_d)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;before:&quot;</span>, array_d)</span><br><span class="line"><span class="comment"># 先pop再push</span></span><br><span class="line">item = heapq.heapreplace(array_d, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;after: &quot;</span>, array_d)</span><br><span class="line"><span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">10</span>]</span><br><span class="line">after:  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">before: [<span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">10</span>]</span><br><span class="line">after:  [<span class="number">5</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p><code>heappushpop(heap, num)</code>，先将num添加到堆中，然后将堆顶的数据出堆。</p><p><code>heapreplace(heap, num)</code>，先将堆顶的数据出堆，然后将num添加到堆中。</p><p>两个方法都是即入堆又出堆，只是顺序不一样，可以用于替换堆中的数据。具体的区别可以看代码中的例子。</p><h3 id="4-AcWing-907-区间覆盖">4. <a href="https://www.acwing.com/activity/content/problem/content/1114/">AcWing 907. 区间覆盖</a></h3><p>本题的一大特点是候选区间是变化的，相当于有三个区间和两次筛选，这和区间分组这题类似的，但通过进行排序我们仍能非常方便的进行枚举而不用回溯。</p><p>本题使用调整法证明。</p><p>要区分迭代顺序和优化测度（选择函数）。</p><p>本题迭代顺序是所有区间按左端点从小到大顺序，选择函数（最优策略）则是选择能覆盖start的区间中，右端点最大的区间。</p><p>迭代顺序要便于最优策略的实施。如果按右端点从小到大顺序排序，可以发现</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230327103222358.png" alt="image-20230327103222358"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——区间问题——区间覆盖   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; W.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st, ed, n;<span class="comment">// st、ed为待覆盖区间的左右端点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;st, &amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        range[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(range, range + n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>; <span class="comment">// 标记是否能成功覆盖</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i, r = <span class="number">-2e9</span>; <span class="comment">// r用于记录候选区间的最大右端点</span></span><br><span class="line">        <span class="comment">// 筛选候选区间</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">        &#123;</span><br><span class="line">            r = <span class="built_in">max</span>(r, range[j].r); <span class="comment">// 记录候选区间的最大右端点</span></span><br><span class="line">            ++ j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r &lt; st) <span class="comment">// 候选区间的最大右端点与待覆盖区间的左端点比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res ++ ; <span class="comment">// 成功覆盖后，区间数增1</span></span><br><span class="line">        st = r; <span class="comment">// 更新选择候选区间的标准：更新待覆盖区间的左端点</span></span><br><span class="line">        i = j - <span class="number">1</span>; <span class="comment">// 抛弃当前候选集合中的所有区间，更新要枚举的原始区间的开始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st &gt;= ed) </span><br><span class="line">        &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-2">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    st, ed = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">    rg = <span class="built_in">sorted</span>([<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    find = <span class="literal">False</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        r = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> st &gt;= rg[i][<span class="number">0</span>]: </span><br><span class="line">            r = <span class="built_in">max</span>(r, rg[i][<span class="number">1</span>])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; st:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            st = r</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r &gt;= ed:</span><br><span class="line">            find = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(res <span class="keyword">if</span> find <span class="keyword">else</span> <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这题的代码我自己写卡了好久，问题就在于我将判断更新Max_r和遍历候选区间。导致出错的是一些边界情况如，最后一个区间恰是要选择的最后一个区间、区间长度为0等。写代码时为了避免边界出问题或其他一些没有考虑的问题，要采用分布思想，每个不同的逻辑功能处采用单独的一段代码进行处理，分块书写，不要怕麻烦。</p><h3 id="5-AcWing-111-畜栏预定">5. <a href="https://www.acwing.com/problem/content/113/">AcWing 111. 畜栏预定</a></h3><p>本题显然是一个区间分组问题，不过要记录的信息多一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r, x, w;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Range a,  Range b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(Range a,  Range b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp3</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> P &amp;a,  <span class="type">const</span> P &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line">        range[i].w = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(range + <span class="number">1</span>, range + n + <span class="number">1</span>, cmp1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;P, vector&lt;P&gt;, cmp3&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>().first &gt;= range[i].l)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            heap.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(range[i].r, res));</span><br><span class="line">            range[i].x = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            P min = heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(range[i].r, min.second));</span><br><span class="line">            range[i].x = min.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(range + <span class="number">1</span>, range + n + <span class="number">1</span>, cmp2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, range[i].x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-AcWing-110-防晒">6. <a href="https://www.acwing.com/activity/content/problem/content/344/">AcWing 110. 防晒</a></h3><p>这里有两个对象——奶牛和防晒霜，所以对于两者都要进行维护和处理。</p><p>奶牛和防晒霜都有多个，为了便于分析，显然要一瓶一瓶防晒霜的处理。</p><p>奶牛需要强度实际上是一个区间，所以这是区间问题。</p><p>显然最基本的，需求低的牛涂作用低的防晒霜，所以防晒霜和奶牛都要排序才方便处理。每个防晒霜都有其可作用奶牛的集合，我们以防晒霜为标准从左到右筛选奶牛，确定候选集合。需求的左端点小于此防晒霜、右端点大于当前防晒霜才可以涂。</p><p>对于可以涂的候选集合，右端点小的一定会优先涂。这是因为如果右端点小的可以用后续的防晒霜，右端点大的也一定可以。反之则不行。有最优方案是能涂完就涂完，所以按照右端点顺序依次涂，直至涂完。</p><p>本题我最初还是分析错了，我忽略了一个问题：有些右端点偏左的牛左端点可能偏右，可能不能涂当前的防晒霜，但可以涂下一个防晒霜，这就出现了回溯问题，无法循环迭代。但是牛按右端点排序是没问题，因为就算只能涂下一个防晒霜，也一定优先涂，符合要求的牛右端点偏左的一定优先涂，且一定涂从左到右第一个符合的防晒霜。这意味我们需要双循环，对防晒霜也采用最优策略：从左到右排序，第一个大于左端点的还有剩余的防晒霜一定涂給当前的牛。</p><p>这样我们就可以发现我们之前的致命错误：牛和防晒霜基本是同地位的，对两者都要筛选最优来配对，不能只考虑牛或防晒霜。双变量（双筛选）则意味着双循环。</p><p>处理双循环的另一个关键问题是谁为内循环，谁为外循环。本题牛为外循环，很简单，因为牛有两个端点，防晒霜只有一个点坐标。而本题内循环本质上会出现回溯，需要进行标记。如果牛作为内循环，就会出现比较复杂的回溯，而防晒霜作为内循环比较容易标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;w)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; w.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cover</span>&#123;</span><br><span class="line">    <span class="type">int</span> c, n;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Cover &amp;w)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; w.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;cover[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, l;</span><br><span class="line">    cin &gt;&gt; c &gt;&gt; l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;range[i].l, &amp;range[i].r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;cover[i].c, &amp;cover[i].n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range, range + c);</span><br><span class="line">    <span class="built_in">sort</span>(cover, cover + l);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="type">bool</span> st = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (cover[j].c &gt;= range[i].l &amp;&amp; cover[j].n)&#123;</span><br><span class="line">                st = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (st &amp;&amp; cover[j].c &lt;= range[i].r)&#123;</span><br><span class="line">            res ++;</span><br><span class="line">            cover[j].n--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-AcWing-112-雷达设备">7. <a href="https://www.acwing.com/activity/content/problem/content3/1766/">AcWing 112. 雷达设备</a></h3><h4 id="逆向思维">逆向思维</h4><p>本题实际上可以转化为“区间选点”问题，并不难然而我却被题目的表述形式卡住了。</p><p>本题雷达站有一特性：都固定在x轴上，是一维；而海岛则是二维的，可以分布在x轴上方任意位置。</p><p>本题的要求是让雷达覆盖小岛，雷达是动的，但规格确定。如果直接去思考如何让雷达去覆盖小岛是很麻烦的，因为覆盖的范围是二维的圆，寻找一个雷达能够覆盖到的小岛很不方便。</p><p>二维问题过于复杂，尝试转化为一维。<strong>关键在于入手对象的选取</strong>。多个对象时，要从简单的对象入手。前面<a href="https://www.acwing.com/activity/content/problem/content/344/">AcWing 110. 防晒</a>这道题也是类似，对于防晒霜和奶牛，我们首先从防晒霜入手而不是奶牛。</p><p>然而考虑到已知条件，我们完全可以预处理以下，找到每个小岛可以被雷达覆盖时，雷达所需要的临界条件（此时是一维的条件了），此时我们就可以<strong>化二维为一维</strong>，大大简化问题。每个小岛能否被覆盖此时就对应于一个一维区间范围，问题也就<strong>转化为了“区间选点”问题</strong>。</p><p>本题再次反映了我在思考问题时思维的僵化，要学会在理解题目的基础上对题目进行一定的处理，实现问题表述和思考逻辑的转化，充分简化问题。</p><p>本题我们用到了逆向思维、二维化一维的思维，转化化归为基本模型的思维，利用已知条件预处理从而简化条件和问题的方法。</p><p><img src="https://mdpic.dreamgo.fun/img/1130_2b828e0e3d-%E9%9B%B7%E8%BE%BE%E8%AE%BE%E5%A4%872.png" alt="1130_2b828e0e3d-雷达设备2"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——区间问题——AcWing 1247. 后缀表达式</span></span><br><span class="line"><span class="comment">// 利用逆向思维、二维化一维的思维可以转化化归为区间选点的基本问题</span></span><br><span class="line"><span class="comment">// 贪心——区间问题——AcWing 1247. 后缀表达式</span></span><br><span class="line"><span class="comment">// 利用逆向思维、二维化一维的思维可以转化化归为区间选点的基本问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span>&#123;</span><br><span class="line">    <span class="type">double</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Range &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; W.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="type">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (d &lt; y)</span><br><span class="line">            failed = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">double</span> len = <span class="built_in">sqrt</span>(d * d - y * y);</span><br><span class="line">            range[i].l = x - len;</span><br><span class="line">            range[i].r = x + len;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(range, range + n);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; </span><br><span class="line">        <span class="type">double</span> ed = <span class="number">-1e20</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (range[i].l &gt; ed)&#123;</span><br><span class="line">                ed = range[i].r;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Huffman树">Huffman树</h2><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p>哈夫曼树的关键特性是<strong>带权路径最小</strong>，<strong>凡是问题要求解的量可以转化为二叉树的带权路径的，就可以用哈夫曼树来求其最小值</strong>。</p><p>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。</p><h3 id="构造过程">构造过程</h3><p>哈夫曼树的构造过程使用的是贪心的策略</p><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：<br>(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；<br>(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；<br>(3)从森林中删除选取的两棵树，并将新树加入森林；<br>(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</p><h3 id="构建哈弗曼树的算法实现">构建哈弗曼树的算法实现</h3><p>构建哈夫曼树时，需要每次根据各个结点的权重值，<strong>筛选出其中值最小的两个结点</strong>，然后构建二叉树。</p><p>查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：</p><ul class="lvl-0"><li class="lvl-2"><p>如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；</p></li><li class="lvl-2"><p>如果介于两个结点权重值之间，替换原来较大的结点；</p></li></ul><p>由于哈夫曼树是二叉树，我们可以<strong>使用优先队列（堆）来实现</strong>，<strong>每次更新时，会取出最小的两个值，并将其和重新放入集合</strong>，为了便于维护排序，可使用小根堆。</p><p>权重越小的点，放的深度越深。</p><h3 id="1-AcWing-148-合并果子">1. <a href="https://www.acwing.com/activity/content/problem/content/1115/">AcWing 148. 合并果子</a></h3><p>合并堆的过程可以被视作由底向上构建树的过程，总代价就是树的带权路径，因此可以构建Huffman树求最小值。</p><p>使用小根堆维护所有果子，每次弹出堆顶的两堆果子，并将其合并，合并之后将两堆重量之和再次插入小根堆中。</p><p>每次操作会将果子的堆数减一，一共操作 $n - 1$ 次即可将所有果子合并成 1 堆。每次操作涉及到 2 次堆的删除操作和 1 次堆的插入操作，计算量是 $O(logn)$。因此总时间复杂度是 $O(nlogn)$。</p><p>微扰法证明</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230327113847759.png" alt="image-20230327113847759"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——huffman数——合并果子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span> , vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// res 即带权路径和WPL， 在本题中每个结点到其父节点的路径权重为其自身值得大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">    <span class="comment">// 只剩根节点时即结束</span></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123; </span><br><span class="line">        <span class="type">int</span> a = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = heap.<span class="built_in">top</span>(); heap.<span class="built_in">pop</span>(); </span><br><span class="line">        <span class="comment">// 取出最小的两个结点；注意priority_queue.pop()是没有返回值的</span></span><br><span class="line">        res += a + b;</span><br><span class="line">        <span class="comment">// WPL要增加这两个节点到其合并出的父节点的路径权重（即各自的值大小）</span></span><br><span class="line">        heap.<span class="built_in">push</span>(a + b);</span><br><span class="line">        <span class="comment">// 将新生成的结点再次放入集合（堆）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Python-3">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="comment"># 使用小根堆维护哈夫曼树节点</span></span><br><span class="line">    heap = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    </span><br><span class="line">    heapq.heapify(heap)</span><br><span class="line">    </span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(heap) &gt; <span class="number">1</span>:</span><br><span class="line">        a = heapq.heappop(heap)</span><br><span class="line">        b = heapq.heappop(heap)</span><br><span class="line">        heapq.heappush(heap, a + b)</span><br><span class="line">        res += a + b</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="排序不等式">排序不等式</h2><p>这种题型使用先进行排序，利用排序不等式从小到大即为最优方案。</p><p>排序不等式（Rearrangement Inequality）又称排序原理，是数学上的一种不等式。排序不等式表述如下。</p><p>设有两数列$a_1, a_2, \cdots, a_n$和$b_1, b_2, \cdots, b_n$，满足$a_1\leq a_2\leq \cdots\leq a_n$，$b_1 \leq b_2\leq \cdots\leq b_n$， $c_1,c_2,\cdots,c_n$是$b_1, b_2, \cdots, b_n$的乱序排列，则有：<br>$$<br>\sum\limits<sup>n_{i=1}a_ib_{n+1-i}\leq\sum\limits</sup>n_{i=1}a_ic_i\leq\sum\limits^n_{i=1}a_ib_i<br>$$<br>当且仅当$a_i=a_j$ 或 $b_i=b_j(1\leq i,j\leq n)$时等号成立。</p><p>简单说就是按照从小到大的“顺序”相乘的和最大；按照相反顺序，也就是“逆序”相乘的和最小；混乱顺序则处于二者之间。(<strong>正序和大于等于乱序和，乱序和大于等于逆序和</strong>)</p><p>证明使用调整法（微扰），推不等式</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230327115605559.png" alt="image-20230327115605559"></p><h3 id="1-AcWing-913-排队打水">1. <a href="https://www.acwing.com/activity/content/problem/content/1213/">AcWing 913. 排队打水</a></h3><p>其实就是单机调度问题。<br>$$<br>s_i = t_1 + t_2 + t_3 + \cdots + t_{i-1}<br>$$<br>$$<br>sum = \sum\limits_{i} s_i<br>$$<br>看到上式我们可以相当前缀和，但其实如果我们耐性整理的话，可以整理出更清晰的式子，整理可得<br>$$<br>sum = t_1 * (n-1) + t_2 * (n-2) + \cdots + t_{n-1} * 1 + t_n * 0<br>$$</p><p>代价可以直接中公式求出。得到公式后既可以利用不等式放缩得到最优解情况，这里利用排序不等式即可。</p><p>由此，我们可以得到贪心策略：按照从小到大的顺序排列，总时间最小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——推公式——排队打水</span></span><br><span class="line"><span class="comment">// 利用了排序不等式</span></span><br><span class="line"><span class="comment">// 贪心策略：按照从小到大的顺序排列，总时间最小</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL; <span class="comment">// 注意爆int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(t, t + n);</span><br><span class="line">    <span class="built_in">reverse</span>(t, t + n);</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res += t[i] * i;</span><br><span class="line">    <span class="comment">// 没有reverse，则写成： res += t[i] * (n - i - 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Python-4">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    nums = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">sum</span>(nums[i] * (n - i - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="绝对值不等式">绝对值不等式</h2><p>$| a |$表示数轴上的点a与原点的距离叫做数a的绝对值</p><p>$$<br>||a| - |b|| ≤ |a+b| ≤ |a|+|b|<br>$$<br>当且仅当$ ab≤0 $时左边等号成立，$ab≥0$ 时右边等号成立</p><p><strong>几何意义</strong><br>1、当a，b同号时它们位于原点的同一边，此时a与﹣b的距离等于它们到原点的距离之和。<br>2、当a，b异号时它们分别位于原点的两边，此时a与﹣b的距离小于它们到原点的距离之和。(|a-b|表示a-b与原点的距离，也表示a与b之间的距离)<br>$$<br>|b - a|\leq|a - x| + |b - x|<br>$$</p><p>$|a - x| + |b - x|$几何意义是x到a, b两点距离之和</p><h3 id="1-AcWing-104-货仓选址">1. <a href="https://www.acwing.com/activity/content/problem/content/1214/">AcWing 104. 货仓选址</a></h3><p>设出所有点的值，写出对应公式，从公式的角度推导出如何取最小值</p><p>这题推导时变形的非常巧妙，对我个人而言还是很难想到的。同时本题是很基本的模板和类型题，做法需要铭记。</p><p>中位数有非常优秀的性质，比如说在这道题目中，每一个点到中位数的距离，都是满足全局的最优性，而不是局部最优性。</p><p>我们设在仓库左边的所有点，到仓库的距离之和为pp,右边的距离之和则为qq，那么我们就必须让p+qp+q的值尽量小。</p><p>当仓库向左移动的话，pp会减少xx，但是qq会增加n−xn−x，所以说当为仓库中位数的时候,p+qp+q最小。</p><p>本题的解决关键是推出目标的公式表示，然后再利用绝对值不等式。为此先把所有点假设表述出来。推出公式后有个小难点时这里利用不等式时也是从局部的思路来思考的，而不是整体一起应用不等式（<strong>分组的技巧</strong>）。本题证明的核心就在于分组。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230328100507923.png" alt="image-20230328100507923"></p><p><img src="https://mdpic.dreamgo.fun/img/image-20230328100437179.png" alt="image-20230328100437179"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——推公式——货仓选址</span></span><br><span class="line"><span class="comment">// 本题使用绝对值不等式</span></span><br><span class="line"><span class="comment">// 排序+中位数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; q[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(q, q + n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) res += <span class="built_in">abs</span>(q[i] - q[n &gt;&gt; <span class="number">1</span>]);<span class="comment">// q[n/2]</span></span><br><span class="line">    <span class="comment">// abs(q[i] - q[n/2])对于n为就奇偶都成立</span></span><br><span class="line">    <span class="comment">// 如果有奇数个数，则一定在中位数处</span></span><br><span class="line">    <span class="comment">// 如果有偶数个数，则一定在中间两个数之间，包括端点，所以取前一个数q[n /2]没问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Python-5">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    nums = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line">    mid = n // <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># res = 0</span></span><br><span class="line">    <span class="comment"># for i in range(mid):</span></span><br><span class="line">    <span class="comment">#     res += nums[n - i - 1] - nums[i] </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>([nums[n - i - <span class="number">1</span>] - nums[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mid)]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 切片写法</span></span><br><span class="line">    <span class="comment"># if n &amp; 1:</span></span><br><span class="line">    <span class="comment">#     nums = nums[:mid] + nums[mid+1:]</span></span><br><span class="line">    <span class="comment"># print(sum(nums[mid:]) - sum(nums[:mid]))</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="拓展与其他写法">拓展与其他写法</h4><h2 id="推公式">推公式</h2><p>很多贪心问题都是先推公式，然后利用不等式的原理，求出最优解，而不是从直觉上想</p><p>要对题目进行量化表示，明确目标函数和约束条件，进行变形和推导，同时利用一些常用的不等式等数学技巧，推出相应公式，从公式的角度应用不等式的原理。</p><p>常用不等式有均值不等式、调和不等式、柯西不等式、排序不等式、绝对值不等式等。</p><p>为了写出公式，首先要把所有对象对应量表示出来。有些时候可以直接写出去目标函数全局公式，有些时候则不能。对于不方便写出全局公式的，可以使用邻项交换法等进行表示和分析。</p><h3 id="1-AcWing-125-耍杂技的牛-AcWing">1. <a href="https://www.acwing.com/activity/content/problem/content/1215/">AcWing 125. 耍杂技的牛 - AcWing</a></h3><p>本题所要求的其实就是找到一种最优的排序方法。</p><p>考虑到贪心策略，我们先研究局部的排序方法，最小的局部即相邻的两个项如何排序。</p><p>这里<strong>关键要意识到相邻的两项互换的话并不会影响其他项的值</strong>，只会影响这两项的值，因此自然想到用邻项交换法。</p><p>邻项交换法（微扰）求某个排列问题中考虑交换两个相邻项看哪种更优。比较微扰后的代价和之前的代价哪一个更大。这种方法不仅可用于证明贪心策略的有效性，<strong>也可用于进行问题的推导</strong>。</p><p>这是一种类似冒泡排序的思想，每次相邻项的交换都使答案更优，而当全排好后相邻的都达到最优，而全局最大值就是这些相邻对最大值之一，于是全局最大值能够最小。</p><p>本题<strong>使用邻项交换法，先求出使得相邻两项最优的排序方法</strong>。这需要进行数学推导，表示出目标函数、约束条件、已知量，进行分类讨论，可以非常容易的推到出最有条件。只需注意推导时要灵活代数变形。（具体略，可参考<a href="https://www.acwing.com/file_system/file/content/whole/index/content/1764911/">AcWing 125. 耍杂技的牛（严密推导，自然分析，不需要直觉）</a>）</p><p>经过数学推导，可以发现最优条件是将$w + s$小的放上面，大的放下面。同时迭代思路是按照这种思路进行全排序，按照$w_i + s_i$从小到大的顺序排，风险系数一定是最小的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——推公式——耍杂技的牛</span></span><br><span class="line"><span class="comment">// 重点利用了邻项交换（微扰）法进行推导和证明</span></span><br><span class="line"><span class="comment">// 贪心策略：按照 w + s从小到大的顺序排</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// 使用pair</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">PII cow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;s);</span><br><span class="line">        cow[i] = &#123;w + s, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(cow, cow + n);</span><br><span class="line">    <span class="comment">// 使用sort()对pair排序时，默认对first升序，当first相同时对second升序；</span></span><br><span class="line">    <span class="comment">// 但需注意这里不要误解为：如果强度和重量之和相等，必须按照重量从小到大排</span></span><br><span class="line">    <span class="comment">// 实际上我们推出的条件是按w + s来排序的，当其相等时，随意排或按照w排或按照s排都可以</span></span><br><span class="line">    <span class="comment">// 而这里使用pair的目的不是为了双关键字排序，而仅仅是为了便于存储，(w + s, w或s)的存储方式可以方便在排序后仍能轻松得到w和s各自的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2e9</span>, sum = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> s = cow[i].first - cow[i].second, w = cow[i].second;</span><br><span class="line">        res = <span class="built_in">max</span>(res, sum - s);</span><br><span class="line">        sum += w; <span class="comment">// 计算前 i - 1项的重量和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-pair">C++ pair</h4><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。</p><p>pair的实现是一个结构体，主要的两个成员变量是first和second。因为是使用struct不是class，所以可以直接使用pair的成员变量。</p><p>其标准库类型–pair类型定义在#include <utility>头文件中，定义如下：</p><p>类模板：template&lt;class T1,class T2&gt; struct pair</p><p>参数：T1是第一个值的数据类型，T2是第二个值的数据类型。</p><p>功能：pair将一对值(T1和T2)组合成一个值，</p><ul class="lvl-0"><li class="lvl-2"><p>这一对值可以具有不同的数据类型（T1和T2），</p></li><li class="lvl-2"><p>两个值可以分别用pair的两个公有函数first和second访问。</p></li></ul><p>使用sort()对pair排序时，默认对first升序，当first相同时对second升序；</p><h4 id="Python-6">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    data = <span class="built_in">sorted</span>([<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], key = <span class="keyword">lambda</span> x: <span class="built_in">sum</span>(x))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    res = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">    sums = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w, s <span class="keyword">in</span> data:</span><br><span class="line">        res = <span class="built_in">max</span>(res, sums - s)</span><br><span class="line">        sums += w</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-114-国王游戏">2. <a href="https://www.acwing.com/activity/content/problem/content/348/">AcWing 114. 国王游戏</a></h3><p>本题与“耍杂技的牛”的解题思路基本一致，为贪心推公式的方法。</p><p>本题的目标是一种最优的排序方式，而相邻项进行比较、冒泡排序的方法不仅适用于单纯的数值排序，也适用于具有更复杂排序标准的排序问题。这种方法可以采用邻项比较（微扰）法证明。</p><p>由此，本题进行数学表示，研究相邻项比较标准的数学表达式，最终得到的贪心策略时两手的数的乘积更小的往前排，按照两手的数的乘积大小从小到大排。</p><p>但本题的一个难点是用到高精度数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">PII p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt;a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">bool</span> is_first = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>, t = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        t = t * <span class="number">10</span> + a[i];</span><br><span class="line">        <span class="type">int</span> x = t / b;</span><br><span class="line">        <span class="keyword">if</span> (!is_first || x)</span><br><span class="line">        &#123;</span><br><span class="line">            is_first = <span class="literal">false</span>;</span><br><span class="line">            c.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        t %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">max_vec</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>()) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>()) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(a.<span class="built_in">rbegin</span>(), a.<span class="built_in">rend</span>()) &gt; <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(b.<span class="built_in">rbegin</span>(), b.<span class="built_in">rend</span>())) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        p[i] = &#123;a * b, a&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">product</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) res = <span class="built_in">max_vec</span>(res, <span class="built_in">div</span>(product, p[i].first / p[i].second));</span><br><span class="line">        product = <span class="built_in">mul</span>(product, p[i].second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) cout &lt;&lt; res[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>处理多次询问的题许多都用前缀和</p><p>用差分实现区间操作</p><h3 id="3-AcWing-1536-均分纸牌">3. <a href="https://www.acwing.com/problem/content/solution/1538/1/">AcWing 1536. 均分纸牌</a></h3><h4 id="考虑-“纸牌均分问题”-如何解决？">考虑 “纸牌均分问题” 如何解决？</h4><p>设一共有 M个人，每个人初始的纸牌数量为$c_i$，纸牌总数为$T$<br>显然当 $M∤T$时，方案不存在，现只考虑方案存在的情况</p><p>第 1 个人为了达到平均持有数，需要向第 2 个人传递 $c_1−T/M$数量的牌（正数是给，负数是拿）</p><p>第 2 个人为了达到平均持有数，需要向第 3 个人传递 $c_2−T/M+c1−T/M$数量的牌</p><p>…</p><p>第 n-1 个人为了达到平均持有数，需要向第 n 个人传递 $∑^{n−1}_{i=1}c_i−(n−1)×T/M$数量的牌</p><p>此时前 n-1 人都达到了平均数，则第 n 个人必然也达到了平均数</p><p>统计易得，最小交换次数为：</p><p>$$<br>\sum_{i=1}<sup>{n−1}|\sum_{j=1}</sup>i(cj−TM)|<br>$$</p><p>不妨设 $Ai=ci−T/M$，于是化简可得：</p><p>$$<br>\sum_{i=1}<sup>{n−1}|\sum_{j=1}</sup>i A_j|=\sum_{i=1}^{n−1}|S_i|，其中 S_i 为 A_i 的前缀和，即 S_i=\sum_{j=1}^iA_j<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——前缀和——AcWing 1536. 均分纸牌</span></span><br><span class="line"><span class="comment">// 贪心策略：从左往右开始传递使每一个符合要求（等于平均值），符合要求则不传递</span></span><br><span class="line"><span class="comment">// 利用前缀和的原因：第i个和第i+1个互传后不影响s[i+1]以及往后的所有前缀和的大小</span></span><br><span class="line"><span class="comment">// 传递后，前i个已经符合要求，s[i] == i * ave</span></span><br><span class="line"><span class="comment">// 此时第i+1个如果不符合要求则s[i+1] != (i+1) * ave（至于前i个具体如何传递的不用考虑，因为s[i+1]不变）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i<span class="number">-1</span>]; <span class="comment">// 求前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ave = s[n] / n, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] - i * ave != <span class="number">0</span>)&#123; <span class="comment">// 选择的标准</span></span><br><span class="line">            res ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-AcWing-122-糖果传递">4. <a href="https://www.acwing.com/activity/content/problem/content/1765/">AcWing 122. 糖果传递</a></h3><p>本题首先要用数学知识进行问题的表示和推导，这一步比较难。然后通过观察推导出的代数式，我们可以联想基本题型，进而可以转化为货仓选址问题（贪心类绝对值不等式）。</p><p>首先我们进行数学分析和表示。我们用A[i]表示最初每个人的糖果数。可以发现，为了最优，一定不会出现两人之间的双向传递，只会由一人传向另一人，为此我们可以将两人之间的传递值用C[i]表示，C[i]正负都可以，正表示由前一个传给后一个，负表示由后一个传给前一个。</p><p>传递的过程是复杂的，但我们可以确定最终所有人获得糖果相同，因而$C[i] = |A[i] - ave|$一定成立。</p><p>我们优化的目标是：<br>$$<br>Min =\sum\limits^n_{i=1}|C[i]|<br>$$</p><p>同时分析临界情况，本问题是一个环形的糖果交换问题，则一定存在一种最优解使得某两个人之间没有交换。就是要么a给b，要么b给a，不能a给了b，b又给了a，如果存在这样的交换，就不是最优解了，可以用反证法证明。（这所以会想到这个性质是因为我们试图将环形转化为线性，更方便解决）</p><h4 id="思路一：前缀和-贪心">思路一：前缀和 + 贪心</h4><p>通常，涉及连续子数组问题的时候，我们使用前缀和来解决。前缀和的作用主要体现在能快速求出一个数组中一段连续区间的和，</p><p>当序列中需要相邻项相互传递值时往往可以利用前缀和来求解。</p><h5 id="考虑-“纸牌均分问题”-如何延伸到-“环形纸牌均分问题”-？">考虑 “纸牌均分问题” 如何延伸到 “环形纸牌均分问题” ？</h5><p>环形区间的问题，第一想到的就是<strong>破环成链</strong>了</p><p>经过思考发现，一定存在一个最优解方案，环上有相邻的两个人之间没有发生交换</p><blockquote><p>这部分证明如下：如果环上相邻两人全部发生交换，则会出现两种情形：（正数传递为有向边的正向方向）</p><ol><li class="lvl-3">出现一个环这种方案肯定不是最优解，因为给出去的纸牌经过一圈收回来了，显然浪费了操作次数我们在这个环上断开交易数量最小的一条交换边，并使其他边减少该边的交换数量，必然不会使方案变差</li><li class="lvl-3">出现一个点到达另一个点有两条路径我们可以断开起点两条出边中 val=cnt×wval=cnt×w 最小的那一套边，并该边权值累加到另一条路径的每一条边上，其结果不会变差（其中 cntcnt 是起点到终点路径上经过的点数，ww 是这条边的权重）</li></ol></blockquote><p>一个朴素的做法是直接枚举断点的位置，然后做一遍线性纸牌均分，但是时间复杂度为 O(n^2) 不可取，需要推导</p><p>考虑在第k个人之后断开，则环化成链有：第 k+1 个人向第 k+2 个人传递 $c_k−T/M = A_{k + 1}= S_{k+1} - S_k$数量的牌（正数是给，负数是拿）</p><p>第 k+2 个人向第 k+3 个人传递 $c_{k+1}−T/M + c_k−T/M = A_{k+1} + A_k = S_{k+2} -S_k$数量的牌<br>…</p><p>第n个人向第1个人传递 $∑^{n}_{i=k+1}c_i−(n-k)×T/M = S_n - S_k$数量的牌</p><p>第1个人向第2个人传递 $∑^{n}_{i=k+1}c_i−(n-k+1)×T/M = S_1 +  S_n - S_k $数量的牌</p><p>第k-1个人向第k个人传递 $∑^{n}<em>{i=k+1}c_i−(n-1)×T/M = S</em>{k-1} + S_n - S_k $数量的牌</p><p>又易知 $S_n=∑cj−n×\frac{T}{M}=0$，故求得最小步数为：</p><p>$$<br>∑_{i=1}^n|S_i−S_k|，其中 S_i 为 A_i 的前缀和，即 S_i=∑_{j=1}^iA_j<br>$$<br>该绝对值不等式最小值的求解，就同 “货仓选址” 异曲同工了</p><p>因此 $S_k$ 的选择，就取 $S_i$排序后的中位数即可</p><p><strong>考虑 “纸牌均分问题” 如何解决？</strong></p><p>设一共有 $M$ 个人，每个人初始的纸牌数量为 $c_i$，纸牌总数为 $T$</p><p>显然当 $M \nmid T$ 时，方案不存在，现只考虑方案存在的情况</p><p>第 1 个人为了达到平均持有数，需要向第 2 个人传递 $c_1 - T / M$ 数量的牌（正数是给，负数是拿）</p><p>第 2 个人为了达到平均持有数，需要向第 3 个人传递 $c_2 - T / M + c_1 - T / M$ 数量的牌</p><p>…</p><p>第 n-1 个人为了达到平均持有数，需要向第 n 个人传递 $\sum_{i=1}^{n-1} c_i - (n-1) \times T / M$ 数量的牌</p><p>此时前 n-1 人都达到了平均数，则第 n 个人必然也达到了平均数</p><p>统计易得，最小交换次数为：</p><p>$$<br>\sum_{i=1}^{n-1} \Big| { \sum_{j = 1}^i (c_j - \frac{T}{M}) } \Big|<br>$$</p><p>不妨设 $A_i = c_i - T / M$，于是化简可得：</p><p>$$<br>\sum_{i=1}^{n-1} \Big| { \sum_{j=1}^i A_j } \Big| =<br>\sum_{i=1}^{n-1} | { S_i } | \quad\text{其中 } S_i \text{ 为 } A_i \text{ 的前缀和，即 } S_i = \sum_{j=1}^i A_j<br>$$</p><p><strong>考虑 “纸牌均分问题” 如何延伸到 “环形纸牌均分问题” ？</strong></p><p>环形区间的问题，第一想到的就是 <strong>破环成链</strong> 了</p><p>经过思考发现，一定存在一个最优解方案，环上有相邻的两个人之间没有发生交换</p><p>这部分证明如下：如果环上相邻两人全部发生交换，则会出现两种情形：（正数传递为有向边的正向方向）</p><ol><li class="lvl-3"><p>出现一个环这种方案肯定不是最优解，因为给出去的纸牌经过一圈收回来了，显然浪费了操作次数我们在这个环上断开交易数量最小的一条交换边，并使其他边减少该边的交换数量，必然不会使方案变差</p></li><li class="lvl-3"><p>出现一个点到达另一个点有两条路径我们可以断开起点两条出边中 $val = cnt \times w$ 最小的那一套边，并该边权值累加到另一条路径的每一条边上，其结果不会变差（其中 $cnt$ 是起点到终点路径上经过的点数，$w$ 是这条边的权重）</p></li></ol><p>一个朴素的做法是直接枚举断点的位置，然后做一遍线性纸牌均分，但是时间复杂度为 $O(n^2)$ 不可取，需要推导</p><p>现将这 $n$ 个人的 $A_i$ 和 $S_i$ 罗列出来 $(A_i = \sum\limits_{j=1}^n (c_j - \dfrac{T}{M}), S_i = \sum\limits_{j = 1}^i A_j)$</p><p>$$<br>\begin{matrix}<br>A_1 &amp; S_1 \\<br>A_2 &amp; S_2 \\<br>\cdots &amp; \cdots \\<br>A_k &amp; S_k \\<br>A_{k+1} &amp; S_{k+1} \\<br>\cdots &amp; \cdots \\<br>A_n &amp; S_n<br>\end{matrix}<br>$$</p><p>考虑在第 $k$ 个人之后断开，则环化成链有：</p><p>$$<br>\begin{matrix}<br>A_{k+1} &amp; S_{k+1} - S_k \\<br>\cdots &amp; \cdots \\<br>A_n &amp; S_n - S_k \\<br>A_1 &amp; S_1 + S_n - S_k \\<br>A_2 &amp; S_2 + S_n - S_k \\<br>\cdots &amp; \cdots \\<br>A_k &amp; S_k + S_n - S_k \\<br>\end{matrix}<br>$$</p><p>又易知 $S_n = \sum c_j - n \times T / m = 0$，故求得最小步数为：</p><p>$$<br>\sum_{i=1}^n |S_i - S_k| \quad\text{其中 } S_i \text{ 为 } A_i \text{ 的前缀和，即 } S_i = \sum_{j=1}^i A_j<br>$$</p><p>该绝对值不等式最小值的求解，就同上一题 “货仓选址” 异曲同工了</p><p>因此 $S_k$ 的选择，就取 $S_i$ 排序后的中位数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——前缀和/推公式——AcWing 122. 糖果传递</span></span><br><span class="line"><span class="comment">// 贪心策略：首先破环成链，以k和k+1之间为破链处，然后从k+1开始左往右开始传递使每一个符合要求（等于平均值），符合要求则不传递</span></span><br><span class="line"><span class="comment">// 前缀和传递前为s[i] - s[k]，传递后为s&#x27;[i] = ave * i ，传递量为s[i] - s[k] - ave * i</span></span><br><span class="line"><span class="comment">// 只有s[k]为变量，可利用“货仓选址”的思路求出</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line">LL s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i<span class="number">-1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    LL ave = s[n] / n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] -= ave * i; </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 货仓选址：贪心、中位数</span></span><br><span class="line">    <span class="built_in">sort</span>(s + <span class="number">1</span>, s + n + <span class="number">1</span>);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        res += <span class="built_in">abs</span>(s[i] - s[(n+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 求出传递量</span></span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二：推公式">思路二：推公式</h4><p>首先利用每个人最终都得到相同个数得糖果可以列出n个方程。然后再解线性方程组推导出结论公式，再转化为“货仓选址”问题。</p><p>不妨设每个人i向前一个传递的糖果数为$x_i$，则目标是求：<br>$$<br>Min = min\sum\limits_{i=1}^nx_i<br>$$</p><p>研究方程组可以发现一共有n-1个独立方程和n个未知数，因而可以用一个未知数$x_k$表示剩余的所有未知数。</p><p>整理可得：<br>$$<br>Min = min\sum\limits_{i=1}^n|x_1 - c_i|<br>$$</p><p>$$<br>c_n = avg - a_n，c_{i-1} = c_i + avg - a_{i-1}，c[1] = 0<br>$$</p><p><strong>第二种推导方式</strong></p><p>这种推导方式相较于上一种，思维量小，但对公式的变形要求高，是直接统计每个点</p><p>考虑直接在环上求解，环的顺时针方向设为正方向，若边权为正，表示左向右传递；反之则是右向左传递</p><p>设 $d_i$ 表示第 $i$ 个人向第 $(i+1)\bmod n$ 传递的所有纸牌数量</p><p>传递完成后的结束是所有人的纸牌数量变成平均数，以此建立方程组有：<br>$$<br>\begin{cases}<br>avg =&amp; c_1 - d_1 + d_n \\<br>avg =&amp; c_2 - d_2 + d_1 \\<br>\cdots \\<br>avg =&amp; c_{n-1} - d_{n-1} + d_{n-2} \\<br>avg =&amp; c_{n} - d_{n} + d_{n-1}<br>\end{cases}<br>\qquad \Rightarrow \qquad<br>\begin{cases}<br>d_1 &amp;= c_1 - avg + d_n \\<br>d_2 &amp;= c_2 - avg + d_1 \\<br>\cdots \\<br>d_{n-1} &amp;= c_{n-1} - avg + d_{n-2} \\<br>d_n &amp;= c_{n} - avg + d_{n-1}<br>\end{cases}<br>$$<br>观察易得，相邻两个等式之间，有可以代入的项，从上到下用滚动相消法可得：<br>$$<br>\begin{cases}<br>d_1 =&amp; c_1 - avg + d_n \\<br>d_2 =&amp; \sum\limits_{i=1}^2 c_i - 2 \times avg + d_n \\<br>\cdots \\<br>d_{n-1} =&amp; \sum\limits_{i=1}^{n-1} c_i - (n-1) \times avg + d_n \\<br>d_n =&amp; \sum\limits_{i=1}^{n} c_i - n \times avg + d_n<br>\end{cases}<br>$$<br>易得通项：$d_i = \sum\limits_{j=1}^{i} c_j - i \times avg + d_n = d_n + \sum\limits_{j=1}^{i} (c_j - avg) = d_n - \sum\limits_{j=1}^{i} (avg - c_j)$</p><p>不妨设 $A_i = avg - c_i, S_i = \sum\limits_{j = 1}^i A_j$，则通项可以化简为：$d_i = d_n - \sum\limits_{j=1}^{i}A_j$</p><p>则总共的操作数为：</p><p>$$<br>\sum_{i=1}^n d_i = \sum_{i=1}^n |d_n - \sum_{j=1}^i A_j| =<br>\sum_{i=1}^n |d_n - S_i|<br>$$</p><p>由 <strong>绝对值不等式</strong> 易得：$d_n$ 应取 $S_i$ 排序后的中位数</p><p><img src="https://mdpic.dreamgo.fun/img/F4178CB81B40AE8072F7F6339F541970.png" alt="F4178CB81B40AE8072F7F6339F541970"></p><p><img src="https://mdpic.dreamgo.fun/img/FFD8060DA5743944EBE8295FFB828C42.png" alt="FFD8060DA5743944EBE8295FFB828C42"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    LL avg = sum / n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n ; i &gt; <span class="number">1</span>; -- i)</span><br><span class="line">        c[i] = c[i + <span class="number">1</span>] + avg - a[i];</span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res += <span class="built_in">abs</span>(c[i] - c[(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-AcWing-1235-付账问题">5. <a href="https://www.acwing.com/activity/content/code/add/1767/">AcWing 1235. 付账问题</a></h3><p>本题利用了数学知识，但不要深陷入数学推导。贪心题首先还是先试试一些直觉性的局部最优策略。</p><p>本题的目标是使每个所付钱数的偏差最小，显然如果每个人带的钱数都足够，则均分最好。这利用均值不等式可证。</p><p>不同于均分问题，一旦有人带的钱数不够，就要求其他人多出钱。一种直觉性的想法时，钱不够的人肯定要把所有钱都交出，不够的钱数为了使偏差小，应由其他人均摊。</p><p>这就是我们的贪心策略。</p><p>可以发现本题不同于均分问题的一点使每个人最好按照均值支出，但均值使在变化的，一旦出现有人钱不够，其他人支出的总数就会增大，均值也相应变大。因而如果是支出顺序是无序的，支出的标准（均值）也就无法确定。</p><p>考虑到钱不够的人的支出是确定的，且所有钱不够的人算过后，其余人的支出标准也就可确定了。由此我们要进行按照钱数大小从小到大对每个人排序， 从最小的开始处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——推公式——AcWing 1235. 付账问题</span></span><br><span class="line"><span class="comment">// 均值不等式 + 排序</span></span><br><span class="line"><span class="comment">// 贪心策略：1.按照钱数大小从小到大对每个人排序， 从最小的开始处理</span></span><br><span class="line"><span class="comment">// 2. 钱不够的人肯定要支出所有钱，不够的钱数由其他人均摊</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> LD;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    LD s = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(p, p + n);</span><br><span class="line">    LD avg = s / n, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        LD cur = s / (n - i); <span class="comment">// 更新选择标准：剩余每人需均摊的钱</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] &lt; cur) cur = p[i]; </span><br><span class="line">        <span class="comment">// 分类处理：钱不够指出所有，钱够支出当前所需的均摊的钱</span></span><br><span class="line">        res += (cur - avg) * (cur - avg);</span><br><span class="line">        s -= cur; <span class="comment">// 更新剩余人需均摊的总钱数</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%.4Lf\n&quot;</span>, <span class="built_in">sqrt</span>(res / n));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-AcWing-1239-乘积最大">6. <a href="https://www.acwing.com/problem/content/1241/">AcWing 1239. 乘积最大</a></h3><p>本题直观的策略很简单：若为正数则尽量大，负数则尽量小。</p><p>首先n个数中取n个则不用优化。</p><p>当n个数中取k个（k&lt;n)时</p><p>为了使正数尽量大，偶数项则依次取两项负数或两项正数的乘积中最大的，奇数项则先取最大的正数项（注意不是最后处理最后一项，先处理才能保证两项乘积取得都是最大的。</p><p>成为负数只有一种可能，就是全为负数且k为奇数，显然先取最大的一个，然后依次取两项乘项最小的一对</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——排序 + 分类讨论——AcWing 1239. 乘积最大</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>, res = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        res = a[r --]; </span><br><span class="line">        k--;</span><br><span class="line">        <span class="comment">// 奇数项时一定先取最大的一项</span></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) sign = <span class="number">-1</span>; </span><br><span class="line">        <span class="comment">// 序列中全为负数且要取的个数为奇数时，结果才为负数</span></span><br><span class="line">        <span class="comment">// 此时依次取最小的两项乘积，通过引入辅助变量sign=-1更方便统一代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        LL x = (LL)a[l] * a[l+<span class="number">1</span>], y = (LL)a[r - <span class="number">1</span>] * a[r];</span><br><span class="line">        <span class="comment">// 排序后最大乘积项一定在两端（全为负数时最小乘积项在右端）</span></span><br><span class="line">        <span class="keyword">if</span> (x * sign &gt; y * sign)&#123; <span class="comment">// 选择标准：大小</span></span><br><span class="line">            res = x % mod * res % mod;</span><br><span class="line">            l += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res = y % mod * res % mod;</span><br><span class="line">            r -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-AcWing-1247-后缀表达式">7. <a href="https://www.acwing.com/activity/content/problem/content/1769/">AcWing 1247. 后缀表达式</a></h3><p>本题最关键依旧是理解题目中隐含的关键性质。</p><p>为什么题目要凑出的是后缀表达式而不是中缀表达式？两者有什么最关键不同？</p><p>可以发现，后缀表达式可通过其中数字和符号的顺序来直接表示运算顺序而不需要借助括号，这在中缀时不行。</p><p>换句话说，后缀表达式等价于中缀式可以任意规定运算顺序（任意加括号）。</p><p>而这意味什么呢？我们需要进一步研究在只有加减运算时括号所起的作用。</p><p>可以发现，减号和括号得组合作用可以使得去掉括号后括号内加号变减号，减号变加号。由于括号是任意加的，不难可以想到，无论题目给出多少加号，只要存在至少一个减号，我们就能将任意数量的加号变成减号，减号数量可以为1<sub>N+M中的任意个（对应于加号数量可以为0</sub>N+M-1中任意个）。</p><p>由此，最优的求解策略就是加上所有正数，减去所有负数。</p><p>注意边界情况，第一个数前无运算负，相当于一定加上第一个数，同时只要减号不为零，一定至少有一个减号。换句话说，m == 0时直接相加输出；m != 0时，一定要至少加上一个数，减去一个数，其贪心策略是先加上最大的数和减去最小的数，其余的数加上其绝对值。</p><p>再次总体说明一下，本题揭示出我们既不能局限于题目原有的概念和表述，也必须充分挖掘其中的关键性质。本题中我们不要用后缀式去直接求解，而是用中缀式，因为后者更方便思考和求解问题。但是这并不意味着我们忽视后缀式及其具有的性质，恰恰想法其具有的性质是解题的关键。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——分类讨论——AcWing 1247. 后缀表达式</span></span><br><span class="line"><span class="comment">// 贪心策略：</span></span><br><span class="line"><span class="comment">// M == 0时直接相加输出；</span></span><br><span class="line"><span class="comment">// M != 0时，先加上最大的数和减去最小的数，其余的数加上其绝对值。</span></span><br><span class="line"><span class="comment">// 注意要能挖掘到题目的性质：</span></span><br><span class="line"><span class="comment">// 只要存在至少一个减号，我们就能将任意数量的加号变成减号，</span></span><br><span class="line"><span class="comment">// M != 0 时，减号数量可以为1~N+M中的任意个，且至少有一个加号和减号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>; </span><br><span class="line"><span class="comment">// 注意数据范围： n &lt;= 10^5 , m &lt;= 10^5 </span></span><br><span class="line"><span class="comment">// 则n + m + 1 &lt;= 2 * 10 ^5 + 1 不要写错了!!</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> k = n + m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; k; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按减号个数分类讨论</span></span><br><span class="line">    <span class="keyword">if</span> (!m)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">            res += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + k); <span class="comment">// 找到最大值和最小值</span></span><br><span class="line">        </span><br><span class="line">        res = a[k - <span class="number">1</span>] - a[<span class="number">0</span>]; </span><br><span class="line">        <span class="comment">// m != 0时至少加上一个数、减去一个数，选最大和最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k - <span class="number">1</span>; ++ i)</span><br><span class="line">            res += <span class="built_in">abs</span>(a[i]);</span><br><span class="line">            <span class="comment">// 其余直接加上绝对值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="峰谷类">峰谷类</h2><h3 id="1-AcWing-1055-股票买卖-II">1. <a href="https://www.acwing.com/activity/content/problem/content/1763/">AcWing 1055. 股票买卖 II</a></h3><p>本题我最初做时费了很长时间都没有想到正确思路，究其原因还是做题的方法不对。</p><p>首先本题题目说明并不是非常清楚，导致我没有正确理解题意，误认为每一天只能有一次操作（不能当天买卖或卖买），然而题目的只要求在再次购买前出售掉之前的股票，一天内是可以多次操作的。这反映了我在做题时不认真理解，容易乱加约束或少约束的问题。</p><p>由于没有正确理解题意，我自然没有发现本题的一个最关键的性质：<strong>任何一个跨度大于一的交易都等价于连续跨度为一的多次交易之和</strong>（即拆分成连续当天买第二天卖的交易）。由于这个性质，我们就只需关注跨度为一的交易，只要收益为正就可以进行。进行完所有跨度为一的交易，我们即可得到最优解。</p><p>发现这种性质的关键是要去思考任意一笔交易能不能进行转化，表示成更小的交易之和（分解成子问题的思想）。</p><p>我在分析时没有挖掘题目隐含的性质，而是深陷入对各种复杂约束条件的人为分析中，这并不符合贪心应用简单局部最优策略进行迭代优化的特性。</p><p>同时我在思考时受前面做题的影响，过多的局限于排序的策略，并陷入对全局问题的思考，而忽视了对父问题和子问题的迭代关系的思考。盲目试图进行数学推导也是一大问题。</p><p>我在思考时，一直局限于思考如何选择买入的时间点和卖出的时间点、买卖的次数应该是多少，这些量显然是无法直接求出的同时也不应该去直接求，我们不应该纠结于如何用数学推导出这些量。贪心的思想恰在于用最简单的局部最优策略去建立一个简单的选择标准，然后迭代地求解而不是直接求解。既然买入卖出的时间点、买卖的次数这些量不确定性太高，不好求，我们就应该思考如何将它们转化，规避直接求解。</p><p>另一种想法就是直接去猜想一个最简单粗暴、短视的策略，并证明其可行性。同时可以思考我们方便进行的操作和便于确定的标准是什么，能不能用起来表示问题量。</p><p>交易次数可以任意，并不是为了让我们自己确定次数，而是因为此时具有特殊的性质。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230328100556635.png" alt="image-20230328100556635"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心——峰谷类——AcWing 1055. 股票买卖 II</span></span><br><span class="line"><span class="comment">// 贪心策略：</span></span><br><span class="line"><span class="comment">// 利用任何一个跨度大于一的交易都等价于连续跨度为一的多次交易之和这一性质将交易分解表示</span></span><br><span class="line"><span class="comment">// 对所有收入为正的跨度为一的交易求和</span></span><br><span class="line"><span class="comment">// 分解转化问题，转化为相邻项比较的问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;s[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> dt =  s[i+<span class="number">1</span>] - s[i];</span><br><span class="line">        <span class="keyword">if</span> (dt &gt; <span class="number">0</span>) res += dt;</span><br><span class="line">        <span class="comment">// 对所有收入为正的跨度为一的交易求和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分类讨论">分类讨论</h3><p>分析出问题的性质很关键</p><h2 id="维护贪心策略的算法或数据结构">维护贪心策略的算法或数据结构</h2><p>排序</p><p>栈</p><p>堆</p><p>平衡树</p><p>双指针</p><p>二分</p><p>链表</p><p>位掩码</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课5 动态规划</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划">动态规划</h1><p>动态规划先化零为整，再化整为零。</p><p>化零为整即将不同的方案归到一类去，用一个状态来表示</p><p>化整为零即将每一个状态分割成若干个字迹再分别来求</p><p>DP能解的前提是为拓扑图不存在环</p><p>DP是特殊的最短路问题，是没有环的最短路entire</p><h2 id="背包问题模型">背包问题模型</h2><p>每件物品i重量为$w_1$,价值为$v_i$，背包至多能装W重量的物体，问如何选择物品获得的价值最大。</p><p>背包问题解决的问题大致都是：从某些物品里，在某种限制下，选择一部分物品，使目标值最大。</p><p>背包问题是选择问题或组合问题的一种</p><p><strong>DP问题的优化都是对状态转移方程/代码的等价变形</strong></p><h3 id="1-AcWing-2-01背包问题">1. <a href="https://www.acwing.com/problem/content/description/2/">AcWing 2. 01背包问题 </a></h3><p>每件物品最多只用一次</p><p><img src="https://mdpic.dreamgo.fun/img/71015FA210F785ABDAB0E6E8C6543B60-1679975268081-5.png" alt="71015FA210F785ABDAB0E6E8C6543B60"></p><h4 id="C">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 2. 01背包问题  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// 状态表示，属性为MAX</span></span><br><span class="line"><span class="comment">// 隐含了初始化，没有物品的时候，背包的价值永远是0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件：f[0][0~n] = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            <span class="comment">// 不选择当前物品，则价值等于前i-1个物品在同容量下的MAX</span></span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">// 如果j没有v[i]大，则说明装不下第i件物品，那么含i的集合就是空集</span></span><br><span class="line">            <span class="comment">// 选择当前物品，前提是j &gt;= v[i]，则价值等于前i-1个物品在同j-v[i]容量下的MAX加上第i个物品价值</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f</span><br><span class="line">            [i<span class="number">-1</span>][j-v[i]] + w[i]);<span class="comment">// 递推式</span></span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 2. 01背包问题  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">1010</span></span><br><span class="line">    v = [<span class="number">0</span>] * N</span><br><span class="line">    w = [<span class="number">0</span>] * N</span><br><span class="line">    f = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="comment"># 状态表示，属性为MAX</span></span><br><span class="line">    <span class="comment"># 隐含了初始化，没有物品的时候，背包的价值永远是0</span></span><br><span class="line">    </span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        v[i], w[i] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 不选择当前物品，则价值等于前i-1个物品在同容量下的MAX</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="comment"># 如果j没有v[i]大，则说明装不下第i件物品，那么含i的集合就是空集</span></span><br><span class="line">            <span class="comment"># 选择当前物品，前提是j &gt;= v[i]，则价值等于前i-1个物品在同j-v[i]容量下的MAX加上第i个物品价值</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[i]:</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i])</span><br><span class="line">    <span class="built_in">print</span>(f[n][m])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>优化——滚动数组：使用的两个前提条件：</p><ul class="lvl-0"><li class="lvl-2"><p>状态<code>f(i, j)</code>只与<code>f(i-1, ...)</code>有关，只与<code>x</code>坐标上一层有关</p></li><li class="lvl-2"><p>$f(i - 1, j)与f(i - 1, j - v_1)$ y坐标都小于等于<code>j,</code>都在<code>f(i, j)</code>的同一侧</p></li></ul><p><strong>DP问题的优化都是对状态转移方程/代码的等价变形</strong><br>可以发现<code>f[i][j] = max(f[i][j],f[i - 1][j - volumn[i]] + weight[i])</code>只用到了<code>i-1</code>层的信息，因此可以用滚动数组来进行优化</p><p>滚动数组简介滚动数组是DP中的一种编程思想。简单的理解就是让数组滚动起来，每次都使用固定的几个存储空间，来达到压缩，节省存储空间的作用。起到优化空间，主要应用在递推或动态规划中（如01背包问题）。因为DP题目是一个自底向上的扩展过程，我们常常需要用到的是连续的解，前面的解往往可以舍去。所以用滚动数组优化是很有效的。利用滚动数组的话在N很大的情况下可以达到压缩存储的作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01背包问题——DP + 滚动数组优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 滚动数组降维</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件：f[0~n] = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="comment">// 注意j必须从大到小，从而保证用到的是第i-1层的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;=v[i] ; -- j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-AcWing-3-完全背包问题">2. <a href="https://www.acwing.com/problem/content/3/">AcWing 3. 完全背包问题  </a></h3><p>每件物品有无限个</p><p>朴素的DP就是暴力+递归存储。先不用考虑优化问题，对于每一个不确定的选择维度，就都开一重循环进行枚举即可。</p><p>状态表示的维度和循环的重数不一定相同。对于复杂问题，往往需要<strong>在集合划分时也使用一重循环</strong>。此时先不要考虑优化问题，先上暴力枚举即可。而优化时只需<strong>对状态转移方程等价变形，用前面的状态替换方程的某些部分</strong>。</p><p>集合划分时需要枚举每个物品选几个。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230325122140072.png" alt="image-20230325122140072"></p><h4 id="朴素算法">朴素算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 3. 完全背包问题   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: f[0][0~n] = 0  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; ++ k)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="python-2">python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 3. 完全背包问题   </span></span><br></pre></td></tr></table></figure><h4 id="对状态方程进行变形化简">对状态方程进行变形化简</h4><p>这种变形化简实际上反映了利用两次递推关系。在集合划分时，由于我们思维能力的局限性，我们只沿着第一维i来寻找递推关系并推导，但对于有些复杂问题，我们要沿着第一维i和第二维j都寻找递推关系才能充分化简递推式。</p><p>这就需要我们在由第一维i推导出的递推式基础上，继续寻找沿着第二维j上的递推关系并对现有递推式进行化简。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 3. 完全背包问题   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: f[0][0~n] = 0  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="python-3">python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 3. 完全背包问题   </span></span><br></pre></td></tr></table></figure><h4 id="使用滚动数组优化">使用滚动数组优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: f[0][0~n] = 0  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m ; ++ j) <span class="comment">// 注意j必须从小到大，从而保证用到的是第i层的信息</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="python-4">python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 3. 完全背包问题   </span></span><br></pre></td></tr></table></figure><h2 id="3-AcWing-4-多重背包问题">3. <a href="https://www.acwing.com/problem/content/4/">AcWing 4. 多重背包问题</a></h2><p>多重背包问题每件物品i有$s_i$个</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230325121902131.png" alt="image-20230325121902131"></p><p>注意区分多重背包和完全背包的不同：此处注意，直接借用完全背包的模板是不行的，因为物品数目是有限个，而非完全背包的无限个，在背包空间足够大时，递推会出现错误，因为会多出一项 $dp[i−1][j−(s_i+1)v_i]+s_iw_i$，这一项不能直接利用递推的性质得到 $dp[i−1][j−(s_i+1)v_i]+(s_i+1)w_i$，因为物品$i$最多也才$s_i$件，不可能取到$s_i+1$件，所以不能直接借用完全背包的模板来优化；</p><h3 id="朴素算法-2">朴素算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多重背包问题朴素算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件：f[0][0~n] = 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; ++ k)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-AcWing-5-多重背包问题-II">4. <a href="https://www.acwing.com/problem/content/5/">AcWing 5. 多重背包问题 II</a></h2><p>使用二进制优化方法</p><p>枚举优化：<strong>二进制打包枚举</strong></p><p>利用二进制优化方法，可以将多重背包问题转化为01背包问题</p><p>使用$1,2,4,\cdots,2<sup>k$这几个数的组合可以表示出$0$到$2</sup>{k+1} - 1$中的每一个数，注意每个数$2^i$最多只会被选1次。</p><p>对于任意一个数S，选取最大的k(满足$1+2+4+…+2^k = 2^{k+1} - 1 &lt; S, 1+2+4+…+2^{k+1} = 2^{k+2} - 1&gt;S$)，<br>$c = s - (2^{k+1} - 1)$，则:$$0-S中的所有数都可以用1,2,4,…,2^k,c的组合表示出来。$$<br>注意因为c&lt;2^{k+1}, c和2^{k+1} - 1间无漏缺。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制优化法处理多重背包问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 二进制优化，转换为01背包问题</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * k, w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * s, w[cnt] = b * s;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件：f[0~cnt] = 0</span></span><br><span class="line">    <span class="comment">// 01背包问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; -- j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-AcWing-9-分组背包问题">5. <a href="https://www.acwing.com/problem/content/9/">AcWing 9. 分组背包问题 </a></h2><p>分组背包问题物品分为多个组，每组有多种类别物品</p><p>关键在于理解之前的背包问题以每件物品作为i，而分组问题以每组作为i，每组里再讨论选那个物品哪个物品</p><p>同样注意，对于复杂问题，往往需要<strong>在集合划分时也使用一重循环</strong>。</p><p>分组背包中集合划分时需要枚举每组中选哪一个物品（包含一个也不选）。</p><p>类似完全背包问题的朴素算法</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230325121719809.png" alt="image-20230325121719809"></p><h3 id="朴素算法-3">朴素算法</h3><p>类似完全背包问题的朴素算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分组背包问题朴素算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; ++ j)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j]; <span class="comment">// 先要等于不选本组的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; ++ k)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt;= j) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-v[i][k]] + w[i][k]);</span><br><span class="line">                <span class="comment">// 注意这里f[i][j]不能用f[i-1][j]替换，因为考虑到每组里要进行比较</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="滚动数组优化">滚动数组优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; ++ j)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt;= j) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-v[i][k]] + w[i][k]);</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性DP">线性DP</h2><p>递推式具有明显的线性关系。线性DP一般从前往后推，状态表示和集合划分都会将前<code>i</code>个数视为整体</p><h3 id="1-AcWing-898-数字三角形">1. <a href="https://www.acwing.com/problem/content/900/">AcWing 898. 数字三角形 </a></h3><p><img src="https://mdpic.dreamgo.fun/img/image-20230325171911856.png" alt="image-20230325171911856"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 898. 数字三角形</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 当递推式含有i-1,j-1时存储从1开始，方便应对边界0的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; ++ j)</span><br><span class="line">            f[i][j] = -INF; <span class="comment">// 注意为了应对越界问题，要先赋值为极小值</span></span><br><span class="line">            <span class="comment">// 注意j从0到i+1，而不是1到j——边界的越界问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意边界条件</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="优化1——滚动数组">优化1——滚动数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 898. 数字三角形</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 当递推式含有i-1,j-1时存储从1开始，方便应对边界0的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">            f[i] = -INF; <span class="comment">// 注意为了应对越界问题，要先赋值为极小值</span></span><br><span class="line">            <span class="comment">// 注意j从0到i+1，而不是1到j——边界的越界问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    f[<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">1</span>; -- j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j<span class="number">-1</span>],f[j]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="优化2——直接在存储数据的数组存储结果">优化2——直接在存储数据的数组存储结果</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 898. 数字三角形</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 当递推式含有i-1,j-1时存储从1开始，方便应对边界0的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        a[i][<span class="number">0</span>] = -INF;</span><br><span class="line">        a[i][i+<span class="number">1</span>] = -INF;</span><br><span class="line">    &#125;         <span class="comment">// 注意为了应对越界问题，要先赋值为极小值</span></span><br><span class="line">            <span class="comment">// 注意j从0到i+1，而不是1到j——边界的越界问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">1</span>; -- j)</span><br><span class="line">            a[i][j] = <span class="built_in">max</span>(a[i<span class="number">-1</span>][j<span class="number">-1</span>],a[i<span class="number">-1</span>][j]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res = <span class="built_in">max</span>(res, a[n][i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-895-最长上升子序列">2. <a href="https://www.acwing.com/problem/content/897/">AcWing 895. 最长上升子序列</a></h3><p>状态为1维。</p><p>这里一个难点是集合的定义。集合的定义要满足递推包含性，方便进行递推。集合递推所用到的额外信息往往借助状态的维度进行查找，这也影响集合的定义。核心在于想清楚序列是怎么递推地一步步构成的，需要判断哪些条件。</p><p>集合定义时一定要满足递推包含性。首先，序列的构成显然具有递推性，即一个个数字往结尾加。而本题要判断字符能否加在一个序列最后构成上升子序列，关键要判断当前数字是否大于序列结尾字符。为此，为了进行递推，集合在定义时就必须能方便的表示出序列结尾的数字信息，即结尾数字的位置最好和维度相绑定。因此集合表示所有以第<code>i</code>个数结尾的上升子序列，而不是前<code>i</code>个数构成所有上升子序列的集合。</p><p>本题的集合划分也需注意。DP的核心思路是暴力+递推存储，对于复杂问题，往往需要<strong>在集合划分时也使用循环</strong>。本题中既然序列的递推关系由最后一个数表示和决定，划分时我们同样也可以讨论序列最后一个数的位置，这即对应于状态f。最特殊的情况是序列长度为0，其次可以遍历<code>i</code>前面的状态，取MAX。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230325172802737.png" alt="image-20230325172802737"></p><h4 id="朴素算法-4">朴素算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长上升子序列朴素算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件 f[i] &gt;=  1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        f[i] = <span class="number">1</span>; <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>) ;</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出状态">输出状态</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], f[N], g[N];</span><br><span class="line"><span class="comment">// g[N]用于记录状态转移的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        g[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])</span><br><span class="line">                <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>)&#123;</span><br><span class="line">                    f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">                    g[i] = j; <span class="comment">// 记录状态转移</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (f[k] &lt; f[i])</span><br><span class="line">            k = i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[k]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s[N], len = f[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)&#123;</span><br><span class="line">        s[i] = a[k];</span><br><span class="line">        k = g[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">        cout &lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-AcWing-896-最长上升子序列-II">3. <a href="https://www.acwing.com/problem/content/898/">AcWing 896. 最长上升子序列 II</a></h3><p>贪心加构造单调二分$O(nlogn)$</p><p>使用DP进行求解时会有冗余——会有多个长度相同的上升子串，针对问题所需求解的最长长度来说，不用考虑子串的内容是无所谓的，因此冗余。同时，对于这些长度相同的上升子串，应用贪心的思想，会有一个最优的子串——终端值最小的子串是最优子串，能插在其他等长串的数也一定能插在其后面。因此只用存每个长度的子串集合中的最优子串即可。</p><p>为此，对前面所有子串进行分类，使用一个数组维护前面每个长度下所有子串的最小的终端值。数组 <code>q[i]</code>表示长度为<code>i</code>的最长上升子序列的末尾元素的最小值。这里一定要把维护数组的含义理解好。</p><p>在这一前提下，我们发现一个重要性质——该维护数组一定是严格单调递增的。</p><p>可以使用反证法证明。证明数组<code>q</code>具有单调性，即证明<code>i &lt; j</code>时，<code>q[i] &lt; q[j]</code>。假设存在<code>k&lt;j</code>时，<code>q[k] &gt; q[j]</code>，但在长度为<code>j</code>，末尾元素为<code>q[j]</code>的子序列A中，将后<code>j-i</code>个元素减掉，可以得到一个长度为<code>i</code>的子序列B，其末尾元素$t$必然小于<code>q[j]</code>（因为在子序列A中，<code>t</code>的位置上在<code>q[j]</code>的后面），而我们假设数组d必须符合<code>表示长度为 i 的最长上升子序列的末尾元素的最小值</code>，此时长度为<code>i</code>的子序列的末尾元素<code>t &lt; q[j] &lt; q[k]</code>，即<code>t &lt; d[k]</code>，所以<code>q[k]</code>不是最小的，与题设相矛盾，因此可以证明其单调性。</p><p>由此，我们只需要遍历所有字母，对于每个字母在维护数组中查找小于当前数的最大数，位置为<code>r</code>，表示该字母可以插入的最长上升子串长度为<code>r</code>，并用其替换后一个位置的数，表示插入后子串长度为<code>r+1</code>且恰为相同长度中终端值最小的子串。同时更新维护数组长度也是最长子串长度<code>len</code>。</p><p>找到一个最大的小于当前数的数可以用 <strong>二分</strong> 来优化，使用<code>l=mid</code>模板</p><ul class="lvl-0"><li class="lvl-4"><p>二分的思路：</p><ul class="lvl-2"><li class="lvl-8">先定义边界，<code>l = 0, r = len</code>, 其中<code>len</code>是<code>q</code>数组的长度</li><li class="lvl-8">然后确定<code>check</code>函数, 可以先找到不等式中<code>c &lt; x ≤ a ≤ b</code>的<code>c</code><ul class="lvl-4"><li class="lvl-12">通过<code>q[r + 1] = a[i]</code>来将<code>x</code>覆盖<code>a</code>的值</li><li class="lvl-12">同时也要考虑<code>算法1</code>的情况<code>1</code>, 需要扩大<code>q</code>数组的长度<ul class="lvl-6"><li class="lvl-16">即<code>r + 1 &gt; len</code>时, 表示<strong>超出</strong>了二分边界，这时就要<code>len ++</code>更新<code>q</code>的长度</li></ul></li></ul></li></ul></li></ul><h4 id="C-2">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 896. 最长上升子序列 II</span></span><br><span class="line"><span class="comment">// 贪心 + 二分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N]; <span class="comment">// q[i]存储当前长度为i的上升字串中的结尾的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>; <span class="comment">// 记录维护数组q的长度，也是当前最长上升子串长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 贪心迭代顺序——按原序遍历串中每个数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="comment">// 二分查找每个候选对象的最优插入位置——插到可以插入的最长子串</span></span><br><span class="line">        <span class="comment">// 注意这里l始终初始为0，这样解决了a[i]小于任何长度大于1的子串结尾导致找不到插入位置的问题</span></span><br><span class="line">        <span class="comment">// q[0]此时相当于哨兵，a[i]一定大于0，对应于至少可以自己构成一个长度为1的子串</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="comment">// 找小于当前数的最大的数</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>); <span class="comment">// 更新最大长度</span></span><br><span class="line">        q[r + <span class="number">1</span>] = a[i]; <span class="comment">// 更新维护数组</span></span><br><span class="line">        <span class="comment">// 注意这里非常巧妙的处理了初始的情况</span></span><br><span class="line">        <span class="comment">// 初始时l = r = 0， 直接将a[0]放入长度为1的子串的结尾维护位置中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 896. 最长上升子序列 II</span></span><br><span class="line"><span class="comment"># 贪心 + 二分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    q = [<span class="number">0</span>] * (n + <span class="number">1</span>) </span><br><span class="line">    <span class="comment"># 注意这里q[i]存储当前长度为i的上升字串中的结尾的最小值</span></span><br><span class="line">    <span class="comment"># 因此从1开始存储，只要开n+1个位置</span></span><br><span class="line">    </span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        l, r = <span class="number">0</span>, length</span><br><span class="line">        <span class="comment"># 注意这里l始终初始为0，这样解决了a[i]小于任何长度大于1的子串结尾导致找不到插入位置的问题</span></span><br><span class="line">        <span class="comment"># q[0]此时相当于哨兵，a[i]一定大于0，对应于至少可以自己构成一个长度为1的子串</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> q[mid] &lt; x: l = mid</span><br><span class="line">            <span class="keyword">else</span>: r = mid - <span class="number">1</span></span><br><span class="line">        length = <span class="built_in">max</span>(length, r + <span class="number">1</span>)</span><br><span class="line">        q[r + <span class="number">1</span>] = x </span><br><span class="line">        <span class="comment"># 注意这里非常巧妙的处理了初始的情况</span></span><br><span class="line">        <span class="comment"># 初始时l = r = 0， 直接将a[0]放入长度为1的子串的结尾维护位置中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(length)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="4-AcWing-897-最长公共子序列">4. <a href="https://www.acwing.com/problem/content/899/">AcWing 897. 最长公共子序列</a></h3><p>本题由于有两个字符串，所以使用二维状态分别表示两个字符串中位置。</p><p>集合定义同样思考公共子序列是如何递推地一步步构成的。只需判断第一个字符串<code>i</code>位置字符和第二个字符串<code>j</code>位置字符是否相同，如果相同就可以加上该字符（所有在<code>i</code>和<code>j</code>前的序列都可以加上)。这只对应一个情况，而集合要对应于多种情况，同时可以发现定义时不需要额外限制条件。所以集合定义为所有在第一个序列前<code>i</code>个字母中出现，且在第二个序列前<code>j</code>个字母中出现的子序列。</p><p>注意本题集合划分比较困难。集合划分时讨论<code>a[i]</code>和<code>b[j]</code>是否包含在子序列中，而易错点时<code>a[i]</code>和<code>b[j]</code>两者相等只对应集合一种情况，只讨论两者大小关系是不够的。<code>a[i]</code>或<code>b[j]</code>还可以与前面任意字符相等，从而被包含，为此需要划分成一下四类：</p><ul class="lvl-0"><li class="lvl-2"><p>所有在第一个序列前<code>i-1</code>个字母中出现，且在第二个序列前<code>j-1</code>个字母中出现的子序列(<code>f[i-1, j-1]</code>)</p></li><li class="lvl-2"><p>所有以第一个序列第<code>i</code>个字母中和第二个序列第<code>j</code>个字母结尾的子序列(<code>a[i] == b[j]</code>时才有，<code>f[i-1, j-1]+1</code>)</p></li><li class="lvl-2"><p>所有以第一个序列第<code>i</code>个字母结尾，且在第二个序列前<code>j-1</code>个字母中出现的子序列</p></li><li class="lvl-2"><p>所有以第二个序列第<code>j</code>个字母结尾， 且在第一个序列前<code>i-1</code>个字母中出现的子序列</p></li></ul><p>显然这需要涉及讨论前面的字母，和状态时不直接对应的。但本题是MAX类，使用包含所需情况集合的状态也是可以来替换表示的。<code>f[i-1, j]</code>表示所有在第一个序列前<code>i-1</code>个字母中出现，且在第二个序列前<code>j</code>个字母中出现的子序列，一定包含了所有以第二个序列第<code>j</code>个字母结尾， 且在第一个序列前<code>i-1</code>个字母中出现的子序列的所有情况，但也包含了不以第二个序列第<code>j</code>个字母结尾的情况。但由于本题是最值问题，不影响问题求解，可替换表示。同理，可以用<code>f[i, j-1]</code>覆盖表示所有以第一个序列第<code>i</code>个字母结尾，且在第二个序列前<code>j-1</code>个字母中出现的子序列的所有情况。</p><p>同时可以发现，<code>f[i-1, j]</code>和<code>f[i, j-1]</code>都覆盖表示了<code>f[i-1, j-1]</code>的情况，因此这种情况不用单列了。</p><p>这里还需要注意，之所以可以用<code>f[i-1, j]</code>和<code>f[i, j-1]</code>进行替换表示，一个很重要的<strong>前提是<code>f[i-1, j]</code>和<code>f[i, j-1]</code>仍都是<code>f[i, j]</code>的子集</strong>，没有超出其表示范围，从而不影响其最值结果。</p><p><strong>若状态$s_{i-1} \subset k \subset  f_i$，则当状态$s_{i-1}$不方便表示时，可以用$ k $替换表示</strong>。</p><p>集合划分时可以重复包含，只要不影响结果就行。而当要求的结果是最值时划分出集合有重复往往时无影响。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230325183652600.png" alt="image-20230325183652600"></p><h4 id="C-3">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长公共子序列朴素算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s %s&quot;</span>, &amp;n, &amp;m, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 易错点：这里数组从第二个位置开始存储</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Python-2">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    a = <span class="string">&quot; &quot;</span> + <span class="built_in">input</span>()</span><br><span class="line">    b = <span class="string">&quot; &quot;</span> + <span class="built_in">input</span>()</span><br><span class="line">    f = [[<span class="number">0</span>] * (m + <span class="number">1</span>)  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="comment"># 注意存储从下标1开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i-<span class="number">1</span>][j], f[i][j-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> a[i] == b[j]:</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(f[n][m])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="4-AcWing-902-最短编辑距离">4. <a href="https://www.acwing.com/problem/content/904/">AcWing 902. 最短编辑距离</a></h3><p>要求是将字符串a变成字符串b，实现的过程显然具有递推性。两个字符串，状态为二维。实现要随维度一步步实现，集合可以定义成所有将<code>a[1~i]</code>变成<code>b[1~j]</code>的操作方式</p><p>集合划分：讨论最后一步的操作，根据三种操作划分</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230325212306766.png" alt="最短编辑距离"></p><p>集合划分的方案虽然容易，但是每种方案如何取很容易错。增操作和删操作都意味着<code>a[i]</code>和<code>b[j]</code>不是对应的，这和两者相不相等没有关系，可能已经和前面的字母已经匹配了。因此这些方案必须要进行对应操作。</p><p>但是插操作则不一样，插操作是将当前位置的数替换后<code>a</code>变成<code>b</code>，这意味着要将<code>a[i]</code>和<code>b[j]</code>匹配，因此当<code>a[i]</code>和<code>b[j]</code>已经相等了，就可直接对应，没必要进行此操作，因此需要先判断。这里注意<code>a[i]</code>和<code>b[j]</code>对应的方案也是必须取方案，只不过当两者已经相等时只用取<code>f[i-1][j-1]</code>，而当两者不等时需要取<code>f[i-1][j-1]+1</code>，区别在加1上。</p><h4 id="C-4">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 902. 最短编辑距离</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d%s&quot;</span>, &amp;n, a + <span class="number">1</span>, &amp;m, b + <span class="number">1</span>); </span><br><span class="line">    <span class="comment">// 注意DP一般从下标1存储，这与状态转移方程越界问题有关</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意初始化——从空串变成长度为i的串至少需要i次操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j] + <span class="number">1</span>, f[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 对于a[i]与b[j]对应的方案，即插操作方案，要讨论是否需要加1</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-3">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 902. 最短编辑距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    a = <span class="string">&quot; &quot;</span> + <span class="built_in">input</span>()</span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    b = <span class="string">&quot; &quot;</span> + <span class="built_in">input</span>()</span><br><span class="line">    f = [[<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        f[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        f[<span class="number">0</span>][i] = i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i-<span class="number">1</span>][j], f[i][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a[i] == b[j]:</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(f[n][m])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="5-AcWing-899-编辑距离">5. <a href="https://www.acwing.com/problem/content/901/">AcWing 899. 编辑距离</a></h3><p>本题相当于求解多个最短编辑距离问题</p><h4 id="C-5">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>, M = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">char</span> str[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">edit_distance</span><span class="params">(<span class="type">char</span> a[], <span class="type">char</span> b[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> la = <span class="built_in">strlen</span>(a + <span class="number">1</span>), lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lb; i ++ ) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= la; i ++ ) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= la; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lb; j ++ )&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[la][lb];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">char</span> s[N];</span><br><span class="line">        <span class="type">int</span> limit;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s + <span class="number">1</span>, &amp;limit);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">edit_distance</span>(str[i], s) &lt;= limit)</span><br><span class="line">                res ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-4">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    s = [<span class="string">&quot; &quot;</span> + <span class="built_in">input</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    f = [[<span class="number">0</span>] * <span class="number">1001</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1001</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        b, l = <span class="built_in">input</span>().split()</span><br><span class="line">        b = <span class="string">&quot; &quot;</span> + b</span><br><span class="line">        l = <span class="built_in">int</span>(l)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> s:</span><br><span class="line">            la = <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">            lb = <span class="built_in">len</span>(b) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(la + <span class="number">1</span>): f[i][<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lb + <span class="number">1</span>): f[<span class="number">0</span>][i] = i</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, la + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lb + <span class="number">1</span>):</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i-<span class="number">1</span>][j], f[i][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> a[i] == b[j]:</span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">else</span>: </span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> f[la][lb] &lt;= l:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="区间DP">区间DP</h2><p>递推式不具有线性关系。</p><p><strong>区间dp的状态表示一般采用二维来表示一个区间</strong>。集合是从第<code>i</code>个元素到第<code>j</code>元素而不再都从第1个元素开始。</p><p>递推关系是从两个更小的区间合并成一个更大的区间。</p><p>区间dp要注意枚举顺序，需枚举区间长度，从长度为1的区间开始枚举。<strong>一般先枚举区间长度，再枚举区间左端点</strong>。</p><h3 id="AcWing-282-石子合并"><a href="https://www.acwing.com/problem/content/284/">AcWing 282. 石子合并</a></h3><p>状态表示时要考虑到由于操作是将任意左右两堆合并，左右端点不确定且具有对称性，因此将左右端点作为两维，因此状态对应于一个区间。集合定义即所有将第<code>i</code>堆石子到第<code>j</code>堆石子合并成一堆的合并方式。</p><p>集合划分思考最后一步和倒数第二步的递推关系，显然无论区间有多长，要合成一堆，倒数第二步是合成左右两堆。由于合并顺序不定，因此左右两堆的分界点就会不同，对应的合成两堆的代价也不同。因此需要暴力枚举左右两堆的分界点。</p><p>合并两堆的代价是两堆的总重量，即区间和，因此需要使用前缀和。<br>$$<br>f[i, j] = min(f[i, k] + f[k + 1, j] + s[j] - s[i - 1]), k =i,\ldots, j - 1<br>$$<br><code>k</code>从<code>i</code>到<code>j-1</code>是因为左右都至少要有一堆</p><p>枚举顺序是先枚举区间长度，再枚举区间左端点。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230325202545559.png" alt="image-20230325202545559"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 石子合并</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N];<span class="comment">// 前缀和</span></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] += s[i<span class="number">-1</span>];<span class="comment">// 求前缀和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本题递推中只涉及区间数据的和</span></span><br><span class="line">    <span class="comment">// 求任意区间的数据的和可以采用前缀和的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以区间长度从小到大来枚举所有状态</span></span><br><span class="line">    <span class="comment">// 边界条件：区间长度为1，值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++ i)&#123; <span class="comment">// i为区间起点</span></span><br><span class="line">            <span class="type">int</span> l = i, r = i + len - <span class="number">1</span>; <span class="comment">// 区间左右端点</span></span><br><span class="line">            f[l][r] = <span class="number">1e9</span>; <span class="comment">// 注意求的是最小值，一定要先把状态值初始化为比较大的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt; r; ++ k) <span class="comment">// 注意k&lt;r，补去等。 k为子区间的分界点</span></span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;        </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-5">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    s = [<span class="number">0</span>] + <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    f = [[<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        f[i][i] = <span class="number">0</span></span><br><span class="line">        s[i] += s[i - <span class="number">1</span>] <span class="comment"># 前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注意这里的遍历范围是极容易错的</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span> - <span class="built_in">len</span> + <span class="number">1</span>):</span><br><span class="line">            l, r = i, i + <span class="built_in">len</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(l, r):</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k+<span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(f[<span class="number">1</span>][n])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="组合BP">组合BP</h2><p>有限制的组合（选择）问题就是背包问题，可以使用动态规划，只考虑组合而不考虑排序</p><h2 id="计数类DP">计数类DP</h2><p>计数类DP即状态表示的集合的要求的属性为数量。而这种数量往往指组合的数量，可用DP解决</p><h3 id="1-AcWing-900-整数划分">1. <a href="https://www.acwing.com/problem/content/description/902/">AcWing 900. 整数划分</a></h3><p>组合问题首先就要看能不能用DP</p><h4 id="思路一：转化为完全背包问题">思路一：转化为完全背包问题</h4><p>题目中将正整数 n 表示成若干个正整数$n_i$之和，且划分是无关顺序的（一定按照从大到小排列），这种无关顺序的划分问题可以被视为一个组合问题。原题等价于从1~n中所有数中进行选择，使其和等于n，每个数可以选择无数次。因而这可以转化为完全背包问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数划分 思路一：转化为完全背包问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: 空集作为一种方案</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j] % mod;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= i) f[i][j] = (f[i][j] + f[i][j-i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数划分 思路一：转化为完全背包问题 + 滚动数组优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: 空集作为一种方案</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line">            f[j] = (f[j] + f[j-i]) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-6">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f[i][j] = f[i-1][j] + f[i-1][j-1*i] + f[i-1][j-2*i] + ... + f[i-1][j-k*i]</span></span><br><span class="line"><span class="comment"># f[i][j-i] = f[i-1][j-i] + f[i][j-2*i] + ... + f[i-1][j-k*i]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    f = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    mod = <span class="built_in">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># f[0][0]表示的是从0个数中选体积为0的方案，也就是1个方案</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            f[i][j] = f[i-<span class="number">1</span>][j] % mod</span><br><span class="line">            <span class="keyword">if</span> j &gt;= i:</span><br><span class="line">                f[i][j] = (f[i][j] + f[i][j-i]) % mod</span><br><span class="line">    <span class="built_in">print</span>(f[n][n])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    mod = <span class="built_in">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># f[0][0]表示的是从0个数中选体积为0的方案，也就是1个方案</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n + <span class="number">1</span>):</span><br><span class="line">            f[j] = (f[j] + f[j-i]) % mod</span><br><span class="line">    <span class="built_in">print</span>(f[n])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="思路二">思路二</h4><ul class="lvl-0"><li class="lvl-2"><p>集合：所有总和是<code>i</code>，并且恰好表示成<code>j</code>个数的和的方案</p></li><li class="lvl-2"><p>集合划分：划分为最小值为1和最小值大于1两类</p></li></ul><p>对于第一类，为<code>f[i-1][j-1]</code>；对于第二类，为<code>f[i-j][j]</code>；这两类的推到其实分别沿着第二维j和第一维<code>i</code></p><p><strong>一定掌握这种集合划分的思路，应用到了映射的思想</strong>。既然讨论的是选取方案，我们就可以把是否选取最小的一个元素作为不同点进行讨论，这里关键是能够进行映射才行。</p><p>只要能进行划分并能用状态表示出来即可</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230325225807811.png" alt="image-20230325225807811"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: 空集作为一种方案</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            f[i][j] = (f[i<span class="number">-1</span>][j<span class="number">-1</span>] + f[i-j][j]) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res = (res + f[n][i]) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-7">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    f = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    mod = <span class="built_in">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># f[0][0]表示的是总和为0，由0个数构成，方案数为1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>): <span class="comment"># 注意选择的数最小为1，所以j至多为i</span></span><br><span class="line">            <span class="comment"># 按照组成是否含有1来划分</span></span><br><span class="line">            f[i][j] = (f[i-<span class="number">1</span>][j-<span class="number">1</span>] + f[i-j][j]) % mod</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(f[n]) % mod) <span class="comment"># 注意最后别忘取余</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-1050-鸣人的影分身">2. <a href="https://www.acwing.com/problem/content/1052/">AcWing 1050. 鸣人的影分身</a></h3><p>本题是<a href="https://www.acwing.com/problem/content/description/902/">AcWing 900. 整数划分</a>的变形题。前面和整数划分完全一致，但多了一个限制条件——元素的个数，至多只能划分为N个数。</p><p>因为这个限制条件，整数划分的第一个思路——转化为完全背包问题就不可行了（完全背包对元素个数没有直接限制，每个元素可以取无数次）。但思路二仍是可行的，因为其将划分的元素数作为状态的一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1050. 鸣人的影分身</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数位DP">数位DP</h2><p>可参考以下博客的讲解：</p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.luogu.com.cn/blog/virus2017/shuweidp">数字组成的奥妙——数位dp</a></p></li></ul><p><strong>数位DP重点在于分类讨论</strong>（即集合划分）。</p><p>首先我们要清楚数位dp解决的是什么问题：</p><p>求出在给定区间[A,B]内，符合条件f(i)的数i的个数。条件f(i)一般与数的大小无关，而与数的组成有关</p><p>由于数是按位dp，数的大小对复杂度的影响很小</p><p>对于[l,r]区间问题，我们一般把他转化为两次数位dp,即找[0,r]和[0,l-1]两段，再将结果相减就得到了我们需要的[l,r]</p><h3 id="1-AcWing-338-计数问题">1. <a href="https://www.acwing.com/problem/content/340/">AcWing 338. 计数问题</a></h3><ul class="lvl-0"><li class="lvl-3"><p>直接求解a-b之间的数的个数并不好求，这里要采用类似前缀和的思想来求解，先建立一个求解1~n之间的数的个数的函数，则$$count(a,b) = count(1,b) - count(1, a-1)$$</p></li><li class="lvl-3"><p>针对于求每一位上数出现的个数，我们要进行分类讨论：</p></li></ul><p>不妨设n = abcdefg，当前要求的数为k，分别求出其在每一位上出现的次数</p><p>不妨讨论其在第四位d的情况， 则1 &lt;= xxxkyyy &lt;= abcdefg。下面进行分类讨论：</p><p>(1) xxx = 000~abc - k，则yyy = 000~999，共abc*1000个</p><p>(2) xxx = abc</p><ol><li class="lvl-3"><p>d &lt; k, abckyyy &gt; abcdyyy，不成立</p></li><li class="lvl-3"><p>d = k, yyy = 000~efg，共efg + 1个</p></li><li class="lvl-3"><p>d &gt; k, yyy = 000~999，共1000个</p></li></ol><p>还要注意边界问题：</p><ul class="lvl-0"><li class="lvl-2"><p>当k放在首位是(1)的情况将不存在。</p></li><li class="lvl-2"><p>当k=0时，不能作为前导零和首位，即xxx要从001开始而不能从000开始</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数位dp——计数问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(vector&lt;<span class="type">int</span>&gt; num, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;<span class="comment">// 求出从第l位到第r位组成的数的大小</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &gt;= r; -- i) res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power10</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// 求10^x的大小</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x--) res *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    num.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        num.<span class="built_in">push_back</span>(n % <span class="number">10</span>); <span class="comment">//首先将每一位提出来</span></span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = num.<span class="built_in">size</span>(); <span class="comment">// 保存总位数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// vector从0开始，注意循环的范围</span></span><br><span class="line">    <span class="comment">// 注意这里巧妙的写法：i = n - 1 - !x，这样写避免了0作为第一位</span></span><br><span class="line">    <span class="comment">// 注意i表示第几位的位数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span> - !x; i &gt;= <span class="number">0</span>; -- i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)&#123; <span class="comment">// 作为首位时此情况不存在</span></span><br><span class="line">            res += <span class="built_in">get</span>(num, n - <span class="number">1</span>, i + <span class="number">1</span>) * <span class="built_in">power10</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (!x) res -= <span class="built_in">power10</span>(i); <span class="comment">// x = 0时从001开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[i] == x) res += <span class="built_in">get</span>(num, i - <span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num[i] &gt; x) res += <span class="built_in">power10</span>(i); <span class="comment">// 注意i从0开始，所以这里不是i-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b, a || b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">count</span>(b, i) - <span class="built_in">count</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态压缩DP">状态压缩DP</h2><p>可参考以下博客的讲解：</p><ul class="lvl-0"><li class="lvl-2"><p><a href="https://www.cnblogs.com/ibilllee/p/7651971.html">状态压缩DP入门</a></p></li><li class="lvl-2"><p><a href="https://www.cnblogs.com/Tony-Double-Sky/p/9283254.html">状态压缩动态规划 状压DP</a></p></li><li class="lvl-2"><p><a href="https://blog.csdn.net/u011077606/article/details/43487421">动态规划之状态压缩dp入门</a></p></li></ul><h3 id="引入">引入</h3><p>对于<strong>组合问题或选择问题</strong>，我们可以使用01向量来表示每种组合的选择情况，如$x=&lt;1,0,0,0,1&gt;$。我们以1表示元素被选中，0表示元素没被选中。</p><p>而这种01表示实际上可以被视为一个二进制数。反过来，<strong>每一个二进制都可以用来表示一种组合问题中的选法</strong>。并且我们可以通过二进制的位运算来实现对选法的操作。这就直观的实现了选法的量化和处理。</p><p><strong>所谓状态压缩DP即DP中的所有状态都用二进制编码表示</strong></p><h3 id="状态压缩">状态压缩</h3><p>简单来说，状态压缩利用计算机二进制的性质来描述状态的一种方法。</p><p>利用前文的思路，我们将一个整数视为二进制数，并用二进制数的每一位表示选择的情况。每一个整数就是一个压缩的状态（组合的选法），这就是状态压缩。</p><p>之所以要用到状态压缩是因为在很多问题中状态表示往往比较复杂麻烦，不容易表示出来，需要用一些编码技术，把状态压缩的用简单的方式表示出来。典型方式就是当需要表示一个集合有哪些元素时，往往利用2进制用一个整数表示。</p><p>状压其实是一种很暴力的算法，因为它需要遍历每个状态，所以将会出现2^n的情况数量，不过这并不代表这种方法不适用：一些题目可以依照题意，<strong>排除冗余与不合法的方案</strong>，使一行的总方案数大大减少从而减少枚举。</p><p>这里实际上利用了十进制和二进制的一一对应关系，以二进制表示状态，以十进制作为存储和枚举编号</p><h3 id="状态压缩DP-2">状态压缩DP</h3><p>状态压缩通常和BFS或DP连用，当和DP一起使用时即为状态压缩DP。</p><p>动态规划本来就很抽象，状态的设定和状态的转移都不好把握，而状态压缩的动态规划解决的就是那种状态很多，不容易用一般的方法表示的动态规划问题，这个就更加的难于把握了。难点在于以下几个方面：状态怎么压缩？压缩后怎么表示？怎么转移？是否具有最优子结构？是否满足后效性？涉及到一些位运算的操作，虽然比较抽象，但本质还是动态规划。找准动态规划几个方面的问题，深刻理解动态规划的原理，开动脑筋思考问题。这才是掌握动态规划的关键。</p><p>由于状态都是二进制数，因此在状态计算时就要用到位运算进行操作</p><h3 id="位运算">位运算</h3><p>借助于<strong>位运算</strong>，我们可以实现对状态进行操作或访问。</p><p>常用位运算如下：</p><table><thead><tr><th style="text-align:center">运算名</th><th style="text-align:center">符号</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center">&amp;</td><td style="text-align:center">按位与</td><td style="text-align:center">如果两个相应的二进制位都为1，则该位的结果值为1，否则为0</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">按位或</td><td style="text-align:center">两个相应的二进制位中只要有一个为1，该位的结果值为1</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">按位异或</td><td style="text-align:center">若参加运算的两个二进制位值相同则为0，否则为1</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">取反</td><td style="text-align:center">~是一元运算符，用来对一个二进制数按位取\反，即将0变1，将1变0</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td style="text-align:center">左移</td><td style="text-align:center">用来将一个数的各二进制位全部左移N位，右补0</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td style="text-align:center">右移</td><td style="text-align:center">将一个数的各二进制位右移N位，移到右端 的低位被舍弃，对于无符号数，高位补0</td></tr></tbody></table><p>常用应用技巧如下：</p><table><thead><tr><th style="text-align:center">位运算操作</th><th style="text-align:center">代码</th></tr></thead><tbody><tr><td style="text-align:center">判断一个数字x二进制下第<code>i</code>位是不是等于1(这里<code>i</code>从0开始)</td><td style="text-align:center"><code>if (( x &gt;&gt; i &amp; 1 )</code>或 <code>if ((( 1 &lt;&lt; i) &amp; x ))</code></td></tr><tr><td style="text-align:center">将一个数字x二进制下第<code>i</code>位更改成1</td><td style="text-align:center">`x = x</td></tr><tr><td style="text-align:center"><code>lowbit</code>运算——求一个数字最右端1对应的大小</td><td style="text-align:center"><code>lowbit(x) = x &amp; -x</code></td></tr><tr><td style="text-align:center">把一个数字二进制下最靠右的第一个1去掉</td><td style="text-align:center"><code>x = x - lowbit(x) = x - (x &amp; -x)</code>或<code>x = x &amp; ( x − 1 )</code></td></tr><tr><td style="text-align:center">用位运算求解$2^n$</td><td style="text-align:center"><code>1 &lt;&lt; n</code></td></tr><tr><td style="text-align:center">取出<code>i</code>二进制下的第<code>j</code>位</td><td style="text-align:center"><code>i &gt;&gt; j &amp; 1</code></td></tr><tr><td style="text-align:center">用位运算判断奇偶</td><td style="text-align:center">奇数：<code>n &amp; 1 == 1</code> 偶数：<code>n &amp; 1 == 0</code></td></tr></tbody></table><h3 id="1-AcWing-291-蒙德里安的梦想">1. <a href="https://www.acwing.com/problem/content/293/">AcWing 291. 蒙德里安的梦想</a></h3><p>首先需要注意到当我们将所有横向的小方格，纵向的小方格就只能保剩下的位置全部填满，因而只剩下一种填法。</p><p><strong>所以整个的划分方案数就等于所有横向的小方格的方案数</strong>。</p><p>这里要求看出组合/排序/选择问题的本质，去除冗余，并从多个对象中合理选择处理对象。</p><p>需注意横向小方格的方案必须保证最后剩下的位置都被纵向小方格填满。</p><p>如果我们以<code>i</code>作为列数，为了表示每一列中方格的排列情况就需要使用状态压缩，以二进制表示每一行是否存在方格。为此我们以整数j表示这种压缩状态。</p><p>当问题中的状态之间有关联性，需要将每种情况对应的状态具体存储下来用于后续处理，且状态为选择的情况时，就可以用二进制表示。讲白了，常见题目的原数组是固定的，而这里原数组动态变化，是我们讨论的对象，因此需要动态讨论表示出来。</p><p>同时可以发现二进制状态压缩隐含降维的作用，如果不使用状态压缩的话，维度会超过两维，状态转换会过于复杂，而使用状态压缩后每个选择状态都是一个一维向量，却只使用一个数的存储量，实现了降维，便于讨论和转移状态。本题实现了沿列这一维进行压缩，将所有行压缩到一个数值中。</p><p>另外需注意，由于小方格的大小是 $1 \times 2 $的，<strong>所以在我们研究第<code>i + 1</code>列时，第<code>i</code>列的组合情况就会对其造成影响</strong>。但需注意，这种影响并不是后效性，可以发现<strong>只有相邻的两列才会产生互相影响，而不会影响其他列</strong>。因而实际上，这是一种<strong>有条件约束、需分类讨论的递推关系</strong>，仍可以使用dp。</p><p>可以发现，第<code>i</code>列的每种组合情况实际上都等同于第<code>i+1</code>列所有初始分布情况，状态<code>j + 1</code>是在状态<code>j</code>的基础上得到的。换就话说为了得出<code>j + 1</code>，就要对前一列的所有状态<code>j</code>进行枚举，再取所有满足前面两种限制的状态<code>j + 1</code>。</p><p>前面的两种限制可以量化为以下形式：</p><ol><li class="lvl-3"><p>为了保证第<code>i</code>列和第<code>i+1</code>列不出现小方格的重叠放置，必须满足：<br>$$<br>(j \ &amp; \ k) == 0<br>$$</p></li></ol><p>之所以这样写是因为我们的二进制表示中只会表示横向方格的第二个方格，如果当前列的状态中有方格，前一列就必须没有方格（实际表示要有空间存放第一个方格）。这一化简很重要。</p><ol start="2"><li class="lvl-3"><p>为了保证最后第<code>i-1</code>能被纵向的小方格填满，第<code>i</code>列的状态<code>j</code>和第<code>i+1</code>列的状态<code>k</code>必须满足：</p></li></ol><p>$$<br>(j\  |\ k)不存在连续奇数个0<br>$$</p><p>注意<code>(j|k)</code>表示的是第<code>i-1</code>列的选择情况而不是第<code>i</code>列。因此最后一列还要特判。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230329212621963.png" alt="image-20230329212621963"></p><h4 id="朴素算法-5">朴素算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 291. 蒙德里安的梦想——状压DP未优化做法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N; <span class="comment">// 使用位运求解2^N</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL f[N][M]; <span class="comment">// 爆int</span></span><br><span class="line"><span class="type">bool</span> st[M];<span class="comment">// 用于标记是否满足偶数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)&#123; <span class="comment">// n=0，m=0时，表示输入终止</span></span><br><span class="line">        <span class="comment">// 预处理出所有满足偶数的二进制表示状态</span></span><br><span class="line">        <span class="comment">// 遍历所有可能的选择情况的二进制表示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i)&#123; <span class="comment">// 使用位运求解2^n</span></span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// cnt表示当前这一段连续0的个数</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 2^n二进制有n位</span></span><br><span class="line">            <span class="comment">// 预处理所有状态不存在奇数个0</span></span><br><span class="line">            <span class="comment">// 之所以可以预处理是因为所有组合情况都通过二进制穷举出</span></span><br><span class="line">            <span class="comment">// 这里一定要注意这种预处理思想，不是在组合前进行判断，而是在组合后进行判断；无论如何组合，都会包含在事先枚举出的所有状态中</span></span><br><span class="line">            <span class="comment">// 遍历每个二进制表示的每一位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)&#123; <span class="comment">// i的二进制中，从右往左数，取第j+1位上的值</span></span><br><span class="line">                <span class="comment">// 当前这一段是1说明上一段连续0的段落已经截止</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 判断上一段连续的0是奇数个还是偶数个</span></span><br><span class="line">                    <span class="comment">// cnt &amp; 1取出cnt二进制的个位，当cnt为偶数时，个位为0，当cnt为奇数时，个位为1</span></span><br><span class="line">                    cnt = <span class="number">0</span>; <span class="comment">// 清空</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ++ cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>; <span class="comment">// 最后一段下方可能是边界不再存在1（小方格）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f); <span class="comment">// memset 按照字节赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 第0列什么都不放，其状态为0，也不会存在小方格顶出到第1列，所以f[0][0] = 1(什么都不放也是选择方式)，f[0][1~n] = 0(其余组合状态都不被选择)</span></span><br><span class="line">        <span class="comment">// 枚举所有列</span></span><br><span class="line">        <span class="comment">// 分割从第0列开始，但第0列是不用讨论的，只存储横向方格的第二个方格</span></span><br><span class="line">        <span class="comment">// 因为j|k维护前一列，所以遍历到m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) </span><br><span class="line">            <span class="comment">// 枚举第i列所有状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; ++ j)</span><br><span class="line">                <span class="comment">// 枚举第i-1列的所有状态</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k]) </span><br><span class="line">                    <span class="comment">// j &amp; k 会取出在j和k中都为1的位，即都被选择的元素，它实际上就是两列重叠放置的情况</span></span><br><span class="line">                    <span class="comment">// j | k 会筛出在j或k中被选的元素，它实际上就是两列都放上小方格后第i-1列的组合情况，用于维护i-1列最后一定能被填满</span></span><br><span class="line">                        f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">                        <span class="comment">// 只要相邻两列的状态满足约束条件，前一列的该状态的选择数就会加在发f[i][j]上</span></span><br><span class="line">                        <span class="comment">// 这里是一种穷举方法，针对第i列的每一种状态，都枚举前一列的所有状态来判断是否可以组合在一起</span></span><br><span class="line">        <span class="comment">// 不能有超出棋盘的方格，所以m对应的状态为全0</span></span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 这里要理解f[i][j]里存的是什么，i是第i列，j是这一列的一种选择状态，f[i][j]表示在这一列处于这种选择状态时从第1列到第i列的所有选择数</span></span><br><span class="line">        <span class="comment">// 最后一列由于涉及边界问题，不能再存放小方格，所以其状态只能是0，由此要求的答案为f[m][0]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="去除无效状态的优化写法">去除无效状态的优化写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL f[N][M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state[M];</span><br><span class="line"><span class="type">bool</span> st[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> is_valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        is_valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++ ;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) is_valid = <span class="literal">false</span>;</span><br><span class="line">            st[i] = is_valid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            state[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> ((i &amp; j) == <span class="number">0</span> &amp;&amp; st[i | j])</span><br><span class="line">                    state[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : state[j])</span><br><span class="line">                    f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-8">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 状态是否有效</span></span><br><span class="line">    ok = [<span class="literal">False</span>] * (<span class="number">1</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line">    <span class="comment"># 每个状态能被转移过来的状态</span></span><br><span class="line">    state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        M = <span class="number">1</span> &lt;&lt; n</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 预处理每个状态是否合法（能否竖向插入）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            cnt, valid = <span class="number">0</span>, <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i &gt;&gt; j &amp; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> cnt &amp; <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    cnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt &amp; <span class="number">1</span>:</span><br><span class="line">                valid = <span class="literal">False</span></span><br><span class="line">            ok[i] = valid</span><br><span class="line">        <span class="comment"># 预处理每个状态的转移子集，求出每个状态后面能接的非法状态</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            state[j] = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">                <span class="comment"># 检查第 i - 2 列与第 i - 1 列是否冲突，二进制 1 表示当前行是牌板尾部</span></span><br><span class="line">                <span class="comment"># 即状态前后表示要么是 [尾，头]，要么是 [头，尾]</span></span><br><span class="line">                <span class="comment"># 此时第 i - 1 列的最终态已确定，检查第 i - 1 列能否满足竖向插入</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (j &amp; k) <span class="keyword">and</span> ok[j | k]:</span><br><span class="line">                    state[j].append(k)</span><br><span class="line">        <span class="comment"># DP 过程，前 i - 1 列安排完毕，第 i - 1 列能转移到第 i 列的方案数转移</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * M <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> state[j]:</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][k]</span><br><span class="line">        <span class="comment"># 前 m 列安排完毕，且没有牌板出界的所有方案数</span></span><br><span class="line">        <span class="built_in">print</span>(dp[m][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-91-最短Hamilton路径">2. <a href="https://www.acwing.com/problem/content/93/">AcWing 91. 最短Hamilton路径</a></h3><p>本题显然是具有最优子结构的：0经k到j的最优路径对应的0到k的路径也是最优的。因此考虑DP。</p><p>但是可以发现，路径的变化导致状态的变化。且由于这是一个无向图，行进的方向是任意的，且题目要求一个点只能遍历一次，因而结点间的顺序是相互影响的，即对应状态间是由互斥等关系的，因此就必须具体存储和讨论每个状态。又由于只用考察当前每个结点是否已经走过了，相当于组合或选择问题，可以使用二进制状态压缩。</p><p>又由于最后一个节点影响迭代，所以状态另一维度是最后到达的节点</p><p>集合：所有从0走到<code>j</code>，走过的所有点是<code>i</code>的所有路径属性：Min</p><p>集合划分：讨论倒数第二个点是0~n-1中的哪一个</p><p>这里需注意我们所关心的是经过了哪些点，最后一个点是谁，因而定义了以上的状态表示</p><h4 id="为什么使用memset-f-0x3f-sizeof-f-来初始为极大值">为什么使用memset(f, 0x3f, sizeof f)来初始为极大值</h4><p><a href="https://cloud.tencent.com/developer/article/1877662">为什么是 0x3f ？</a></p><p>0x3f中0x表示十六进制数 3f转化为二进制位0011 1111。<br>memset 按照字节赋值，因此我们把4个0011 1111填充到 32位的int上，此时f = 0x3f3f3f3f = 1061109567 是$10^9$级别的。</p><p>但问题是，为什么不是 0x4f 或者 0x5f ？</p><p>首先$10^9$级别足够大，其次，也是最重要的，0x3f3f3f3f + 0x3f3f3f3f 等于 0x7e7e7e7e = 2122219134，不会爆int。</p><p>在一般的电脑中,int占用4字节,32比特,数据范围为-2147483648<sub>2147483647[$-2^31$</sub>$2^31-1$]。</p><p>但当用到初始化-INF，直接 memset(a, -0x3f, sizeof a) 也是可以的，无非就是0x3f取反加一嘛，从 0011 1111 变为 1100 0001。但是相加会爆，所以并不是很好。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230329214550825.png" alt="image-20230329214550825"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状压DP——最短Hamilton路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            cin &gt;&gt; d[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f); <span class="comment">// 要求的是最小值，需要先初始化为无穷大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 从0走动0，距离为0(状态1表示只经过0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有状态，i表示每种路径的状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i)</span><br><span class="line">        <span class="comment">// j表示路径经过的最后一个点 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="comment">// 枚举每个点作为最后一个点</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)<span class="comment">// 状态i要经过j</span></span><br><span class="line">                <span class="comment">// k表示路径经过的倒数第二点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n ; ++ k) <span class="comment">// 枚举每个点作为倒数第二个点</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>) <span class="comment">// 状态i要经过k</span></span><br><span class="line">                        f[i][j]  = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + d[k][j]);</span><br><span class="line">                        <span class="comment">// i - (1 &lt;&lt; j)将状态i中j这个选择置为0，即路径中去除j</span></span><br><span class="line">                        <span class="comment">// 这里利用了最后一个点的有无并不影响前面的路径，如果是中间某个点就不能随意去除了</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 1 &lt;&lt; n - 1恰表示所有点（二进制的每一位都是1）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-9">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    d = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    M = <span class="number">1</span> &lt;&lt; n</span><br><span class="line">    f = [[<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]  * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(M)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 起点距离为 0</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt;&gt; j &amp; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> i &gt;&gt; k &amp; <span class="number">1</span>:</span><br><span class="line">                        <span class="comment"># 可到达点 k、j，且当前在点 k 中转到点 j 的最短路径</span></span><br><span class="line">                        <span class="comment"># f[i -(1 &lt;&lt; j)][k]对应于挖去节点j，且最后的节点为k的最优路径值</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + d[k][j])</span><br><span class="line">    <span class="comment"># 最后是全1的状态，终点为n-1</span></span><br><span class="line">    <span class="built_in">print</span>(f[M-<span class="number">1</span>][n-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="树形DP">树形DP</h2><h3 id="1-AcWing-285-没有上司的舞会">1. <a href="https://www.acwing.com/problem/content/287/">AcWing 285. 没有上司的舞会</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 285. 没有上司的舞会</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> has_fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = ++ idx; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">        has_fa[a] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (has_fa[root]) ++ root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DP没有后效性 &lt;==&gt; 抽象出来的图论模型是一个拓扑图</p><p>能都进行递归的前提是图必须是拓扑图，不能出现环</p><h2 id="记忆化搜索">记忆化搜索</h2><h3 id="1-AcWing-901-滑雪">1. <a href="https://www.acwing.com/problem/content/903/">AcWing 901. 滑雪</a></h3><p>状态表示：集合：所有从(i,j)开始滑的路径属性：Max<br>集合划分：从(i,j)分别向上下左右滑</p><p>思路更好想，代码更好写，但运行会慢些，可能会爆栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索——滑雪</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 枚举上下左右四个方向的常用技巧：使用偏移量</span></span><br><span class="line"><span class="comment">// 使用偏移量是一种简化枚举的常用技巧，记住这种使用技巧</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆化搜索——在dfs中加入存储</span></span><br><span class="line"><span class="comment">// dp(i, j)返回f[i][j]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = f[x][y];</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> v;  </span><br><span class="line">    <span class="comment">// 说明f[x][y]已经求出来了，直接返回即可</span></span><br><span class="line">    <span class="comment">// 避免重复计算；不同于递推，递归中会出现重复问题，要进行标记</span></span><br><span class="line">    <span class="comment">// 这里重复是因为我们在main()中会遍历所有f[i][j]，而dp中会进行存储，避免重复计算</span></span><br><span class="line"></span><br><span class="line">    v = <span class="number">1</span>; <span class="comment">// 至少为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp;b &lt;= m &amp;&amp; h[x][y] &gt; h[a][b])<span class="comment">// 注意边界问题</span></span><br><span class="line">            v = <span class="built_in">max</span>(v, <span class="built_in">dp</span>(a, b) + <span class="number">1</span>); <span class="comment">// 注意要进行递归， dp[i][j]会返回f[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);<span class="comment">// 将所有状态都先初始化为-1，表示每个状态都没有被算过</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Python-10">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    h = [[<span class="number">0</span>] * m] + [[<span class="number">0</span>] + <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    f = [[-<span class="number">1</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    d_x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    d_y = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="comment"># f[x][y]已经求出来了，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> f[x][y] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> f[x][y]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意初始化，至少为1</span></span><br><span class="line">        f[x][y] = <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> <span class="built_in">zip</span>(d_x, d_y):</span><br><span class="line">            nx, ny = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= nx &lt;= n <span class="keyword">and</span> <span class="number">1</span> &lt;= ny &lt;= m <span class="keyword">and</span> h[nx][ny] &lt; h[x][y]:</span><br><span class="line">                f[x][y] = <span class="built_in">max</span>(f[x][y], dp(nx, ny) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[x][y]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历每个状态</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp(i, j))</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课4 数学知识</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-4-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-4-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="数学知识">数学知识</h1><h2 id="质数">质数</h2><p>质数的定义：</p><p>在大于1的整数中，如果只包含1和本身这两个约束，就被称为质数，或者素数</p><p>注意0、1不属于质数，也不属于合数。（定义从2开始）</p><p>应用</p><ul class="lvl-0"><li class="lvl-2"><p>质数的判定：试除法 $ O ( \sqrt{n} )$</p></li><li class="lvl-2"><p>分解质因数：试除法 $ O ( \sqrt{n} )$（实际运行时$ O ( log n ) $~$ O ( \sqrt{n} )$）</p></li><li class="lvl-2"><p>筛质数：</p><ol><li class="lvl-5">朴素筛法</li><li class="lvl-5">埃氏筛法</li><li class="lvl-5">线性筛法</li></ol></li></ul><h3 id="质数的判定——试除法">质数的判定——试除法</h3><h4 id="前置知识：">前置知识：</h4><ul class="lvl-0"><li class="lvl-2"><p>质数是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数</p></li></ul><h4 id="算法分析：">算法分析：</h4><p>暴力做法：枚举约数，判断是否只有1和自己本身。</p><p>优化：约数成对出现，只用枚举每对较小的一个约数</p><p>如果在 $2\sim n - 1$ 中存在 $n$ 的约数，不妨设为 $k$，即 $n\bmod k = 0$，那么由 $k\cdot \dfrac{n}{k} = n$ 可知，$\dfrac{n}{k}$ 也是 $n$ 的一个约数，且 $k$ 和 $\dfrac{n}{k}$ 中一定满足其中一个小于等于 $\sqrt n$、另一个大于等于 $\sqrt n$。这启发我们，只需要判定 $n$ 能否被 $2, 3, \cdots, \lfloor \sqrt n \rfloor$ 中的一个整除，即可判定 $n$ 是否为素数。时间复杂度为 $O(\sqrt n)$。</p><h4 id="AcWing-866-试除法判定质数"><a href="https://www.acwing.com/problem/content/868/">AcWing 866. 试除法判定质数</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 质数的判定——试除法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_primes</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 2是最小的质数，如果n小于2，那n肯定就不是质数</span></span><br><span class="line">    <span class="comment">// 从最小的质数2开始枚举到sqrt(n)</span></span><br><span class="line">    <span class="comment">// 约数成对出现，只用枚举每对较小的一个约数</span></span><br><span class="line">    <span class="comment">//  i &lt;= n / i 比 sqrt(n)快，同时相对于i * i &lt;= n可以防止溢出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; ++ i)</span><br><span class="line">        <span class="comment">//如果可以被i整除，说明这个数不是质数</span></span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_primes</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Python">Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 质数的判定——试除法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_primes</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= x // i: <span class="comment"># 注意整除</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x % i:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span> <span class="keyword">if</span> is_primes(x) <span class="keyword">else</span> <span class="string">&quot;No&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="分解质因数——试除法">分解质因数——试除法</h3><h4 id="前置知识">前置知识</h4><h5 id="整数分解的唯一性定理">整数分解的唯一性定理</h5><p>任意一个正整数a都能分解成质数乘积的形式，并且此表示是唯一的<br>$$<br>a = P_1<sup>{\alpha_1}P_2</sup>{\alpha_2} \ldots P_t^{\alpha_t}<br>$$</p><ul class="lvl-0"><li class="lvl-2"><p>质因子：每个合数都可以写成几个质数相乘的形式,这几个质数就都叫做这个合数的质因数。如果一个质数是某个数的因数，那么就说这个质数是这个数的质因数</p></li></ul><h4 id="算法分析">算法分析</h4><p>一个正整数 $n$ 必然可以写成一个或多个质数的乘积的形式（$1$ 除外），例如 $6 = 2^1 \times 3^1$，$8 = 2^3$，$180 = 2^2 \times 3^2 \times 5^1$，即<br>$$<br>n = p_1^{ \alpha_1 } * p_2^{ \alpha_2 } * \ldots * p_k^{ \alpha_k }, \ \ p_1, p_2, \ldots , p_k皆为质数<br>$$<br>本题暴力求解是从小到大枚举所有数，寻找n的质因数。</p><p>这里需要注意的一个性质是，由于所有正整数$n$由质数的乘积构成，<strong>只要我们从小到大枚举时，把当前质因数完全除尽，每当出现 $ n \ % \ i == 0 $ 的情况时，因数<code>i</code>就一定是质数而不是合数（如果不除尽则不一定）</strong></p><p>优化：</p><p>对于一个正整数 $n$ 来说，如果它存在除 $1$ 和本身之外的因子，那么一定是在 $\sqrt n$ 左右成对出现。而如果将这个结论放在 “质因子” 上面，会得到一个强化结论：对于一个正整数 $n$ 来说，如果它存在 $[2, n]$ 范围内的质因子，要么这些质因子全部小于等于 $\sqrt n$；要么只存在一个大于 $\sqrt n$ 的质因子，而且其余质因子全部小于等于 $\sqrt n$。</p><p>因此<strong>n中最多只包含一个大于$\sqrt n$ 的质因子，只用枚举小于$\sqrt n$ 的质因子，最后如果剩下一个大于1的数，则其就是最大的一个质因子</strong></p><h4 id="算法步骤">算法步骤</h4><p>1、枚举 $1\sim \sqrt n$ 范围内所有的质数 $p$，判断 $p$ 是否为 $n$ 的因子。</p><ul class="lvl-0"><li class="lvl-2"><p>若 $p$ 是 $n$ 的因子，那么就初始化其个数 $s$ 为 $0$，然后只要 $p$ 还是 $n$ 的因子，就让 $n$ 不断除以 $p$，每次令其个数加 $1$，直到 $p$ 不再是 $n$ 的因子为止。</p></li><li class="lvl-2"><p>若 $p$ 不是 $n$ 的因子，就直接跳过。</p></li></ul><p>2、若在步骤 $1$ 结束后 $n$ 仍然大于 $1$，说明 $n$ <strong>有且仅有</strong>一个大于 $\sqrt n$ 的质因子（有可能是 $n$ 本身），这时需要初始化其个数为 $1$。</p><h4 id="时间复杂度分析">时间复杂度分析</h4><p>由于我们需要枚举 $1\sim \sqrt n$ 范围内所有的数并进行判断，这步时间复杂度为 $O(\sqrt n)$，而如果我们枚举到的数是 $n$ 的因子但不是质因子，就需要不断让 $n$ 除以 $p$：<code>while (n % p == 0) n /= p, s ++</code>，这步的时间复杂度可以忽略不计，因为即使是 $2$，最多也只会执行 $31$ 次，并且 <code>int</code> 范围内的数最多只会由 $9$ 个不同的质数组合而成，实际执行的次数非常少，时间复杂度的瓶颈在于枚举范围内的数。</p><p>至此，就已经将 $n$ 的质因子全部分解出来了。时间复杂度为 $O(\sqrt n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 867. 分解质因数</span></span><br><span class="line"><span class="comment">// 试除法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 只用枚举1~sqrt(n)范围</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; ++ i) </span><br><span class="line">    <span class="comment">// i * i &lt; i * (i+1) &lt; (i+1) * (i+1)</span></span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123; <span class="comment">// 注意i一定是质数</span></span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// k = p1^a1*p1^a2...pn^an, p1,p2...pn皆为质数，对应于i一定是质数</span></span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)&#123; </span><br><span class="line">                x /= i; <span class="comment">// 除尽当前质因数</span></span><br><span class="line">                ++ s; <span class="comment">// 统计次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, s);</span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="comment">// n中最多只包含一个大于sqrt(n)的质数，只需最后特判</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">divide</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Python-2">Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 867. 分解质因数</span></span><br><span class="line"><span class="comment"># 试除法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">x</span>):</span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= x // i:</span><br><span class="line">            <span class="keyword">if</span> x % i == <span class="number">0</span>:</span><br><span class="line">                s = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> x % i == <span class="number">0</span>:</span><br><span class="line">                    x //= i <span class="comment"># 注意整除</span></span><br><span class="line">                    s += <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;&#123;:d&#125; &#123;:d&#125;&quot;</span>.<span class="built_in">format</span>(i, s))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&#123;:d&#125; &#123;:d&#125;&quot;</span>.<span class="built_in">format</span>(x, <span class="number">1</span>))</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        divide(x)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="筛质数">筛质数</h3><h4 id="前置知识：-2">前置知识：</h4><ul class="lvl-0"><li class="lvl-2"><p>自然数按因数的个数分：质数、合数、$0$、$1$ 四类</p></li><li class="lvl-2"><p>最小的质数是 $2$，最小的合数是 $4$，连续的两个质数是 $2$、$3$</p></li><li class="lvl-2"><p>每个合数都可以由几个质数相乘得到，即<strong>合数等于质数之积</strong>，质数相乘一定得到合数</p></li><li class="lvl-2"><p>除了 $2$ 和 $5$，其余质数的个位都是 $1、 3、 7、 9$</p></li><li class="lvl-2"><p><strong>质数定理：当 $n \rightarrow \infty$ 时，$1\sim n$ 中的质数个数为 $\dfrac{n}{\ln n}$</strong>。</p></li></ul><h4 id="常用筛法：">常用筛法：</h4><h5 id="1、暴力筛-O-n-sqrt-n">1、暴力筛 $O(n\sqrt n)$</h5><p>通过用判断素数的函数来枚举每一数加入到素数表中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_prime</span>(i)) primes[cnt ++ ] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析：</p><p>遍历 $O(n)$，素数判断最坏 $O(\sqrt n)$，总复杂度为 $O(n\sqrt n)$。</p><h5 id="2、朴素筛-O-n-log-n">2、朴素筛 $O(n\log n)$</h5><p>任何整数 $x$ 的倍数 $2x, 3x, \cdots$ 都不可能是素数。我们可以从 $2$ 往后扫描，将当前数的所有倍数全部筛掉，剩下没有被筛掉的数就是质数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i ) st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析：</p><p>当 $i = 2$ 时，第二层循环共循环了 $\dfrac{n}{2}$ 次，$i = 3$ 时循环了 $\dfrac{n}{3}$ 次，$\cdots$，总共循环了：<br>$$<br>\dfrac{n}{2} + \dfrac{n}{3} + \cdots + \dfrac{n}{n} = n(\dfrac{1}{2} + \dfrac{1}{3} + \cdots + \dfrac{1}{n})<br>$$<br>其中 $\dfrac{1}{2} + \dfrac{1}{3} + \cdots + \dfrac{1}{n}$ 为调和级数，当 $n \rightarrow \infty$ 时，有：$\sum\limits_{k=1}^{n} \dfrac{1}{k} = \ln n + \gamma$，并且 $\gamma$ 为<strong>欧拉常数</strong>（$\text{Euler Constant}$），约为 $0.577215664\ldots$ 故时间复杂度：<br>$$<br>n(\dfrac{1}{2} + \dfrac{1}{3} + \cdots + \dfrac{1}{n})\approx n\ln n \approx n\log n<br>$$<br>即 $O(n\log n)$。</p><h5 id="3、-埃拉托斯特尼（埃氏）筛-O-n-log-log-n">3、 埃拉托斯特尼（埃氏）筛 $O(n\log \log n)$</h5><p>对上面的朴素筛法进行优化，我们发现并不需要将每个数的倍数都筛去，我们可以只把所有质数的倍数筛去。</p><p>若按照之前的筛法筛去一个整数的所有倍数，我们最终会留下一些质数，以 $p$ 为例，说明 $p$ 不是 $2\sim p - 1$ 内任何一个数的倍数，我们并不需要将 $2\sim p - 1$ 内所有的数依次枚举一遍，只要将其中的质数枚举一遍即可，因为<strong>合数等于质数之积</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i ) st[j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//  for (LL j = (LL)i * i; j &lt;= n; j += i ) st[j] = true;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个优化，$j$ 可以从 $i\cdot i$ 开始枚举，因为 $i\cdot (2\sim i - 1)$ 已经被 $2\sim i - 1$ 筛去了。但由于数据范围限制，这样会使得 $i\cdot i$ 可能会爆 <code>int</code>，因此要开 <code>long long</code>。</p><p>时间复杂度分析：</p><p>由于我们只用筛去 $2\sim n - 1$ 中的素数倍数即可，故调和级数变为：$\sum\limits_{p\leq n} \dfrac{1}{p}$，其中 $p$ 为质数。当 $n$ 趋于无穷时，有：</p><p>$$<br>M = \lim_{n\to \infty} \left (\sum\limits_{p\leq n} \dfrac{1}{p} - \ln(\ln(n))\right) = \gamma + \sum\limits_p \left [\ln \left(1 - \dfrac{1}{p} \right) + \dfrac{1}{p} \right]<br>$$</p><p>其中，$M$ 为 <strong>$\text{Meissel-Mertens}$ 常数</strong>，也称 <strong>$\text{Mertens}$ 常数</strong>或<strong>质数倒数和常数</strong>，数值约为 $0.261497\ldots$</p><p>所以当 $n\rightarrow \infty$ 时，$ n\cdot \sum\limits_{p\leq n} \dfrac{1}{p} \approx n\ln(\ln n) $，即为 $O(n\log \log n)$。</p><h5 id="4、-线性（欧拉）筛-O-n">4、 线性（欧拉）筛 $O(n)$</h5><p>埃氏筛存在一个缺陷，即对于一个合数，可能会被筛多次，例如 $30 = 2\times 15 = 5\times 6\ldots$，我们改用其最小质因子去筛掉这个合数，就可以保证他只会被筛一次。</p><p>我们从小到大枚举所有质因子 <code>primes[j]</code>。</p><p>1、当出现 <code>i % primes[j] == 0</code> 时，<code>primes[j]</code> 一定是 $i$ 的最小质因子，因此也一定是 <code>primes[j] * i</code> 的最小质因子。</p><p>2、当出现 <code>i % primes[j] != 0</code> 时，说明我们还尚未枚举到 $i$ 的任何一个质因子，也就表示 <code>primes[j]</code> 小于 $i$ 的任何一个质因子，这时 <code>primes[j]</code> 就一定是 <code>primes[j] * i</code> 的最小质因子。</p><p>可以发现无论如何，<code>primes[j]</code> 都一定是 <code>primes[j] * i</code> 的最小质因子，并且由于所要筛的质数在 $2\sim n$ 之间，因此合数最大为 $n$，故 <code>primes[j] * i</code> 只需枚举到 $n$ 即可，但由于 <code>primes[j] * i</code> 可能会溢出整数范围，故改成 <code>primes[j] &lt;= n / i</code> 的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)  <span class="keyword">break</span>; <span class="comment">// primes[j] 一定是 i 的最小质因子 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析：</p><p>$2\sim n$ 中，任何一个合数都会被筛去，而且仅用最小质因子去筛，每个合数都有且仅有一个最小质因子，故每个合数只会被筛一次，所以时间复杂度为 $O(n)$。</p><h4 id="AcWing-868-筛质数"><a href="https://www.acwing.com/problem/content/870/">AcWing 868. 筛质数</a></h4><p>朴素筛法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 868. 筛质数 </span></span><br><span class="line"><span class="comment">// 朴素筛法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>埃氏筛法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 868. 筛质数 </span></span><br><span class="line"><span class="comment">// 埃氏筛法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">            primes[cnt ++] = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i+i; j &lt;= n; j += i) st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性筛法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 868. 筛质数 </span></span><br><span class="line"><span class="comment">// 线性筛法求素数</span></span><br><span class="line"><span class="comment">// 核心方法是使用primes[j]筛掉primes[j] * i</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[x]存储x是否被筛掉，筛掉的即不是质数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 枚举所有数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++] = i; <span class="comment">// 没被筛掉说明是质数</span></span><br><span class="line">        <span class="comment">// 使用当前所有质数进行筛选，且每个数只会由其最小质因子筛掉</span></span><br><span class="line">        <span class="comment">// 即使用primes[j]筛掉primes[j] * i</span></span><br><span class="line">        <span class="comment">// primes[j] * i &gt; n 时不再具有筛选意义</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; ++ j)&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;<span class="comment">// n只会被最小质因子筛掉</span></span><br><span class="line">            <span class="comment">//primes[j]一定是primes[j] * i的最小质因子。</span></span><br><span class="line">            <span class="comment">// 到i的最小质因子截止</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j]一定是i的最小质因子</span></span><br><span class="line">            <span class="comment">// 注意循环一定会停止，i为质数时，则primes[j]最后一个等于i，会break；i不为质数则一定存在primes[j]使break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Python-3">Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 868. 筛质数 </span></span><br><span class="line"><span class="comment"># 线性筛法求素数</span></span><br><span class="line"><span class="comment"># 核心方法是使用primes[j]筛掉primes[j] * i</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    primes = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    st = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_primes</span>(<span class="params">n</span>):</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> st[i]:</span><br><span class="line">                primes[cnt] = i</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> primes[j] &lt;= n // i:</span><br><span class="line">                st[primes[j] * i] = <span class="literal">True</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i % primes[j - <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(cnt)</span><br><span class="line">        </span><br><span class="line">    get_primes(n)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="约数">约数</h3><p>应用</p><ol><li class="lvl-3"><p>试除法求一个数的所有约数</p></li><li class="lvl-3"><p>约数个数</p></li><li class="lvl-3"><p>约数之和</p></li></ol><h2 id="试除法求所有约数">试除法求所有约数</h2><p>对于一个正整数 $n$ 来说，如果它存在除 $1$ 和本身之外的因子，那么一定是在 $\sqrt n$ 左右成对出现。所以我们在求一个整数 $n$ 的所有约数时，只需要求出<strong>较小的那一个约数</strong>即可。</p><p>例如对于 $3 \times 4 = 12,\ 4 \times 3 = 12$，两种情况是等价的，一个公式能枚举出两个约数。</p><h3 id="算法步骤：">算法步骤：</h3><p>对于一个整数 $n$，它的任意两个约数 $a,\ b$ 满足 $a \leq \sqrt n,\ \ b \geq \sqrt n$。</p><p>所以我们在枚举时，只需要枚举 $1\sim \sqrt n$，保存较小的那个约数 $a$ 和对应的另一个约数 $\dfrac{x}{a}$，注意需要特判一下两个约数是否相等**（因为有可能是<strong>开方</strong>）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i &lt;= n / i; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 避免i * i = n时重复</span></span><br><span class="line">            <span class="keyword">if</span> (i != n / i) res.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">        &#125; </span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">get_divisors</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t : res) cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数个数">约数个数</h2><h3 id="算法分析：-2">算法分析：</h3><p>如果要求一个正整数 $n$ 的因子个数，只需要对其进行质因子分解，得到各质因子的个数分别为 $e_1, e_2, \ldots, e_k$，于是 $n$ 的因子个数就是 $(e_1 + 1)\cdot (e_2 + 1)\cdot \ldots \cdot (e_k + 1)$。</p><p>原因是，对于每个质因子 $p_i$，都可以选择其出现 $0$ 次、$1$ 次、$\cdots$、$e_i$ 次，共有 $e_i + 1$ 种可能，组合起来就是答案。</p><p>求约数个数的公式：<br>$$<br>如果 N = p_1^{c_1} * p_2^{c_2} * … *p_k^{c_k},\\约数个数=(c_1 + 1) * (c_2 + 1) * … * (c_k + 1)<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;<span class="comment">// 存储每个质因子的次数</span></span><br><span class="line">    <span class="comment">// 使用数值直接存储浪费空间，使用map存储</span></span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="comment">// 试除法分解质因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; ++ i)</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> prime : primes) res = res * (prime.second + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="comment">// map容器的迭代器里面有first()和second()，first()相当于健的迭代器，second()相当于值的迭代器</span></span><br><span class="line">    <span class="comment">// 取模时利用性质: a*b mod n = (a mod n) * (b mod n) mod n = (a mod n) * b mod n;</span></span><br><span class="line">    <span class="comment">// 这里分别处理每个正整数即可，不需要先乘在一起</span></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数之和">约数之和</h2><p>求约数之和的公式：<br>$$<br>如果 N = p_1^{c_1} * p_2^{c_2} * … *p_k^{c_k},\\<br>约数之和=(p_1^0 + p_1^1 + … + p_1^{c_1}) * … * (p_k^0 + p_k^1 + … + p_k^{c_k})<br>$$</p><p>算法分析：对于任意一个自然数 $n$，可以将其分解为：$$n = p_1^{e_1}\cdot p_2^{e_2}\cdot p_3^{e_3}\cdot \ldots \cdot p_k^{e_k}$$</p><p>其中 $p_i$ 表示质因子，$e_i$ 表示 $p_i$ 的指数（即该质因子的个数），则 $n$ 的约数个为: $$(e_1 +1)\cdot (e_2 + 1)\cdot (e_3 + 1)\cdot \ldots \cdot (e_k + 1)$$</p><p>其约数之和为：</p><p>$$(1 + p_1^1 + p_1^2 + \cdots + p_1^{e_1})\cdot (1 + p_2^1 + p_2^2 + \cdots + p_2^{e_2})\cdot \ldots \cdot (1 + p_k^1 + p_k^2 + \cdots + p_k^{e_k})$$</p><p>等比数列求和公式：<br>$$<br>S_n= \frac{a_1(1-q^n)}{(1-q)}<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unodered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="comment">// 试除法分解质因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; ++ i)</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i]++; <span class="comment">// 记录次幂数</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) primes[x ++];</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> prime : primes)&#123;</span><br><span class="line">        <span class="type">int</span> p = prime.first, a = prime.second;</span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// t = 1 --&gt; t*p + 1 = p + 1</span></span><br><span class="line">        <span class="keyword">while</span> (a--) t = (t * p + <span class="number">1</span>) % mod; <span class="comment">// 利用递推式求和</span></span><br><span class="line">        <span class="comment">// a * b % p = (a % p) * b % p = (a % p) * (b % p) % p</span></span><br><span class="line">        <span class="comment">// (a + b) % p = (a % p + b % p) % p </span></span><br><span class="line">        res = res * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧几里得算法-辗转相除法">欧几里得算法(辗转相除法)</h2><p>欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式<code>gcd(a,b) = gcd(b,a mod b)</code></p><p>$O(logn)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> namepsace std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; <span class="comment">// 递归写法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">gcd</span>(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小公倍数-两数相乘-最大公约数">最小公倍数 = 两数相乘 / 最大公约数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求两个数的最大公约数</span></span><br><span class="line"><span class="comment"># 也可以调库 from math import gcd</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求两个数的最小公倍数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcm</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a * b // gcd(a, b)</span><br></pre></td></tr></table></figure><h2 id="公式法求欧拉函数">公式法求欧拉函数</h2><p>欧拉函数：在数论，对正整数n，欧拉函数是小于等于n的正整数中与n互质的数的数目。互质：互质是公约数只有1的两个整数，叫做互质整数。公约数只有1的两个自然数，叫做互质自然数，后者是前者的特殊情形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        <span class="type">int</span> res = a;</span><br><span class="line">        <span class="comment">// 试除法分解质因数</span></span><br><span class="line">        <span class="comment">// 欧拉公式fa(n) = N * p1 * (p1 - 1) * p2 * (p2 - 1)... * pn * (pn -1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; ++i) <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (a % i == <span class="number">0</span>)&#123;</span><br><span class="line">                res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛法求1-n内欧拉函数">线性筛法求1~n内欧拉函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])&#123; <span class="comment">// 是否为质数</span></span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>; <span class="comment">// 质数p的欧拉函数值为p-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线性筛法 关键在于利用了质数的欧拉函数的特性 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; ++j)&#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            <span class="comment">// 求质因子的i倍的欧拉函数值，且primes[j]必须是primes[j] * i 的最小质因子</span></span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)&#123;<span class="comment">// primes[j]是i的最小质因子</span></span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// primes[j]不是i的最小质因子</span></span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; ++i) res += euler[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_eulers</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="威尔逊定理">威尔逊定理</h2><p>若p为质数，则</p><p>p|(p-1)!+1</p><h2 id="欧拉定理和费马小定理">欧拉定理和费马小定理</h2><p>欧拉定理：若a与n互质，则<br>$$<br>a^{\phi(n)} \equiv  1\ (mod \  n)<br>$$<br>费马小定理：若p是质数，则对于任意整数a，有<br>$$<br>a^{p-1} \equiv 1\  ( mod \  p )<br>$$</p><p>欧拉定理的推论</p><ul class="lvl-0"><li class="lvl-2"><p>若正整数a，n互质，那么对于任意正整数b，有<br>$$<br>a<sup>b≡a</sup>{b\  mod\  \phi (n)}\ (mod\  n)<br>$$</p></li><li class="lvl-2"><p>有针对a，p互质的推论，不过我们直接说扩展的。即p为任意数。<br>$$<br>if ( b  &lt; \phi(p) ), a^b =  a^b\  (mod \  p)<br>$$<br>$$<br>if ( b &gt;= \phi(p) ), a^b = a^{b,  mod ,   \phi (p) \ +\  \phi(p)}\ (mod \  p )<br>$$</p></li></ul><h3 id="求逆元：">求逆元：</h3><p>当p为质数时，可以使用费马小定理和快速幂求逆元；当p不为质数时，要使用扩展欧几里得算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速幂求逆元</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="comment">// a^k % p 快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL) res * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL) a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="type">int</span> a, p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, &amp;a, &amp;p);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">qmi</span>(a, p<span class="number">-2</span>, p);<span class="comment">// p-2=0时比较特殊，一定返回1</span></span><br><span class="line">        <span class="keyword">if</span> (a % p) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);<span class="comment">// 要判断a与p是否互质</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂">快速幂</h2><p>在$O(logk)$复杂度内快速求出$ a^k \ mod \ p $的结果($ 1 \leq a, p, k \leq 10^9$)</p><p>将k用2的幂表示，预处理出$a<sup>{2</sup>i}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a^k % p</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p; <span class="comment">// 截取k的二进制表示中的最后一位</span></span><br><span class="line">        <span class="comment">// 按位与运算有两种典型用法，一是取一个位串信息的某几位，如以下代码截取x的最低7位：x &amp; 0177。二是让某变量保留某几位，其余位置0，如以下代码让x只保留最低6位：x = x &amp; 077。以上用法都先要设计好一个常数，该常数只有需要的位是1，不需要的位是0。用它与指定的位串信息按位与。</span></span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>; <span class="comment">// k右移除2</span></span><br><span class="line">        <span class="comment">//  右移运算将一个位串信息向右移指定的位，右端移出的位的信息被丢弃。例如12&gt;&gt;2,结果为3。与左移相反，对于小整数，每右移1位，相当于除以2</span></span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> a, k , p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;k, &amp;p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">qmi</span>(a, k ,p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="裴蜀定理">裴蜀定理</h2><p>对于任意正整数a,b，一定存在正整数x,y，使得ax + by = (a,b)，且其为a和b能表示出的最小的正整数。(a,b)表示a和b的最大公约数。x,y不唯一。</p><h2 id="扩展欧几里得算法">扩展欧几里得算法</h2><p>由(a,b) = (b,a % b)，则ap + bq = by + (a mod b)x = (a, b)。又$a \  mod\  b = a - \lfloor \frac{a}{b}\rfloor * b$，得公式：<br>$$a<em>x + b</em>(y - \lfloor\frac{a}{b}\rfloor * x) = (a , b)$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展欧几里得算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用递归法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="comment">// 边界：b=0时，可以找到一组特解：x = 1, y = 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x); <span class="comment">// 递归求最大公约数</span></span><br><span class="line">    y -= a / b * x;<span class="comment">// 利用公式更新y</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b ,x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用：求解线性同余方程">应用：求解线性同余方程</h3><p>线性同余方程：已知$a * x\equiv b \ (mod \  m) $，求x</p><p>该方程等价于存在整数y，使得$a * x = m * y + b$，即存在整除y’，使得$a<em>x+m</em>y’= b$。使用扩展欧几里得算法即可解决。</p><p>解题时，对题目中的代数式进行变形，对问题进行等价转换很重要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展欧几里得算法求解线性同余方程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展欧几里得算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a/ b * x;</span><br><span class="line">    <span class="keyword">return</span> d; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b ,x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">        <span class="type">int</span> d = exgcd(a, m, x, y);</span><br><span class="line">        <span class="keyword">if</span> (b % d) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(LL)x * (b / d) % m); <span class="comment">// 注意系数的变化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="中国剩余定理">中国剩余定理</h2><p><img src="https://mdpic.dreamgo.fun/img/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.png" alt="中国剩余定理"></p><p>对于一元线性同余方程组，不互为质数时要用扩展欧几里得算法</p><p>对于方程组：<br>$$<br>\begin{cases}<br>x = k_1 * a_1 + m_1 \\<br>x = k_2 * a_2 + m_2 \\<br>\end{cases}<br>$$<br>首先，可得$k_1 * a_1 + m_1 = k_2 * a_2 + m_2$，即$k_1<em>a_1 - k_2</em>a_2=m_2 - m_1$。由扩展欧几里得算法，其有解等价于$$(a_1,a_2) |m_2-m_1,\ \  (m_2-m_1整除a_1和a_2的最大公约数)$$通解为<br>$$<br>\begin{cases}<br>k_1 = k_1 + k_1 * \frac{a_1}{d} \\<br>k_2 = k_2 + k_2 * \frac{a_2}{d} \\<br>\end{cases}<br>$$</p><p>因而整理得<br>$$<br>x = a_1<em>k_1 + m_1 + k</em> \frac{a_1 * a_2} {d}<br>$$<br>即<br>$$<br>x = x_0 + k <em>a,\ \  其中x_0 = a_1</em>k_1 + m_1, \ a = \frac{a_1 * a_2} {d}<br>$$</p><p>按照以上过程，可以将方程组化为一个方程。此时$x \equiv x_0\ (mod\  a)$，x为最小正整数时，可解得<br>$$<br>x = x_0 \ mod\  a<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一元线性同余方程组非互质情况——扩展欧几里得算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展欧几里得算法</span></span><br><span class="line">LL <span class="title function_">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL&amp;y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL d = exgcd(b, a % b , y , x);</span><br><span class="line">    y -= a / b  * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="type">bool</span> has_answer = <span class="literal">true</span>;</span><br><span class="line">    LL a1, m1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a1 &gt;&gt; m1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i)&#123;</span><br><span class="line">        LL a2, m2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a2 &gt;&gt; m2;</span><br><span class="line"></span><br><span class="line">        LL k1, k2;</span><br><span class="line">        LL d = exgcd(a1, a2, k1, k2); <span class="comment">// 求出最大公约数</span></span><br><span class="line">        <span class="keyword">if</span> ((m2 - m1) % d) <span class="comment">// 判断是否可解</span></span><br><span class="line">        &#123;</span><br><span class="line">            has_answer = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k1 *= (m2 - m1) / d; <span class="comment">// 使k1变为 m2 - m1对应得系数</span></span><br><span class="line">        LL t = a2 / d; </span><br><span class="line">        k1 = (k1 % t + t) % t; <span class="comment">// 为防止溢出，要使k1最小</span></span><br><span class="line">        <span class="comment">// 注意(a % m + a) % m 得写法可应对负数问题，保证余数为非负</span></span><br><span class="line">        m1 = a1 * k1 + m1; </span><br><span class="line">        a1 = <span class="built_in">abs</span>(a1 / d * a2); <span class="comment">// 利用公式</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (has_answer)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (m1 % a1 + a1) % a1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="高斯消元">高斯消元</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gauss</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r= <span class="number">0</span>; c &lt; n; ++c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; ++i) <span class="comment">//找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">            t = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>; <span class="comment">// 为0的话就无需处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= n; ++j) swap(a[t][j], a[r][j]); <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; --j) a[r][j] /= a[r][c]; <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; ++i) <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;=c ; --j)</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        ++ r;<span class="comment">// 每次起始位置下移一行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) <span class="comment">// 从下往上消</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>;j &lt; n; ++j)</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; ++j)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = gauss();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &lt; eps) a[i][n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, a[i][n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="递归法求组合数">递归法求组合数</h2><p>利用组合数的性质之递推公式：<br>$$C^b_a = C^b_{a-1} + C^{b-1}_{a-1}$$<br>适用范围：$$10万组，1 \leq b \leq a\leq 2000$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先全部暴力递归求出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[ i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            <span class="comment">// 注意c[i-1][i]本是不存在的，但这里由于其值为0，且c[i][i]所=c[i-1][i-1]，所以不影响</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="通过预处理逆元的方式求组合数——预处理出阶乘">通过预处理逆元的方式求组合数——预处理出阶乘</h2><p>适用范围：<br>$$<br>1万，1\leq b \leq 10^5<br>$$<br>公式：<br>$$<br>C^b_a = fact[a] * infact[a - b] * infact[b]<br>$$<br>fact[a] = a! mod 1e9 + 7</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过预处理逆元的方式求组合数——预处理出阶乘</span></span><br><span class="line"><span class="comment">// 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]; 如果取模的数是质数，可以用费马小定理求逆元</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fact[N], infact[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂求逆元 涉及除法的求余要用逆元替代除法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// // 预处理所有阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL)infact[i - <span class="number">1</span>] * qmi(i, mod - <span class="number">2</span>, mod) % mod;<span class="comment">// 费马小定理要求mod为质数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(LL)fact[a] * infact[b] % mod * infact[a - b] % mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Lucas定理求组合数">Lucas定理求组合数</h2><p>若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：<br>$$<br>C^b_a\equiv C^{b, mod,p}<em>{a, mod, p} * C^{b/p}</em>{a/p}\ (mod \ p)<br>$$<br>适用于p取值范围较大又不太大，适用范围：<br>$$<br>10组，1 \leq b \leq a \leq10^{18}, 1\leq 10^5<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lucas定理求组合数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂求逆元</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL)a * a % p; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>  <span class="comment">// 当a和b都小于p时，通过最基础的求组合数的方法——组合数基本公式求组合数C(a, b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>;  <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; -- i, ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * i % p; <span class="comment">// 求(a - b + 1)!</span></span><br><span class="line">        y = (LL)y * j % p; <span class="comment">// 求b!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * (LL)qmi(y, p - <span class="number">2</span>) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lucas</span><span class="params">(LL a, LL b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> C(a, b);</span><br><span class="line">    <span class="keyword">return</span> (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;</span><br><span class="line">    <span class="comment">// b应该小于a，否则值为0.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lucas(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分解质因数法求组合数">分解质因数法求组合数</h2><p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：<br>1. 筛法求出范围内的所有质数<br>2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + …<br>3. 用高精度乘法将所有质因子相乘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分解质因数法求组合数 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解质因数</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];     <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_primes</span><span class="params">(<span class="type">int</span> n)</span>      <span class="comment">// 线性筛法求素数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; ++ j )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">// 使用最小质因子进行筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span>       <span class="comment">// 求n！中的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span>       <span class="comment">// 高精度乘低精度模板</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// 存储进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++ i)&#123;</span><br><span class="line">        t += a[i] * b; <span class="comment">// 当前位的值加上进位</span></span><br><span class="line">        c.push_back(t % <span class="number">10</span>); <span class="comment">// 只保留10的余数</span></span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//上移一位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    get_primes(a);  <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i )     <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = primes[i];</span><br><span class="line">        sum[i] = get(a, p) - get(b, p) - get(a - b, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    res.push_back(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; ++ i )     <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; ++ j )</span><br><span class="line">            res = mul(res, primes[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = res.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>; -- i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="卡特兰数">卡特兰数</h2><ul class="lvl-0"><li class="lvl-2"><p>卡特兰数（英语：Catalan number），又称卡塔兰数、明安图数，是组合数学中一种常出现于各种计数问题中的数列。</p></li><li class="lvl-2"><p>卡特兰数有以下公式：<br>$$C_{2n}^n + C^{n-1}<em>{2n} = \frac{1}{n+1}C^n</em>{n+1},\quad \ \frac{1}{n+1}C^n_{n+1}即为卡特兰数。$$</p></li><li class="lvl-2"><p>卡特兰数$C_n$满足以下递推关系：</p></li></ul><ol><li class="lvl-3"><p>$$C_{n + 1} = C_0C_n+C_1C_{n-1}+\cdots+C_nC_0$$</p></li><li class="lvl-3"><p>$$(n-3)C_n = \frac{n}{2}(C_3C_{n-1} + C_4C_{n-2}+C_5C_{n-3}+\cdots+C_{n-2}C_4+C_{n-1}C_3)$$</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求卡特兰数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k ,<span class="type">int</span> p)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用普通的组合数定义公式+逆元求组合数</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">2</span> * n, b = n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; -- i, ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">         res = (LL)res * i  % mod;</span><br><span class="line">         res = (LL)res * qmi(j, mod <span class="number">-2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (LL)res * qmi(n + <span class="number">1</span>, mod - <span class="number">2</span>, mod) % mod;<span class="comment">// 别忘了1/n+1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="容斥原理">容斥原理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容斥原理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++ i) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 容斥原理公式的$2^n-1$个项对应于$2^n-1$种选法，其中偶数个项的为正，奇数个项的为负</span></span><br><span class="line">    <span class="comment">// 使用位运算进行枚举，把i看成m位的二进制数</span></span><br><span class="line">    <span class="comment">// 1 &lt;&lt; m 表示1的二进制左移m位，当其再转换为十进制数时即表示$2^m$，注意这里i从1开始（至少选一项）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// t 表示当前所有质数的乘积</span></span><br><span class="line">        <span class="comment">// cnt 表示当前选法有几个项（对应于几个集合）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)&#123; </span><br><span class="line">            <span class="comment">// &gt;&gt;:将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0。</span></span><br><span class="line">            <span class="comment">// i &gt;&gt; j &amp; 1:i的二进制中，从右往左数，取第j+1位上的值</span></span><br><span class="line">                cnt ++;</span><br><span class="line">                <span class="keyword">if</span> ((LL)t * p[j] &gt; n)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = <span class="number">-1</span>; <span class="comment">// 说明此选法不成立</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                t *= p[j]; <span class="comment">// 对应于该选法中含有p[j]这一项</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 求倍数个数使用 n / t</span></span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span>) res += n / t;</span><br><span class="line">            <span class="keyword">else</span> res -= n / t;</span><br><span class="line">            <span class="comment">// 由项数就奇偶判断正负，偶数个项的为正，奇数个项的为负</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> t  = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt ++;</span><br><span class="line">                <span class="keyword">if</span> ((LL)t * p[j] &gt; n)&#123;</span><br><span class="line">                    t = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                t *= p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span>) res += n / t;</span><br><span class="line">            <span class="keyword">else</span> res -= n / t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="博弈论">博弈论</h2><h2 id="Nim游戏">Nim游戏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namesapce <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        res *=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合-Nim游戏">集合-Nim游戏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line">isng namespace <span class="built_in">std</span>;</span><br><span class="line">cosnt <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> s[N], f[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sg</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] != <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span> (itn i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = s[i];</span><br><span class="line">        <span class="keyword">if</span> ( x &gt;= sum) S.insert(sg(x - sum));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!S.coutn(i))</span><br><span class="line">            <span class="keyword">return</span> f[x] - i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) <span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        res *=sg(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课3 搜索与图论</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-3-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-3-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索与图论">搜索与图论</h1><h2 id="DFS-深度优先搜索">DFS 深度优先搜索</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">数据结构</th><th style="text-align:center">空间复杂度</th><th style="text-align:center">特性</th></tr></thead><tbody><tr><td style="text-align:center">DFS</td><td style="text-align:center">stack</td><td style="text-align:center">$O(h)$</td><td style="text-align:center">不具有“最短路”特性</td></tr><tr><td style="text-align:center">BFS</td><td style="text-align:center">queue</td><td style="text-align:center">$O(2^h)$</td><td style="text-align:center">具有“最短路”特性</td></tr></tbody></table><p>DFS俗称“暴搜”，思考问题时最重要的是想清楚<strong>搜索的顺序</strong>，要确定用什么样的顺序来把问题的所有方案全部遍历一遍比较方便。</p><p>每个DFS都对应一个搜索树，当比较难思考时，就从<strong>搜索树的角度</strong>来思考。通过画图可以帮助我们理解。</p><p>DFS是一种递归，不用将DFS和递归区分</p><p>DFS的两个重要概念是是回溯、剪枝</p><p>回溯是指从深层回退的过程，回溯时的关键是回溯时必须“恢复现场”，会到原有的状态。</p><p>算法思路比较奇怪的或对空间要求比较高的一般用DFS而不用BFS</p><p>深搜会一条路走到黑，往深层搜索。</p><p>深搜空间复杂度低的原因，是因为深搜只需要同时存储一条路径。</p><p>DFS+存储即记忆化搜索</p><h3 id="AcWing-842-排列数字"><a href="https://www.acwing.com/activity/content/problem/content/905/">AcWing 842. 排列数字</a></h3><p>本题的搜索顺序是对空着的位置从左到右一个一个填。第k层对应于第k个位置。限制条件是当前位填写的数不能和前面的数相同，可以使用标记数组记录好已经用过的数。</p><p>回溯使用系统栈实现。回溯时要考虑是否需要恢复现场，如果递归时状态发生改变，下一轮递归需要用到原状态，就要恢复现场。</p><p>每层递归中要遍历所有子节点，并对每个子节点进行递归深入。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230402151231043.png" alt="image-20230402151231043"></p><h4 id="朴素算法">朴素算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS——AcWing 842. 排列数字</span></span><br><span class="line"><span class="comment">// 搜索顺序：本题的搜索顺序是对空着的位置从左到右一个一个填。第k层对应于第k个位置。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N]; <span class="comment">// 存储路径</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="comment">// 传递u标记当前深度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)&#123; <span class="comment">// u == n时为叶子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; ++ i)</span><br><span class="line">    <span class="comment">// 遍历所有可能</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 进入递归前修改状态，标记已用过</span></span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 在从递归里出来后，即为回溯，要恢复现场</span></span><br><span class="line">            <span class="comment">// p[u]会被覆盖，因而不用恢复</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>); <span class="comment">// 从根节点开始</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化：使用状态压缩表示">优化：使用状态压缩表示</h4><p>组合问题的状态可以用二进制压缩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS + 状态压缩——AcWing 842. 排列数字</span></span><br><span class="line"><span class="comment">// 搜索顺序：本题的搜索顺序是对空着的位置从左到右一个一个填。第k层对应于第k个位置。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用state状态压缩，每一位表示对应的数是否被用过</span></span><br><span class="line">    <span class="comment">// 初始时state为0，表示没有任何数被选过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!(state &gt;&gt; i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="comment">// 取state的第i+1位，为i+1说明已经用过</span></span><br><span class="line">            path[u] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u +<span class="number">1</span>, state + ( <span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            <span class="comment">// 1 &lt;&lt; i 使第i + 1 位为1，也相当于求2^i</span></span><br><span class="line">            <span class="comment">// state加上 1 &lt;&lt; i即使state第i + 1位变为1</span></span><br><span class="line">            <span class="comment">// state的值没有变，因而回溯时不用恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-843-n-皇后问题"><a href="https://www.acwing.com/activity/content/problem/content/906/">AcWing 843. n-皇后问题</a></h3><h4 id="第一种搜索顺序：一个方格一个方格地搜索（先左后右，先上后下）">第一种搜索顺序：一个方格一个方格地搜索（先左后右，先上后下）</h4><p>需要注意约束条件，标记每一行、每一列、每一对角线是否存在皇后（是否能摆放）。</p><p>注意如何表示对角线: 注意到每条线的截距不同，因为可用截距来表示对角线，两侧的对角线分别用一个数组存。</p><ul class="lvl-0"><li class="lvl-2"><p><code>y = x + b </code>–&gt;<code> b = y - x</code> – &gt; <code>b = y - x + n</code><br>(由于数组下标不能为负数，所以增加一个偏移量n，仍满足一一对应)</p></li><li class="lvl-2"><p><code>y = -x + b</code> --&gt;<code> b = x + y</code></p></li></ul><p><img src="https://mdpic.dreamgo.fun/img/image-20230402153641062.png" alt="image-20230402153641062"></p><p>每层递归内部要枚举子节点的所有选择情况。</p><p>这种搜索顺序枚举了每个格子的两种可能状态，比较麻烦费时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS——AcWing 843. n-皇后问题</span></span><br><span class="line"><span class="comment">// 搜索顺序：一个方格一个方格地搜索（先左后右，先上后下）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N * <span class="number">2</span>], udg[N * <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 标记每一行、每一列、每一对角线是否存在皇后（是否能摆放）</span></span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y , <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; n) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( y == n) y = <span class="number">0</span>, x ++; <span class="comment">// 处理越界问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == n)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="comment">// 此方案中会枚举每个格子，所以在枚举时初始化即可，不用提前初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举当前格子的两种可能的选择状态</span></span><br><span class="line">    <span class="comment">// 不放皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放皇后，需判断可不可以</span></span><br><span class="line">    <span class="keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])&#123;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="comment">// 更新标记</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 回溯时要恢复现场</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种搜索顺序">第二种搜索顺序</h4><p>搜索顺序的选取和状态的选取是相关的，每个状态都对应一个节点，所有状态构成了搜索树。对于内部搜索问题，每个状态节点都对应于题目二维图中的真实方格。对于外部搜索为题，每个状态节点对应于通过操作变换的状态图中得到的状态。题目的限制条件除了显式的限制搜索顺序（如八连通、四连通等），还通过对合法状态的限制影响状态的选取和表示，并间接影响搜索顺序。这也可以理解成一种预先的可行性剪枝。</p><p>由题意，每一行最多只能放一个皇后且必须放一个皇后，因此可以将每行整体视为一个状态而不用一个一个方格取讨论。这时候对于每个状态，讨论的不再是每个方格是否放了皇后而是每行皇后放在第几个位置，状态只用记录当前行皇后所在列位置。这相当于按照全排列的思路进行搜索。因而只用按照行序一行一行进行搜索。此时按照约束枚举每一位的可能的值。将二维降成一维。</p><p>搜索树的每个节点对应于一个具体状态，每一层则对应一个抽象状态——即操作和讨论对象。</p><p>搜索时要注意剪枝。剪枝分为最优性剪枝和可行性剪枝，提前判断当前方案一定不是最优或一定不合法，直接回溯。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS——AcWing 843. n-皇后问题</span></span><br><span class="line"><span class="comment">// 搜索顺序：类似全排列的搜索思想，按照行序一行一行进行搜索</span></span><br><span class="line"><span class="comment">// 整体的搜索是一维，但每次具体的搜索也是一个一维枚举</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    <span class="comment">// 枚举所有子节点——枚举每行的位置所有选择情况</span></span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])&#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>; </span><br><span class="line">            <span class="comment">// 更新标记</span></span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>); </span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="comment">// 回溯时要恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="BFS-广（宽）度优先搜索">BFS 广（宽）度优先搜索</h2><p>BFS是一层一层来搜的，当<strong>图的路径权值相同</strong>时，<strong>BFS具有“最短路”特性</strong>（边权相同时才能用BFS求解最短路问题）。此时涉及最小步数、最短距离、最少操作次数的问题基本上都可以用BFS</p><p>dp问题和最短路问题是互通的，dp问题可以看成一种特殊的最短路问题，是没有环存在的最短路问题。</p><p>记忆化搜索即深搜+存储。</p><p>最短路问题包括用最短路算法求解的题，BFS求解的题，dp求解的题。</p><p>BFS的基本框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue &lt;- 初始状态（入队列）</span><br><span class="line"><span class="keyword">while</span> queue不空&#123;</span><br><span class="line">    取出队头</span><br><span class="line">    拓展队头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-844-走迷宫"><a href="https://www.acwing.com/problem/content/846/">AcWing 844. 走迷宫</a></h3><h4 id="自己手写队列">自己手写队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 844. 走迷宫</span></span><br><span class="line"><span class="comment">// 当图的路径权值相同时，BFS具有“最短路”特性。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存图（01状态）</span></span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">// 存到起点的距离</span></span><br><span class="line">PII q[N * N]; </span><br><span class="line"><span class="comment">// 入队列元素有两个属性x, y，注意元素总个数为N*N</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 分别标记队列要取出结点的位置，存取结点的前一个位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="comment">// 初始化为-1，可用于标记是否已经走过</span></span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 初始化起始点</span></span><br><span class="line"></span><br><span class="line">    q[++ tt] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">// 初始状态入队列</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="comment">// 常用技巧：使用偏移量表示向四个方向的移动</span></span><br><span class="line">    <span class="comment">// 本质上是用向量提前表示出所有移动方向，再枚举（因为移动方向是固定的）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt) <span class="comment">// 队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++]; <span class="comment">// 取出队头元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展队列元素</span></span><br><span class="line">        <span class="comment">// 枚举所有可能的移动方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            <span class="comment">// 要判断该点是否能走，是否已经被走过，是否越界了</span></span><br><span class="line">            <span class="keyword">if</span> (g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span> &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = &#123;x, y&#125;;</span><br><span class="line">                <span class="comment">// 更新状态并入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    q[++ tt] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span> &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp;  y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = &#123;x, y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i  = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span> &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m)&#123;</span><br><span class="line">                d[x][y] = d.[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = &#123;x, y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q[++ tt] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span> &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = &#123;x, y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS——内部搜索——AcWing 844. 走迷宫</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存图（01状态）</span></span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">// 存到起点的距离</span></span><br><span class="line">queue&lt;PII&gt; q; </span><br><span class="line"><span class="comment">// 入队列元素有两个属性x, y，注意元素总个数为N*N</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="comment">// 初始化为-1，可用于标记是否已经走过</span></span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 初始化起始点</span></span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">// 初始状态入队列</span></span><br><span class="line">    <span class="comment">// q.push(&#123;0, 0&#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="comment">// 常用技巧：使用偏移量表示向四个方向的移动</span></span><br><span class="line">    <span class="comment">// 本质上是用向量提前表示出所有移动方向，再枚举（因为移动方向是固定的）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) <span class="comment">// 队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); <span class="comment">// 取出队头元素</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展队列元素</span></span><br><span class="line">        <span class="comment">// 枚举所有可能的移动方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 要判断该点是否能走，是否已经被走过，是否越界了</span></span><br><span class="line">            <span class="keyword">if</span> (g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span> &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y));</span><br><span class="line">                <span class="comment">// 更新状态并入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-845-八数码"><a href="https://www.acwing.com/problem/content/847/">AcWing 845. 八数码</a></h3><p>本题是一个重点要掌握的外部搜索的的题。外部表示往往涉及状态表示和状态转移。</p><p>本题的两大难点：</p><ol><li class="lvl-3"><p>状态表示</p></li></ol><ul class="lvl-0"><li class="lvl-3"><p>如何把状态放到队列里</p></li><li class="lvl-3"><p>如何记录每个状态的距离</p></li></ul><ol start="2"><li class="lvl-3"><p>状态转移</p></li></ol><p>本题状态表示比较复杂，每个状态都是一个3 X 3的小矩阵。一种比较简单的方式是使用字符串来表示状态，将二维矩阵转化为一维字符串（展成一行）。入队时使用queue<string> queue，记录距离时使用哈希表unorrdered_map&lt;string, int&gt; dist。</p><p>在进行状态转移时，首先将字符串变回矩阵（可以是想象的），然后进行转移——枚举上下左右，最后将矩阵再变回字符串。</p><p>这里要用到一个常用技巧：二维坐标与一维坐标的转换。设矩阵大小为n X m，元素二维坐标为(x, y)(x为行号，y为列号)，一维坐标是k，则：$$x = k / n, y = k % n$$<br>$$ k = x * n + y$$</p><p>注意这里要求一维序列和二维矩阵都要从0开始计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS——外部搜索——AcWing 845. 八数码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;string&gt; q; <span class="comment">// 队列</span></span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; d; <span class="comment">// 存储距离的哈希表</span></span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(state); <span class="comment">// 初始状态入栈</span></span><br><span class="line">    d[state] = <span class="number">0</span>; <span class="comment">// 标记</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="comment">// 偏移量表示四种移动方向</span></span><br><span class="line"></span><br><span class="line">    string end = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    <span class="comment">// 终止状态</span></span><br><span class="line">    <span class="comment">// 注意使用字符串表示状态，将二维矩阵转化为一维来表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) <span class="comment">// 队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 注意t是字符串，用于表示状态</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 取出队头元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == end) <span class="keyword">return</span> d[t];</span><br><span class="line">        <span class="comment">// 判断是否为终止状态</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> distance = d[t];</span><br><span class="line">        <span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        <span class="comment">// 使用string的find函数找到x的一维坐标位置</span></span><br><span class="line">        <span class="type">int</span> x = k / <span class="number">3</span>, y = k % <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 转换二维矩阵中的二维坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所以移动方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">            <span class="comment">// 判断是否越界</span></span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">3</span> &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[a * <span class="number">3</span> + b], t[k]);</span><br><span class="line">                <span class="comment">// 求出待移动元素的一维坐标，并进行交换，得到新的状态</span></span><br><span class="line">                <span class="keyword">if</span> (!d.<span class="built_in">count</span>(t)) <span class="comment">// 判断是否被搜索过，使用map的count函数</span></span><br><span class="line">                &#123;</span><br><span class="line">                    d[t] = distance + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t);</span><br><span class="line">                    <span class="comment">// 入队</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(t[a * <span class="number">3</span> + b], t[k]);</span><br><span class="line">                <span class="comment">// 由于当前状态已被改变，需要恢复现场</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">2</span>];<span class="comment">// 应对空格和换行</span></span><br><span class="line"></span><br><span class="line">    string state; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        state += *s;</span><br><span class="line">        <span class="comment">// 注意这种读取string 的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(state) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树和图的存储">树和图的存储</h2><p>树是一种特殊的图，是无环连通图，与图的存储方式相同。对于无向图中的边<code>ab</code>，存储两条有向边<code>a-&gt;b</code>, <code>b-&gt;a</code>。因此我们可以只考虑有向图的存储。</p><p>有向图存储：</p><ol><li class="lvl-3"><p>邻接矩阵：开个二维数组，<code>g[a, b]</code>存储是否有边或边权，适合稠密图不能存储重边，空间复杂度为$O(N^2)$</p></li><li class="lvl-3"><p>邻接表：头结点数组 + n个单链表每个节点都对应一个单链表，单链表中存储当前结点直接指向的所有结点（有边），顺序可任意</p></li></ol><p><img src="https://mdpic.dreamgo.fun/img/image-20230402161436289.png" alt="image-20230402161436289"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="comment">// 插入时一般直接插入头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树和图的深度优先遍历">树和图的深度优先遍历</h2><p>注意树和图的深度优先和宽度优先搜索对于每个节点都只会搜索一层，需要标记。</p><p>时间复杂度$O(n+m)$， $n$ 表示点数，$m$ 表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line">    <span class="comment">// 递归的过程就是入栈的过程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出结点的值</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树的深度优先遍历的一大优点是<strong>能够可以算出每个子树的大小</strong></p><h3 id="AcWing-846-树的重心"><a href="https://www.acwing.com/activity/content/code/content/47105/">AcWing 846. 树的重心</a></h3><p>本题的难点在于充分研究连通块，挖掘其性质和规律，并由此确定搜索的顺序。这种涉及复杂思路的问题显然一般用DFS。</p><p>经研究，我们发现删除某节点后，其父节点往上的部分会做成一个连通块，以其子节点为根节点的子树会各自形成一个连通块。而父节点往上的部分又等于总结点数减去以当前结点为根节点的子树的所有节点数，即等于以当前结点子节点为根节点的所有子树结点数加1。</p><p>由此我们只需要计算每个结点子节点为根节点的子树各自的结点数即可。</p><p>考虑到DFS会按路径遍历，且从叶子节点递归回溯时可以求出路径上的结点数，故采用DFS遍历树。</p><p><strong>树的深度优先遍历可以算出每个子树的大小</strong>，这得益于深度优先遍历会一个一个子树地遍历。</p><p>深度优先遍历的一个重点是在递归的过程中传递和存储信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS遍历树和图——AcWing 846. 树的重心</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = N * <span class="number">2</span>; </span><br><span class="line"><span class="comment">// 注意无向边需要两倍的空间</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;  <span class="comment">// 邻接表</span></span><br><span class="line"><span class="type">int</span> ans = N; <span class="comment">// 存储结果：各个连通块中点数的最大值的最小值</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 标记是否走过，防止从子节点走到父节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的存储</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">    <span class="comment">// 插入到头节点之后</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; </span><br><span class="line">    <span class="comment">// 递归即入栈，要进行标记</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里也是边界条件，即当结点为叶节点时，size = 0, sum = 1（返回的是sum + 1）</span></span><br><span class="line">    <span class="comment">// 注意从递归的角度理解dfs的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[j]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">dfs</span>(j); </span><br><span class="line">        <span class="comment">// 深入搜索，</span></span><br><span class="line">        <span class="comment">// 递归后更新相关量</span></span><br><span class="line">        <span class="comment">// s为以子节点为根节点的所有子树中结点数</span></span><br><span class="line">        size = <span class="built_in">max</span>(size, s);</span><br><span class="line">        <span class="comment">// size保留以子节点为根节点的所有子树中结点数最大者</span></span><br><span class="line">        <span class="comment">// 即断开本结点后，各子节点所在各个连通块中点数的最大值</span></span><br><span class="line">        sum += s;</span><br><span class="line">        <span class="comment">// sum计算以当前结点为根节点的子树的所有结点数，但不包括根节点自身</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    size = <span class="built_in">max</span>(size, n - sum - <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, size); <span class="comment">// 更新各个连通块中点数的最大值的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum + <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 返回以当前结点为根节点的子树的结点数，注意包括自身结点</span></span><br><span class="line">    <span class="comment">// 叶子节点时返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">// 注意对头节点数组初始化为-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对图进行存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">        <span class="comment">// 注意对于无向图要添加双向边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);<span class="comment">// 注意题目中结点的值至少为1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题目边的方向是不确定的，所以还是需要将两个方向的边都建出来。在输入时，由于我们并不能确定DFS时搜索的方向，因此两个方向都需要创建出来。否则如果我们从1号点开始搜，但是建立边的时候，选择的方向是 2 -&gt; 1，那么在DFS时就搜索不到2号点了。</p><p>在遍历一棵树的时候，即使是无向边，也可以将st[]数组去掉，只需要在dfs时传入父节点这个参数就可以了，这样就可以避免重新搜回父节点。</p><p>只要题目指明了父子关系，就可以省略st[]数组。无向树当根节点确定之后，每条边就有了方向，另一个方向就被忽略掉了。如果出现子节点循环到了父节点，会直接contine，不会再次访问到父节点从而出现死循环的。</p><h2 id="树和图的广度优先遍历">树和图的广度优先遍历</h2><p>注意树和图的深度优先和宽度优先搜索对于每个节点都只会搜索一层，需要标记。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 初始状态入队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="comment">// 取出队头</span></span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展队头——拓展当前节点t的所有相邻点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">// 取出结点的值</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            更新信息， 如d[x] = d[t] + <span class="number">1</span></span><br><span class="line">            q.<span class="built_in">push</span>(j); <span class="comment">// 节点入队</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-847-图中点的层次"><a href="https://www.acwing.com/problem/content/849/">AcWing 847. 图中点的层次</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS遍历树和图AcWing 847. 图中点的层次</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    </span><br><span class="line">    q[++ tt] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始状态入队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        <span class="comment">// 取出队头</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">// 遍历所有子节点，拓展队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (j == n) <span class="keyword">break</span>;</span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑序列">拓扑序列</h3><p>拓扑序列是针对有向无环 图而言的。</p><p>对一个<strong>有向无环图</strong>(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边$&lt;u,v&gt;∈E(G)$，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，<strong>由某个集合上的一个偏序得到该集合上的一个全序</strong>，这个操作称之为拓扑排序。</p><p>由AOV网构造出拓扑序列的实际意义是：如果按照拓扑序列中的顶点次序，在开始每一项活动时，能够<strong>保证它的所有前驱活动都已完成</strong>，从而使整个工程顺序进行，不会出现冲突的情况。</p><p>一个有向无环图至少存在一个入度为0的结点（指向该节点的边数为0）。可简单用反证法和抽屉原理证明。</p><p>因而<strong>有向无环图一定存在拓扑序列</strong>，称为拓扑图。<strong>不是有向无环图的一定不存在拓扑序列</strong>，因而<strong>拓扑排序也用来判断一个图是否存在环</strong>。</p><h4 id="算法">算法</h4><p>由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。</p><ol><li class="lvl-3"><p>先拿出所有入度为0的点入队</p></li><li class="lvl-3"><p>在原图中将它们删除此顶点及所有出边。改变子节点的度数。循环结束后，若输出的顶点数小于网中的顶点数，则输出“有回路”信息，否则输出的顶点序列就是一种拓扑序列。</p></li></ol><p>拓扑序列不唯一。有时会要求输出字典序最小的方案，这时把queue改成priority_queue即可</p><p>所有边都是从前指向后的。</p><p>求有向图的拓扑序的图的<strong>宽度优先遍历的经典应用</strong>，使用BFS实现</p><p>时间复杂度 $O(n+m)$, n表示点数，m表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// tt分别表示存入结点的前一个位置</span></span><br><span class="line">    <span class="comment">// hh表示取出结点的位置</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 初始状态入队列——入度数为零的结点全部入队</span></span><br><span class="line">    <span class="comment">// 需预先求出所有点的入度，d[i] 存储点i的入度，在存边时直接更新即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!d[i]) </span><br><span class="line">            q[ ++ tt] = i; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="type">int</span> t = q[hh ++]; </span><br><span class="line">        <span class="comment">// 取出队头结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展队列中存入的结点</span></span><br><span class="line">        <span class="comment">// 枚举节点t的所有出边（相邻节点）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];<span class="comment">// 取出结点的值</span></span><br><span class="line">            <span class="comment">// 更新入度数——删除父节点——所有相邻节点度数减一</span></span><br><span class="line">            d[j]--;</span><br><span class="line">            <span class="comment">// 度数为零则存入队列</span></span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">0</span>) </span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-848-有向图的拓扑序列"><a href="https://www.acwing.com/activity/content/code/content/47106/">AcWing 848. 有向图的拓扑序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序——AcWing 848. 有向图的拓扑序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;<span class="comment">// 邻接表</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储入度</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// tt分别表示存入结点的前一个位置</span></span><br><span class="line">    <span class="comment">// hh表示取出结点的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!d[i]) </span><br><span class="line">            q[ ++ tt] = i; </span><br><span class="line">        <span class="comment">// 初始状态入队列</span></span><br><span class="line">        <span class="comment">// 入度数为零的结点全部入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="type">int</span> t = q[hh ++]; </span><br><span class="line">        <span class="comment">// 取出队头结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展队列中存入的结点</span></span><br><span class="line">        <span class="comment">// 枚举子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];<span class="comment">// 取出结点的值</span></span><br><span class="line">            d[j]--;</span><br><span class="line">            <span class="keyword">if</span> (d[j] == <span class="number">0</span>) </span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">            <span class="comment">// 先删除父节点（子节点度数减一）</span></span><br><span class="line">            <span class="comment">// 度数为零则存入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b); <span class="comment">// 添加边</span></span><br><span class="line">        ++ d[b]; <span class="comment">// 更新入度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">topsort</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路问题">最短路问题</h2><p>常见的最短路问题可分为两大类：</p><ol><li class="lvl-3"><p>单源最短路问题求从一个点到其他所有点的最短距离。可以分为两类</p><ul class="lvl-2"><li class="lvl-5">所有边的权重都是正数常用算法：<ul class="lvl-4"><li class="lvl-7">朴素Dijkstra算法：$O(n^2)$，时间复杂度与边数无关，适用于稠密图。基于贪心</li><li class="lvl-7">堆优化版的Dijkstra算法：$O(mlogn)$，适用于稀疏图(如n和m相同数量级时，<code>n</code>表示点数，<code>m</code>表示边数)</li></ul></li><li class="lvl-5">存在权重为负的边常用算法:<ul class="lvl-4"><li class="lvl-7">Bellman-Ford算法: $O(nm)$，基于离散数学知识</li><li class="lvl-7">SPFA算法：平均复杂度为$O(m)$，最坏复杂度为$O(nm)$<br>SPFA算法是对Bellman-Ford算法的优化，一般效率更高，但有些情况下无法使用，如对最短路经过的边数进行限制<code>m &lt;= k</code>等时，只能用Bellman-Ford。</li></ul></li></ul></li><li class="lvl-3"><p>多源汇最短路源指源点，即起点。汇指汇点，即终点。多源汇即多个起点和终点。多源汇最短路问题会有多个询问，每次起点和终点不同，求最短距离。常用算法：</p><ul class="lvl-2"><li class="lvl-6">Floyd算法：时间复杂度为$O(n^3)$，基于动态规划</li></ul></li></ol><p>最短路问题的侧重点和难点在于<strong>建图</strong>，<strong>如何定义点和边，把原问题抽象成最短路问题</strong>，套用什么模板来做。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230402173115379.png" alt="image-20230402173115379"></p><h3 id="朴素Dijkstra算法">朴素Dijkstra算法</h3><p>稠密图用邻接矩阵来存</p><p>时间复杂是 $O(n^2+m)$, $n$表示点数，$m$表示边数</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230402174808904.png" alt="image-20230402174808904"></p><p><img src="https://mdpic.dreamgo.fun/img/image-20230402180923011.png" alt="image-20230402180923011"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="comment">// 稠密图用邻接矩阵来存</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 最初将所有点距离初始为无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">// 起点到本身的距离为0</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意：st[1] = true; 这句代码不能写，否则后面执行会出问题；需要用起点去更新和它连通的点的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代n次，求出所有点到起点的最短距离</span></span><br><span class="line">    <span class="comment">// 每次都确定一个点t到起点的最短距离，执行n-1次即可求出所有点到起点的最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="comment">// 遍历剩余所有点，在还未确定最短路的点中，寻找到起点距离最小的点，并求出其到起点的最短距离</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">            <span class="comment">// 注意这里巧妙地利用了“短路特性”，t == -1时dist[t] &gt; dist[j]不会执行，从而会读取第一个没确定的点，而不用提前赋值</span></span><br><span class="line">                t = j;</span><br><span class="line">    <span class="comment">// if (t == n) break;</span></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="AcWing-849-Dijkstra求最短路-I"><a href="https://www.acwing.com/problem/content/851/">AcWing 849. Dijkstra求最短路 I</a></h3><p>最短路问题中重边只保留最短的边，自环则直接删掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单源最短路问题——朴素dijkstra算法——AcWing 849. Dijkstra求最短路 I  </span></span><br><span class="line"><span class="comment">// 所有边的权重都是正数，稠密图，使用朴素dijkstra算法，时间复杂度为O(n^2+m)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="comment">// 稠密图用邻接矩阵来存</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">// 最初将所有点距离初始为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 到本身的距离为0</span></span><br><span class="line">    <span class="comment">// 注意：st[1] = true;这句代码不能写，否则后面执行会出问题；需要用起点去更新和它连通的点的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代n次，求出所有点到起点的最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     </span><br><span class="line">        <span class="comment">// 在还未确定最短路的点中，寻找到起点距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">            <span class="comment">// 注意这里巧妙地利用了“短路特性”，t == -1时dist[t] &gt; dist[j]不会执行，从而会读取第一个没确定的点，而不用提前赋值</span></span><br><span class="line">                t = j;</span><br><span class="line">        <span class="comment">// if (t == n) break;</span></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// dijkstra算法每次循环都能确定一个最短点，此点后续不用再更新</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m ;++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], w);</span><br><span class="line">        <span class="comment">// 重边只保留最短的边，自环则直接删掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># 为了处理重边问题，先初始化为无穷大</span></span><br><span class="line">    g = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dijkstra</span>():</span><br><span class="line">        d = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">        d[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        st = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            t = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> st <span class="keyword">and</span> (t == -<span class="number">1</span> <span class="keyword">or</span> d[i] &lt; d[t]):</span><br><span class="line">                    t = i</span><br><span class="line">            st.add(t)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                d[i] = <span class="built_in">min</span>(d[i], d[t] + g[t][i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> d[-<span class="number">1</span>] <span class="keyword">if</span> d[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a, b, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], w)</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(dijkstra())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="堆优化版的Dijkstra算法">堆优化版的Dijkstra算法</h3><p>时间复杂度  $O(mlogn)$, $n$表示点数，$m$表示边数。适用于稀疏图，使用邻接表存储。</p><p>朴素版Dijkstra需要遍历所有点来找剩余点中到起点距离最小的点，这一步可以用堆来优化。</p><p>注意直接使用STL优先队列时，优先队列中不支持修改/删除任意元素，因此每次直接插入新的数而不进行删除，堆中会存在冗余，堆中可能存在个元素，导致复杂度变为$ O(mlogm) $ 。且需要判重。手写堆则不会出现这种状况（可以删除任意节点），保证堆中至多存在n个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="comment">// 存储距离和节点编号，之所以存储编号是因为在堆中不存储则无法获知</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    <span class="comment">// 使用堆进行优化，维护距离最短的点，避免了循环搜索</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); </span><br><span class="line">    <span class="comment">// 初始状态入堆    </span></span><br><span class="line">    <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())&#123; <span class="comment">// 堆不为空</span></span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 每次取出到起点距离最短的点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 已经确定就不用再求了（</span></span><br><span class="line">        <span class="comment">// 用来处理多次迭代中重复入堆，产生冗余的情况，以及有重边的情况</span></span><br><span class="line">        </span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])&#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                <span class="comment">// 用当前点更新其他点</span></span><br><span class="line">                <span class="comment">// 注意w是和邻接表一起存的，因为下标是i不是j</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">                <span class="comment">// 更新后要入堆，更新说明还没确定，不更新则说明已经确定了</span></span><br><span class="line">                <span class="comment">// 会在多次迭代中重复入堆，产生冗余</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-850-Dijkstra求最短路-II"><a href="https://www.acwing.com/problem/content/852/">AcWing 850. Dijkstra求最短路 II</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单源最短路问题——堆优化版dijkstra算法——AcWing 850. Dijkstra求最短路 II</span></span><br><span class="line"><span class="comment">// 所有边的权重都是正数，稀疏图，使用堆优化版dijkstra算法，时间复杂度为O(mlogn)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">150010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="comment">// 存储距离和节点编号，之所以存储编号是因为在堆中不存储则无法获知</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    <span class="comment">// 使用堆进行优化，维护距离最短的点，避免了循环搜索</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); </span><br><span class="line">    <span class="comment">// 初始状态入堆    </span></span><br><span class="line">    <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())&#123; <span class="comment">// 堆不为空</span></span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 每次取出到起点距离最短的点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 已经确定就不用再求了（</span></span><br><span class="line">        <span class="comment">// 用来处理多次迭代中重复入堆，产生冗余的情况，以及有重边的情况</span></span><br><span class="line">        </span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])&#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                <span class="comment">// 用当前点更新其他点</span></span><br><span class="line">                <span class="comment">// 注意w是和邻接表一起存的，因为下标是i不是j</span></span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">                <span class="comment">// 更新后要入堆，更新说明还没确定，不更新则说明已经确定了</span></span><br><span class="line">                <span class="comment">// 会在多次迭代中重复入堆，产生冗余</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp; b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dijkstra</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-2">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    head = [-<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    e = [<span class="number">0</span>] * m</span><br><span class="line">    ne = [<span class="number">0</span>] * m</span><br><span class="line">    w = [<span class="number">0</span>] * m</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    st = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> idx</span><br><span class="line">        e[idx] = b</span><br><span class="line">        w[idx] = c</span><br><span class="line">        ne[idx] = head[a]</span><br><span class="line">        head[a] = idx</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dijksta</span>():</span><br><span class="line">        d = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        d[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        heap = []</span><br><span class="line">        heapq.heappush(heap, (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            dist, node = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> st:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            st.add(node)</span><br><span class="line">            </span><br><span class="line">            i = head[node]</span><br><span class="line">            <span class="keyword">while</span> i != -<span class="number">1</span>:</span><br><span class="line">                j = e[i]</span><br><span class="line">                <span class="keyword">if</span> d[j] &gt; dist + w[i]:</span><br><span class="line">                    d[j] = dist + w[i]</span><br><span class="line">                    heapq.heappush(heap, (d[j], j))</span><br><span class="line">                i = ne[i]</span><br><span class="line">        <span class="keyword">if</span> d[-<span class="number">1</span>] == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(d[-<span class="number">1</span>])</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        add(a, b, c)</span><br><span class="line">    dijksta()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="Python-3">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># More Pythonic code:</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph = defaultdict(<span class="keyword">lambda</span>: defaultdict(<span class="keyword">lambda</span>: <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)))</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a, b, weight = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        graph[a][b] = <span class="built_in">min</span>(graph[a][b], weight)</span><br><span class="line">    dist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n+<span class="number">1</span>)</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    heap = []</span><br><span class="line">    heappush(heap, (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    set_min = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        d, node = heappop(heap)</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> set_min:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        set_min.add(node)</span><br><span class="line">        <span class="keyword">for</span> adj_v <span class="keyword">in</span> graph[node]:</span><br><span class="line">            <span class="keyword">if</span> dist[adj_v] &gt; d + graph[node][adj_v]:</span><br><span class="line">                dist[adj_v] = d + graph[node][adj_v]</span><br><span class="line">                heappush(heap, (dist[adj_v], adj_v))</span><br><span class="line"></span><br><span class="line">    res =  dist[-<span class="number">1</span>] <span class="keyword">if</span> dist[-<span class="number">1</span>] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford算法">Bellman-Ford算法</h3><p>用于求带负权边的最短路问题。使用两重循环进行求解，不用显式存储整个图，只用把每个边及两端点存储即可。</p><p>求最短路问题的图中不能有负权回路，当存在负权回路时，会出现死循环，不存在最短路径（最短路径负无穷）。</p><p>Bellman-Ford算法可用来判断是否存在负权回路，如果当<strong>迭代n次后还有更新</strong>，由抽屉原理，<strong>说明存在负权回路</strong>。第k次迭代含义是从起点经过不超过k条边走到每个点的最短距离，n次迭代还有更新说明有路径存在n条边n+1个节点，说明有负权回路。</p><p>虽然Bellman-Ford算法可以判断负权回路，但复杂度比较高，因此一般不用此算法而是用SPFA算法判断负环。</p><p>对于有边数限制的最短路问题，只能用Bellman-Ford算法，而不能用SPFA算法。</p><p>时间复杂度 $O(nm)$, n表示点数，m表示边数</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230402234558495.png" alt="image-20230402234558495"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="comment">// 由于算法中只涉及边的两个端点和边权，只关心每条边，而不涉及图的路径问题，所以可以直接用结构体存边即可，不需要关心边之间的联系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">// 最初将所有点距离初始为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于我们只给出了起点的距离值dist[1]，其余都为无穷大，因而第i次迭代时都会更新到起点距离为i条边的所有结点</span></span><br><span class="line">    <span class="comment">// 所以迭代k次即可求出从起点点到任意点的最多经过 k 条边的最短距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代n-1次后即可求出任意点到起点最多经过n-1条边的最短距离。此时只要1和n是连通的，且路径上不存在负权回路，一定能求出两者间最短距离</span></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代n次，表示最多经过n条边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i )&#123; </span><br><span class="line">        <span class="comment">// 枚举所有边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j )&#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="comment">// 每次更新所有边的尾端的距离</span></span><br><span class="line">            <span class="comment">// 如果距离大于就更新</span></span><br><span class="line">            <span class="comment">// 跟新的过程称为松弛操作</span></span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代n * m次，即得到起点到所有点的最短距离</span></span><br><span class="line">    <span class="comment">// 循环完后，对所有的边都满足dist[b] &lt;= dist[a] + w，称为三角不等式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除以2的原因:</span></span><br><span class="line">    <span class="comment">// bellman_ford算法会对所有边都尝试进行更新，而由于图中存在负边，就可能出现一种情况——边的两端都是正无穷（距离起点无限远，不连通），但由于是负边，也会对尾端的正无穷进行更新，使其值减小</span></span><br><span class="line">    <span class="comment">// 而本题中由于数据范围k &lt; 500，边权的绝对值 &lt; 10000，所以正无穷至多减小5e6，</span></span><br><span class="line">    <span class="comment">// 因而除2即可保证识别出并连通的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-853-有边数限制的最短路"><a href="https://www.acwing.com/problem/content/855/">AcWing 853. 有边数限制的最短路</a></h3><p>本题因为有步数限制，所以即使有负权回路也会存在最短路径。所以可以使用Bellman-Ford算法，但有负环一定不能用SFPA算法</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230404162303138.png" alt="image-20230404162303138"></p><p>串联问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单源最短路径——bellman_ford算法——AcWing 853. 有边数限制的最短路</span></span><br><span class="line"><span class="comment">// 存在负权边，对边数有限制时，使用bellman_ford算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;<span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N], backup[N]; <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"><span class="comment">// backup用于备份上一次迭代时的所有dist</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;<span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="comment">// 由于算法中只涉及边的两个端点和边权，只关心每条边，而不涉及图的路径问题，所以可以直接用结构体存边即可，不需要关心边之间的联系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">// 最初将所有点距离初始为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有结点</span></span><br><span class="line">    <span class="comment">// 由于我们只给出了起点的距离值dist[1]，其余都为无穷大，因而第i次迭代时都会更新到起点距离为i条边的所有结点</span></span><br><span class="line">    <span class="comment">// 所以迭代k次即可求出从起点点到任意点的最多经过 k 条边的最短距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代n-1次后即可求出任意点到起点最多经过n-1条边的最短距离。此时只要1和n是连通的，且路径上不存在负权回路，一定能求出两者间最短距离</span></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代k次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i )&#123; </span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist); <span class="comment">// 之所以进行备份是为了防止出现更新的串联</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虽然要求距离只能小于k条边（更新小于k次）但可能出现其他点在上一次迭代时已经更新了距离（每次迭代至少更新步长增加1的结点，但可能会更新更远的点，是更短的路径，但不满足步长限制）</span></span><br><span class="line">        <span class="comment">// 如1连接了2和3，边权分别为1、3，2也连接了3，边权为1，限制步长为1，则只能1-&gt;3。但由于会枚举所有边，所以在一次迭代中可能会多次更新，如1更新完2后，2又用更新完的距离去更新3</span></span><br><span class="line">        <span class="comment">// 为了防止这种多次更新的问题，我们就不直接使用dist()来更新，而是用迭代前的备份来更新，保证至多更新一步。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了满足边数的限制，必须保证每次迭代，各点都从上一轮直接相连的点的基础上更新，避免串联问题。为此更新时使用备份的上一轮的距离</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j )&#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="comment">// 每次更新所有边的尾端的距离</span></span><br><span class="line">            <span class="comment">// 如果距离大于就更新</span></span><br><span class="line">            <span class="comment">// 跟新的过程称为松弛操作</span></span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + w);</span><br><span class="line">            <span class="comment">//backup[a]使更新后的dist[a]不会对dsit[b]产生影响，保证至多更新一步。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代n * m次，即得到起点到所有点的最短距离</span></span><br><span class="line">    <span class="comment">// 循环完后，对所有的边都满足dist[b] &lt;= dist[a] + w，称为三角不等式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 除以2的原因:</span></span><br><span class="line">    <span class="comment">// bellman_ford算法会对所有边都尝试进行更新，而由于图中存在负边，就可能出现一种情况——边的两端都是正无穷（距离起点无限远，不连通），但由于是负边，也会对尾端的正无穷进行更新，使其值减小</span></span><br><span class="line">    <span class="comment">// 而本题中由于数据范围k &lt; 500，边权的绝对值 &lt; 10000，所以正无穷至多减小5e6，</span></span><br><span class="line">    <span class="comment">// 因而除2即可保证识别出并连通的情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-4">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    edge = []</span><br><span class="line">    dist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Ballman_Ford</span>():</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            back_up = dist.copy()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                a, b, w = edge[j]</span><br><span class="line">                dist[b] = <span class="built_in">min</span>(dist[b], back_up[a] + w)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> back_up == dist:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> dist[n] == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;impossible&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dist[n]</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a, b, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        edge.append([a, b, w])</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(Ballman_Ford())</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="SPFA-算法">SPFA 算法</h3><p>时间复杂度 平均情况下 $O(m)$，最坏情况下 $O(nm)$，$n$表示点数，$m$表示边数</p><p>SPFA算法使用队列优化Bellman-Ford算法。Bellman-Ford算法每次循环会尝试更新所有节点，但实际上只有上一轮被更新过的节点才会更新其他相邻点的距离，二没有更新过的节点不会更新其他相邻点。基于这一点，使用队列存储所有这一轮被更新的节点，并每次从队列<strong>取出已被更新的节点用于更新其他点</strong>。因此需要标记每个节点是否在队列中，初始时起点入队。</p><p>一定不能用于有负环的问题，也不能用于有边数限制的问题。</p><p>可以用于判断是否存在负环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n; <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">// 最初将所有点距离初始为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 使用队列进行优化</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 初始状态入队列——先放入起点</span></span><br><span class="line">    <span class="comment">// 队列中存储用来更新其他结点的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 取出队头元素</span></span><br><span class="line">        st[t] = <span class="literal">false</span>; <span class="comment">// 标记是否在队列中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举子节点，拓展队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="comment">// 用当前节点距离更新子节点距离</span></span><br><span class="line">                <span class="comment">// 注意w是和邻接表一起存的，因为下标是i不是j</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])&#123;   </span><br><span class="line">                <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 只有被更新过的结点才会入队</span></span><br><span class="line">                    <span class="comment">// 避免了无效的遍历和更新</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-851-spfa求最短路"><a href="https://www.acwing.com/activity/content/code/content/48498/">AcWing 851. spfa求最短路</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spfa算法——AcWing 851. spfa求最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a] , h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">// 最初将所有点距离初始为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 使用队列进行优化</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 初始状态入队列</span></span><br><span class="line">    <span class="comment">// 队列中存储用来更新其他结点的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 取出队头元素</span></span><br><span class="line"> </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举子节点，拓展队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="comment">// 用当前节点距离更新子节点距离</span></span><br><span class="line">                <span class="comment">// 注意w是和邻接表一起存的，因为下标是i不是j</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])&#123;    </span><br><span class="line">                <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 只有被更新过的结点才会入队</span></span><br><span class="line">                    <span class="comment">// 避免了无效的遍历和更新</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m;++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    <span class="comment">// 这个不需要因为队列里都是由起点更新到的点，不存在bellman-ford算法中未更新的点同样被边更新的情况。</span></span><br><span class="line">    <span class="comment">// spfa遵循了一个拓扑顺序，而bellman-ford算法没有</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-5">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    dist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    head = [-<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    e = [<span class="number">0</span>] * m</span><br><span class="line">    ne = [<span class="number">0</span>] * m</span><br><span class="line">    w = [<span class="number">0</span>] * m</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    st  = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> idx</span><br><span class="line">        e[idx] = b</span><br><span class="line">        w[idx] = c</span><br><span class="line">        ne[idx] = head[a]</span><br><span class="line">        head[a] = idx</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spfa</span>():</span><br><span class="line">        q= deque()</span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        q.append(<span class="number">1</span>)</span><br><span class="line">        st[<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            t = q.popleft()</span><br><span class="line">            st[t] = <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            i = head[t]</span><br><span class="line">            <span class="keyword">while</span> i != -<span class="number">1</span>:</span><br><span class="line">                j = e[i]</span><br><span class="line">                <span class="keyword">if</span> dist[j] &gt; dist[t] + w[i]:</span><br><span class="line">                    dist[j] = dist[t] + w[i]</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> st[j]:</span><br><span class="line">                        st[j] = <span class="literal">True</span></span><br><span class="line">                        q.append(j)</span><br><span class="line">                i = ne[i]</span><br><span class="line">        <span class="keyword">if</span> dist[n] == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;impossible&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dist[n]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        add(a, b, c)</span><br><span class="line">    <span class="built_in">print</span>(spfa())</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="SPFA判断图中是否存在负环">SPFA判断图中是否存在负环</h3><p>时间复杂度是$O(nm)$, n表示点数，m表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;<span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];<span class="comment">// dist[x]存储1号点到x的最短距离</span></span><br><span class="line"><span class="comment">// cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组（默认为0），因为有负权边和负环的化一定会更新相关路径</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在负环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 全部入队</span></span><br><span class="line">        <span class="comment">// 环可能在任意结点间的路径里，要遍历所有点作为起点的情况</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 取出队头</span></span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="comment">// 更新距离</span></span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>; <span class="comment">// 主要不是自身加1，而是在前一个点基础上加1</span></span><br><span class="line">                <span class="comment">// 更新路径结点数</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 入队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-852-spfa判断负环"><a href="https://www.acwing.com/problem/content/description/854/">AcWing 852. spfa判断负环</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spfa算法判断图中是否存在负环——AcWing 852. spfa判断负环</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[M], e[M], ne[M], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];<span class="comment">// dist[x]存储1号点到x的最短距离</span></span><br><span class="line"><span class="comment">// cnt[x]存储1到x的最短路中经过的边数，当边数为n时说明经过n+1个点，说明有负环</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组（默认为0），因为有负权边和负环的化一定会更新相关路径</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在负环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 全部入队</span></span><br><span class="line">        <span class="comment">// 环可能在任意结点间的路径里，而不一定与起点连通，要遍历所有点作为起点的情况</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 取出队头</span></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="comment">// 更新距离</span></span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 更新路径结点数</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 入队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-6">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    d = [<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="comment"># 注意不要初始化为负无穷，因为判断的是有无负环，而不是求绝对距离</span></span><br><span class="line">    <span class="comment"># 要初始化为0，保证可更新</span></span><br><span class="line">    head = [-<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    e = [<span class="number">0</span>] * m</span><br><span class="line">    ne = [<span class="number">0</span>] * m</span><br><span class="line">    w = [<span class="number">0</span>] * m</span><br><span class="line">    st = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    cnt = [<span class="number">0</span>] * ( n + <span class="number">1</span>)</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> idx</span><br><span class="line">        e[idx] = b</span><br><span class="line">        ne[idx] = head[a]</span><br><span class="line">        w[idx] = c</span><br><span class="line">        head[a] = idx</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spfa</span>():</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="comment"># 主要所有节点都要入队列，还是因为负环的特殊性</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            q.append(i)</span><br><span class="line">            st[i] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            t = q.popleft()</span><br><span class="line">            st[t]= <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            i = head[t]</span><br><span class="line">            <span class="keyword">while</span> i != -<span class="number">1</span>:</span><br><span class="line">                j = e[i]</span><br><span class="line">                <span class="keyword">if</span> d[j] &gt; d[t] + w[i]:</span><br><span class="line">                    d[j] = d[t] + w[i] </span><br><span class="line">                    cnt[j] = cnt[t] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cnt[j] &gt;= n:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> st[j]:</span><br><span class="line">                        st[j] = <span class="literal">True</span></span><br><span class="line">                        q.append(j)</span><br><span class="line">                i = ne[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        add(a, b, c)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span> <span class="keyword">if</span> spfa() <span class="keyword">else</span> <span class="string">&quot;No&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="Floyd算法">Floyd算法</h3><p>时间复杂度是 $O(n^3)$, n表示点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="comment">// 枚举每个结点来更新其他所有结点间的距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">                <span class="comment">// 其实质是利用了动态规划和滚动数组</span></span><br><span class="line">                <span class="comment">// d[k, i, j] = d[k-1, i, k]  + d[k-1, k, j]</span></span><br><span class="line">                <span class="comment">// d[k,i,j]表示从i到j经过k的距离</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-854-Floyd求最短路"><a href="https://www.acwing.com/problem/content/856/">AcWing 854. Floyd求最短路</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Floyd算法——AcWing 854. Floyd求最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">40010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举每个结点来更新其他所有结点间的距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">                <span class="comment">// 其实质是利用了动态规划和滚动数组</span></span><br><span class="line">                <span class="comment">// d[k, i, j] = d[k-1, i, k]  + d[k-1, k, j]</span></span><br><span class="line">                <span class="comment">// d[k,i,j]表示从i到j经过k的距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化，将不同点之间的距离初始为正无穷</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], w);</span><br><span class="line">        <span class="comment">// 注意重边问题</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp; b);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> t = d[a][b];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除以2的原因:</span></span><br><span class="line">        <span class="comment">// floyd算法会对所有边都尝试进行更新，而由于图中存在负边，就可能出现一种情况——边的两端都是正无穷（距离起点无限远，不连通），但由于是负边，也会对尾端的正无穷进行更新，使其值减小</span></span><br><span class="line">        <span class="comment">// 而本题中由于数据范围k &lt; 40000，边权的绝对值 &lt; 10000，所以正无穷至多减小4e8，</span></span><br><span class="line">        <span class="comment">// 因而除2即可保证识别出并连通的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重边只保留最短的边，自环则直接删掉</p><h4 id="Python-7">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># 注意有重边，需要初始化为inf</span></span><br><span class="line">    g = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Floyd</span>():</span><br><span class="line">        <span class="comment"># 到自身的距离要赋值为0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            g[i][i] = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                    g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c)</span><br><span class="line">        </span><br><span class="line">    Floyd()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="keyword">if</span> g[a][b] == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;impossible&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(g[a][b])</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="最小生成树">最小生成树</h3><p>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边(n-1条)。</p><p>最小生成树一般考察无向图，有向图一般不会用到，存边的时候需要存两次</p><p>难点也在于建图</p><p>常用算法</p><ul class="lvl-0"><li class="lvl-2"><p>普利姆算法（Prim)<br>包括两个版本：</p><ul class="lvl-2"><li class="lvl-4">朴素版Prim算法：用于稠密图，$O(n^2)$</li><li class="lvl-4">堆优化版的Prim算法：用于稀疏图，$O(mlogn)$。不常用，稀疏图更常用Kruskal算法</li></ul></li><li class="lvl-2"><p>克鲁斯卡尔算法（Kruskal）：$O(mlogm)$</p></li></ul><h3 id="朴素版prim算法">朴素版prim算法</h3><p>时间复杂度是 $O(n^2+m)$, n表示点数，m表示边数</p><p>算法流程：</p><ol><li class="lvl-3"><p>输入：一个加权连通图，其中顶点集合为V，边集合为E；</p></li><li class="lvl-3"><p>初始化：$V_{new} = {x}$，其中x为集合V中的任一节点（起始点），$E_{new} = {}$,为空；</p></li><li class="lvl-3"><p>重复下列操作，直到$V_{new} = V$：</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>在集合E中选取权值最小的边$&lt;u, v&gt;$，其中u为集合Vnew中的元素，而v不在$V_{new}$集合当中，并且$v∈V$（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；</p></li><li class="lvl-2"><p>将v加入集合$V_{new}$中，将$&lt;u, v&gt;$边加入集合$E_new$中；</p></li></ul><ol start="4"><li class="lvl-3"><p>输出：使用集合$V_{new}$和$E_{new}$来描述所得到的最小生成树。</p></li></ol><p>Prim算法和Dijkstra算法非常相似，区别在于Dijkstra算法每次找到不在集合内的距离起点最近的点，并用其更新其他点到起点的距离。而Prim算法每次找到不在集合内的距离起点最近的点，并用其更新其他点到集合的距离。Dijkstra算法起始时默认起点已经在集合中，只需迭代n-1次。Prim算法初始时集合为空，所有点到集合距离初始化为正无穷，要迭代n次，且起点可以随机取。</p><p>注意Prim算法可以用于有负权边的图，而Dijkstra算法不能。</p><p>全局贪心</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230404173346134.png" alt="image-20230404173346134"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树集合的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">// 记录距离之和</span></span><br><span class="line">    <span class="comment">// 初始时选择任意一点——这里默认最开始选择编号为1的点</span></span><br><span class="line">    <span class="comment">// 注意i从0开始，要迭代n次，且会用到0的特殊性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 找到到集合的距离最近的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        <span class="comment">// 注意j编号从1开始——节点标号从1开始</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">            <span class="comment">// 注意短路特性</span></span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="comment">// 除了起始点外，其他如果存在最短边长为无穷大说明不连通，不存在生成树</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 加入到集合中</span></span><br><span class="line">        <span class="comment">// 先累加再更新，防止有负自环时，先更新会改变dist[t]的值（自己更新自己）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点到集合的距离，注意不是到某个特定点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        <span class="comment">// 所谓到集合的距离即到集合中的所有点的距离的最小值，即最小的边长</span></span><br><span class="line">        <span class="comment">// 由于点是迭代加入集合的，所以每加入一个点，只用多考虑其和其他点之间的边，取最小即可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-858-Prim算法求最小生成树"><a href="https://www.acwing.com/problem/content/860/">AcWing 858. Prim算法求最小生成树</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 朴素版prim算法——AcWing 858. Prim算法求最小生成树</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">// 记录距离之和</span></span><br><span class="line">    <span class="comment">// 初始时选择任意一点——这里默认最开始选择编号为1的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">    <span class="comment">// 注意i从0开始，要迭代n次，且会用到0的特殊性</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 找到到集合的距离最近的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        <span class="comment">// 注意j编号从1开始——节点标号从1开始</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">            <span class="comment">// 注意短路特性</span></span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="comment">// 除了起始点外，其他如果存在最短边长为无穷大说明不连通，不存在生成树</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 加入到集合中</span></span><br><span class="line">        <span class="comment">// 先累加再更新，防止有负自环时，先更新会改变dist[t]的值（自己更新自己）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点到集合的距离，注意不是到某个特定点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        <span class="comment">// 所谓到集合的距离即到集合中的所有点的距离的最小值，即最小的边长</span></span><br><span class="line">        <span class="comment">// 由于点是迭代加入集合的，所以每加入一个点，只用多考虑其和其他点之间的边，取最小即可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="comment">// 邻接矩阵初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], w);</span><br><span class="line">        <span class="comment">// 注意是无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span> ( t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-8">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    st = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dist = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Prim</span>():</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            t = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> st[j] <span class="keyword">and</span> (t == -<span class="number">1</span> <span class="keyword">or</span> dist[t] &gt; dist[j]):</span><br><span class="line">                    t = j</span><br><span class="line">            <span class="comment"># 判断孤立点</span></span><br><span class="line">            <span class="keyword">if</span> dist[t] == <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">print</span>(<span class="string">&quot;impossible&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            res += dist[t]</span><br><span class="line">            st[t] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                dist[i] = <span class="built_in">min</span>(dist[i], g[t][i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">print</span>(res)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 注意本题是无向图，需要同时添加两条边</span></span><br><span class="line">        g[b][a] = g[a][b] = <span class="built_in">min</span>(g[a][b], c)</span><br><span class="line">    Prim()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="堆优化版的Prim算法">堆优化版的Prim算法</h3><p>把求最小值这一步从遍历变成由堆来优化</p><h3 id="克鲁斯卡尔算法（Kruskal）：">克鲁斯卡尔算法（Kruskal）：</h3><p>从小到大排序，时间主要花在排序上</p><p>时间复杂度是$O(mlogm)$, n表示点数，m表示边数</p><p>基本思想是：假设连通网G=(V,E)，令最小生成树的初始状态为只有n个顶点而无边的非连通图T=(V,{})，概述图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点分别在T中不同的连通分量上，则将此边加入到T中；否则，舍去此边而选择下一条代价最小的边。依此类推，直至T中所有顶点构成一个连通分量为止。</p><p>步骤：</p><ol><li class="lvl-3"><p>将所有边按权重从小到大排序($O(mlogm))</p></li><li class="lvl-3"><p>枚举每条边&lt;a, b&gt;，如果a，b不连通，则将这条边加入集合中</p></li></ol><p>第二步可以使用并查集来实现</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230404173241962.png" alt="image-20230404173241962"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;     <span class="comment">// 存储边</span></span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="comment">//重载运算符排序</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="comment">// 由于本算法只涉及每条边的两端点和边权，只关心每条边，而不涉及图的路径问题，所以可以直接用结构体存边即可，不需要关心边之间的联系</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// 并查集核心操作：寻找祖宗结点+递归式路径压缩</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line">    <span class="comment">// 先从小到大排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    </span><br><span class="line">    <span class="comment">// 初始化并查集（每个结点一个集合）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// res存储最小生成树所有树边的权重之和，cnt存储当前加入集合的边数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大枚举所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="comment">// 寻找两点各自的祖宗结点（集合编号）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a != b)&#123;   </span><br><span class="line">        <span class="comment">// 判断是否在相同集合</span></span><br><span class="line">        <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="comment">// 边数小于n-1，一定不连通</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-859-Kruskal算法求最小生成树"><a href="https://www.acwing.com/problem/content/861/">AcWing 859. Kruskal算法求最小生成树</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 克鲁斯卡尔算法（Kruskal）——AcWing 859. Kruskal算法求最小生成树</span></span><br><span class="line"><span class="comment">// 排序 + 并查集合并集合</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;     <span class="comment">// 存储边</span></span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="comment">//重载运算符排序</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="comment">// 由于本算法只涉及每条边的两端点和边权，只关心每条边，而不涉及图的路径问题，所以可以直接用结构体存边即可，不需要关心边之间的联系</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// 并查集核心操作：寻找祖宗结点+递归式路径压缩</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line">    <span class="comment">// 先从小到大排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i ) p[i] = i;    </span><br><span class="line">    <span class="comment">// 初始化并查集（每个结点一个集合）</span></span><br><span class="line">    <span class="comment">// 注意节点编号从1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// res存储最小生成树所有树边的权重之和，cnt存储当前加入集合的边数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大枚举所有边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="comment">// 寻找两点各自的祖宗结点（集合编号）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a != b)&#123;   </span><br><span class="line">        <span class="comment">// 判断是否在相同集合</span></span><br><span class="line">        <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="comment">// 边数小于n-1，一定不连通</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-9">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    edge = []</span><br><span class="line">    p = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x != p[x]:</span><br><span class="line">            p[x] = find(p[x])</span><br><span class="line">        <span class="keyword">return</span> p[x]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Kruskal</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> edge</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        edge = <span class="built_in">sorted</span>(edge, key=<span class="keyword">lambda</span> s: s[<span class="number">2</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            a, b, c = edge[i]</span><br><span class="line">            a = find(a)</span><br><span class="line">            b = find(b)</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                res += c</span><br><span class="line">                <span class="comment"># 合并集合</span></span><br><span class="line">                p[b] = a</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt != n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;impossible&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a, b, c = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        edge.append([a, b, c])</span><br><span class="line">    <span class="comment"># 注意并查集的初始化    </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        p[i] = i</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(Kruskal())</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="二分图">二分图</h2><p>常用算法：</p><ul class="lvl-0"><li class="lvl-2"><p>染色法：$O(n+m)$，用于判别是否为二分图，实质就是dfs</p></li><li class="lvl-2"><p>匈牙利算法：$O(mn)$，实际运行时间一般远小于$O(mn)$，用于求二分图的最大匹配</p></li></ul><h3 id="染色法判别二分图">染色法判别二分图</h3><p>时间复杂度是 $O(n+m)$, n表示点数，m表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="comment">// 注意e[]和ne[]存的是边数，大小为M</span></span><br><span class="line"><span class="type">int</span> color[N];<span class="comment">// 表示每个点的颜色，0表示未染色，1表示白色，2表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="comment">// 深度优先遍历对节点进行染色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="comment">// 对当前结点的染色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前结点的子结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="comment">// 判断是否已经被染色过</span></span><br><span class="line">        <span class="keyword">if</span> (!color[j])&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 进行染色，注意染相反的颜色</span></span><br><span class="line">            <span class="comment">// 这里由于两种颜色分别为1、2，所以用3 - c来表示相反颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 已经被染色，且染的相同颜色，则染色失败，不是二部图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 枚举所有节点，进行染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="comment">// 注意点的编号从1开始</span></span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 这里注意每个结点所在路径上的点都会被染色</span></span><br><span class="line">            <span class="comment">// 仍未被染色一定在不连通的其他路径上</span></span><br><span class="line">            <span class="comment">// 因而起点都可默认染为1</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-860-染色法判定二分图"><a href="https://www.acwing.com/activity/content/problem/content/926/">AcWing 860. 染色法判定二分图</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 染色法判别二分图——AcWing 860. 染色法判定二分图</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="comment">// 注意e[]和ne[]存的是边数，大小为M</span></span><br><span class="line"><span class="type">int</span> color[N];<span class="comment">// 表示每个点的颜色，0表示未染色，1表示白色，2表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="comment">// 深度优先遍历对节点进行染色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a] , h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="comment">// 对当前结点的染色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前结点的子结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="comment">// 判断是否已经被染色过</span></span><br><span class="line">        <span class="keyword">if</span> (!color[j])&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 进行染色，注意染相反的颜色</span></span><br><span class="line">            <span class="comment">// 这里由于两种颜色分别为1、2，所以用3 - c来表示相反颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 已经被染色，且染的相同颜色，则染色失败，不是二部图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 枚举所有节点，进行染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="comment">// 注意点的编号从1开始</span></span><br><span class="line">        <span class="keyword">if</span> (!color[i])</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="comment">// 这里注意每个结点所在路径上的点都会被染色</span></span><br><span class="line">            <span class="comment">// 仍未被染色一定在不连通的其他路径上</span></span><br><span class="line">            <span class="comment">// 因而起点都可默认染为1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="comment">// 邻接表初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ;i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匈牙利算法求二分图的最大匹配">匈牙利算法求二分图的最大匹配</h3><p>时间复杂度是 $O(nm)$, n表示点数，m表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;<span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];<span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行每个节点的匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">    <span class="comment">// 枚举所有有可能进行匹配的点</span></span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">        <span class="comment">// st数组可用于防止在结点匹配成功后，find无限递归匹配同一个结点（防止先匹配者自己挖自己墙脚）；</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))&#123;</span><br><span class="line">            <span class="comment">// 如果没有进行过匹配或已匹配的结点还有其他可以匹配的点（可以挖墙脚）就可进行匹配</span></span><br><span class="line">            <span class="comment">// 注意这里如果没有st数组，在查找先匹配者的其他匹配对象时，仍会匹配原对象，导致无限递归自身的死循环</span></span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录匹配数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 必须每次要全部更新为false，否则无法挖墙脚</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-861-二分图的最大匹配"><a href="https://www.acwing.com/problem/content/863/">AcWing 861. 二分图的最大匹配</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匈牙利算法求二分图的最大匹配——AcWing 861. 二分图的最大匹配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1, n2, m;<span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];<span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行每个节点的匹配</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">    <span class="comment">// 枚举所有有可能进行匹配的点</span></span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">        <span class="comment">// st数组可用于防止在结点匹配成功后，find无限递归匹配同一个结点（防止先匹配者自己挖自己墙脚）；</span></span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))&#123;</span><br><span class="line">            <span class="comment">// 如果没有进行过匹配或已匹配的结点还有其他可以匹配的点（可以挖墙脚）就可进行匹配</span></span><br><span class="line">            <span class="comment">// 注意这里如果没有st数组，在查找先匹配者的其他匹配对象时，仍会匹配原对象，导致无限递归自身的死循环</span></span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录匹配数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )&#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 必须每次要全部更新为false，否则无法挖墙脚</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课2 数据结构</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表">单链表</h2><p>邻接表：n个链表，用于存储图和树</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230329145817796.png" alt="image-20230329145817796"></p><h3 id="模板">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// e和ne通过下标关联在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>; <span class="comment">// -1标记空节点</span></span><br><span class="line">    idx = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inset</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-826-单链表">1. <a href="https://www.acwing.com/activity/content/problem/content/863/">AcWing 826. 单链表</a></h3><h4 id="C">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点;已经用到的节点的下一个位置</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (k)</span><br><span class="line">                <span class="built_in">remove</span>(k - <span class="number">1</span>); <span class="comment">// 注意存储从0开始，而题目从1开始</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 特判删除头结点</span></span><br><span class="line">                head = ne[head];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">100010</span></span><br><span class="line">    head = - <span class="number">1</span></span><br><span class="line">    e = [<span class="number">0</span>] * N</span><br><span class="line">    ne = [<span class="number">0</span>] * N</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert_head</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> idx, head</span><br><span class="line">        e[idx] = x</span><br><span class="line">        ne[idx] = head</span><br><span class="line">        head = idx</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">k, x</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> idx</span><br><span class="line">        e[idx] = x</span><br><span class="line">        ne[idx] = ne[k]</span><br><span class="line">        ne[k] = idx</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">k</span>):</span><br><span class="line">        ne[k] = ne[ne[k]]</span><br><span class="line">        </span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        data = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&quot;H&quot;</span>:</span><br><span class="line">            x = <span class="built_in">int</span>(data[<span class="number">1</span>])</span><br><span class="line">            insert_head(x)</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;D&quot;</span>:</span><br><span class="line">            k = <span class="built_in">int</span>(data[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> k:</span><br><span class="line">                remove(k - <span class="number">1</span>) <span class="comment"># 注意存储从0开始，而题目从1开始</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 特判删除头结点</span></span><br><span class="line">                head = ne[head]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k, x = <span class="built_in">int</span>(data[<span class="number">1</span>]), <span class="built_in">int</span>(data[<span class="number">2</span>])</span><br><span class="line">            insert(k - <span class="number">1</span>, x)</span><br><span class="line">        m -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    i = head</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i != -<span class="number">1</span>:</span><br><span class="line">        res.append(e[i])</span><br><span class="line">        i = ne[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, res)))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="双链表">双链表</h2><p>用于优化某些问题</p><h3 id="模板-2">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">// 需要注意左端点只有右邻接点，右端点只有左邻接点</span></span><br><span class="line">    <span class="comment">// 初始时左右端点互为邻接点</span></span><br><span class="line">    idx = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="comment">// 在节点a的左边插入一个数相当于在l[a]右边插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-827-双链表-AcWing">1. <a href="https://www.acwing.com/activity/content/problem/content/864/">AcWing 827. 双链表 - AcWing</a></h3><h4 id="C-2">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意初始时，下标0位置设为头结点，下标1位置设为尾节点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="comment">// 在节点a的左边插入一个数x等价于在节点l[a]的右边插入一个数x</span></span><br><span class="line"><span class="comment">// 在最左端插入即在0右侧插入，在最右端插入即在1左侧插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k, r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx, r[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (n -- )&#123;</span><br><span class="line">        <span class="type">int</span> k, x;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;L&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">0</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;R&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(l[<span class="number">1</span>], x); <span class="comment">// 在节点a的左边插入一个数x等价于在节点l[a]的右边插入一个数x</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="comment">// 注意下标0和1表示存储头和尾，元素从下标2开始存储，而题目从1开始</span></span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;IL&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(l[k + <span class="number">1</span>], x); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(k + <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) <span class="comment">// 头节点开始，尾节点结束</span></span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-2">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">100010</span></span><br><span class="line">    e = [<span class="number">0</span>] * N</span><br><span class="line">    l = [<span class="number">0</span>] * N</span><br><span class="line">    r = [<span class="number">0</span>] * N</span><br><span class="line">    r[<span class="number">0</span>], l[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    idx = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">k, x</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> idx</span><br><span class="line">        e[idx] = x</span><br><span class="line">        l[idx], r[idx] = k, r[k]</span><br><span class="line">        l[r[k]] = idx </span><br><span class="line">        r[k] = idx</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">k</span>):</span><br><span class="line">        l[r[k]] = l[k]</span><br><span class="line">        r[l[k]] = r[k]</span><br><span class="line">        </span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        data = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&quot;L&quot;</span>:</span><br><span class="line">            x = <span class="built_in">int</span>(data[<span class="number">1</span>])</span><br><span class="line">            insert(<span class="number">0</span>, x)</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;R&quot;</span>:</span><br><span class="line">            x = <span class="built_in">int</span>(data[<span class="number">1</span>])</span><br><span class="line">            insert(l[<span class="number">1</span>], x)</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;D&quot;</span>:</span><br><span class="line">            k = <span class="built_in">int</span>(data[<span class="number">1</span>])</span><br><span class="line">            remove(k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;IL&quot;</span>:</span><br><span class="line">            k, x = <span class="built_in">int</span>(data[<span class="number">1</span>]), <span class="built_in">int</span>(data[<span class="number">2</span>])</span><br><span class="line">            insert(l[k + <span class="number">1</span>], x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k, x = <span class="built_in">int</span>(data[<span class="number">1</span>]), <span class="built_in">int</span>(data[<span class="number">2</span>])</span><br><span class="line">            insert(k + <span class="number">1</span>, x)</span><br><span class="line">        m -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    i = r[<span class="number">0</span>] <span class="comment"># 注意0和1都不存储元素，只标记头和尾，取值从r[0]开始</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i != <span class="number">1</span>:</span><br><span class="line">        res.append(e[i])</span><br><span class="line">        i = r[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, res)))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="栈">栈</h2><h3 id="模板-3">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt; 0，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-828-模拟栈">1. <a href="https://www.acwing.com/activity/content/problem/content/865/">AcWing 828. 模拟栈</a></h3><h4 id="C-3">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            stk[++ tt] =x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">            cout &lt;&lt; stk[tt] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) tt --;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) cout &lt;&lt; (tt ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接使用列表的方法即可模拟栈</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    stk = []</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        q = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> q[<span class="number">0</span>] == <span class="string">&quot;push&quot;</span>:</span><br><span class="line">            stk.append(<span class="built_in">int</span>(q[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">elif</span> q[<span class="number">0</span>] == <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">            stk.pop() <span class="comment"># list的pop()方法默认弹出最后元素</span></span><br><span class="line">        <span class="keyword">elif</span> q[<span class="number">0</span>] == <span class="string">&quot;empty&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span> <span class="keyword">if</span> <span class="built_in">len</span>(stk) == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;NO&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> q[<span class="number">0</span>] == <span class="string">&quot;query&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(stk[-<span class="number">1</span>])</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-3302-表达式求值">2. <a href="https://www.acwing.com/activity/content/problem/content/3648/">AcWing 3302. 表达式求值</a></h3><h2 id="一-问题分析">一. 问题分析</h2><h3 id="1-信息提取">1. 信息提取</h3><p><code>+</code> 和 <code>-</code> 等价, <code>*</code> 和 <code>/</code> 等价</p><p>所以只需分析 <code>+</code> 和 <code>*</code></p><ul class="lvl-0"><li class="lvl-4"><p><code>*</code> 优先级比 <code>+</code> 大</p><p>$2 + 3 * 2$ 对应的树为</p><p><img src="https://mdpic.dreamgo.fun/img/2401_c5f2f1d625-5.png" alt=""></p></li><li class="lvl-4"><p>同优先级左边大于右边</p><p>$2 + 3 + 2$ 对应的树为</p><p><img src="https://mdpic.dreamgo.fun/img/2401_ccbb870b25-6.png" alt=""></p></li><li class="lvl-4"><p>括号优先级大于其他</p><p>$(2 + 3) * 2$ 对应的树为</p><p><img src="https://mdpic.dreamgo.fun/img/2401_d156dc4b25-7.png" alt=""></p><p>看起来是 <code>+</code> 的优先级比 <code>*</code> 大, 其实是因为括号的优先级比 <code>*</code> 大</p></li></ul><h3 id="2-总结特点">2. 总结特点</h3><ul class="lvl-0"><li class="lvl-4"><p>优先级大的运算符在下面, 优先级小的运算符在上面</p></li><li class="lvl-4"><p>叶节点都是数字, 内部节点都是运算符, 括号不作为节点, 但会作为一个运算符参与运算符优先级的比较</p></li></ul><h2 id="二-问题建模">二. 问题建模</h2><h3 id="1-中序遍历表达式树的计算过程">1. 中序遍历表达式树的计算过程</h3><ul class="lvl-0"><li class="lvl-4"><p>任意一个表达式树</p><p><img src="https://mdpic.dreamgo.fun/img/2401_e9a35c1125-3.png" alt=""></p><blockquote><p>叶节点是数字, 内部节点是运算符</p></blockquote></li><li class="lvl-4"><p>计算过程</p><p><img src="https://mdpic.dreamgo.fun/img/2401_ee9fc12c25-8.png" alt=""></p></li><li class="lvl-4"><p>遍历节点 1 2 3 后, 则 4 的左子树遍历完, 则计算 4 的左子树的结果, 新节点作为 4 的左孩子节点</p></li><li class="lvl-4"><p>继续遍历节点 5 6 7, 则 8 的左子树遍历完, 则计算 8 的左子树的结果, 新节点作为 8 的左孩子节点</p></li><li class="lvl-4"><p>同理, 遍历节点 12 的时候计算其左子树的结果, 新节点作为 12 的左孩子</p></li><li class="lvl-4"><p>当整棵树遍历完后, 再次逆序计算各运算符的结果, 最后只剩一个节点就是表达式的最终结果</p><blockquote><p>注意计算 8 的左子树时先计算运算符 6, 然后结果作为运算符 4 的右孩子, 然后计算运算符 4, 其结果作为运算符 8 的左孩子</p></blockquote></li></ul><h3 id="2-计算过程分析">2. 计算过程分析</h3><p>如何判断某棵子树被遍历完 ?</p><ul class="lvl-0"><li class="lvl-4"><p>中序遍历往上走时, 子树遍历完</p><blockquote><p>例如过程 1 中遍历节点 4 时, 说明 1 2 3 的子树遍历完</p></blockquote></li><li class="lvl-4"><p>中序遍历往下走时, 子树未遍历完</p><blockquote><p>例如过程 2 中遍历节点 6 时, 相对于 4 是往下走的, 此时 8 的左子树未遍历完</p></blockquote></li></ul><p>如何判断往上走还是往下走 ?</p><ul class="lvl-0"><li class="lvl-4"><p>注意到运算符优先级大的在下面, 运算符优先级小的在上面</p></li><li class="lvl-4"><p>所以当目前运算符的优先级比上一运算符优先级小时, 说明是往上走</p></li><li class="lvl-4"><p>当目前运算符的优先级比上一运算符优先级大是, 说明是往下走</p></li></ul><p>什么时候进行计算 ?</p><ul class="lvl-0"><li class="lvl-4"><p>往上走时, 因为此时子树遍历完, 需要计算子树的结果, 并将结果作为一个新的节点代替原来的子树</p><blockquote><p>例如遍历节点 8 时, 计算 8 的左子树, 然后将计算结果作为新的节点代替原来的左子树</p></blockquote></li></ul><h2 id="三-问题解法">三. 问题解法</h2><h3 id="1-数据结构">1. 数据结构</h3><p>由于是模拟中序遍历树的过程, 所以要用栈数据结构</p><p>由于是有运算符和数字两个对象, 所以要用两个栈来存储</p><h3 id="2-算法">2. 算法</h3><p>遇到各节点后的处理</p><ol><li class="lvl-4"><p>数字</p><p>数字并不会产生计算过程, 所以只需提取数字, 将数字压栈</p></li><li class="lvl-4"><p>括号</p><p>括号分为两个运算符 <code>(</code> 和 <code>)</code></p><p>遇到 <code>(</code> 说明会往下走, 所以只需将 <code>(</code> 压栈</p><p>遇到 <code>)</code> 说明会往上走, 所以要计算括号表示的子树的结果, 所以要逆向计算运算符直至遇到 <code>(</code></p></li><li class="lvl-4"><p>普通二元运算符</p><p>如果当前运算符优先级比上一运算符高, 说明是往下走, 则只需将运算符压栈</p><p>如果当前运算符优先级比上一运算符低, 说明是往上走, 则需要一直计算上一运算符直至当前运算符优先级比上一运算符高</p></li></ol><h3 id="3-核心代码实现">3. 核心代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    char c = s[i];              // c 是当前字符</span><br><span class="line">    if(isdigit(c))              // 如果 c 是数字, 就提取数字</span><br><span class="line">    &#123;</span><br><span class="line">        int x = 0, j = i;</span><br><span class="line">        while(j &lt; s.size() &amp;&amp; isdigit(s[j])) x = x * 10 + s[j++] - &#x27;0&#x27;;</span><br><span class="line">        i = j - 1;</span><br><span class="line">        num.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(c == &#x27;(&#x27;) op.push(c);       // 如果 c 是 &#x27;(&#x27;, 就压栈</span><br><span class="line">    else if(c == &#x27;)&#x27;)                   // 如果 c 是 &#x27;)&#x27;, 就一直计算到 &#x27;(&#x27; </span><br><span class="line">    &#123;</span><br><span class="line">        while(op.top() != &#x27;(&#x27;) eval();  // eval 函数的功能是计算上一运算符</span><br><span class="line">        op.pop();                       // &#x27;(&#x27; 出栈</span><br><span class="line">    &#125;</span><br><span class="line">    else                                // 如果 c 是普通运算符, 就一直计算到 c 的优先级比上一运算符高</span><br><span class="line">    &#123;</span><br><span class="line">        while(op.size() &amp;&amp; pr[op.top()] &gt;= pr[c]) eval();</span><br><span class="line">        op.push(c);                     // c 入栈</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四-算法证明">四. 算法证明</h2><h3 id="循环不变式">循环不变式</h3><p>当前运算符及之前所有运算符的<strong>左子树</strong>都是形如下图的形状</p><p><img src="https://mdpic.dreamgo.fun/img/2401_edab902726-2.png" alt=""></p><blockquote><p>前五个例子, 后面的形状以此类推</p></blockquote><h3 id="证明">证明</h3><h4 id="初始化">初始化</h4><p>当 <code>i = 0</code> 时, 当前运算符为空, 循环不变式显然成立</p><h4 id="保持">保持</h4><p>假定在某轮循环前, 循环不变式成立</p><p>执行该轮 <code>for</code> 循环</p><blockquote><p>c 为当前字符</p></blockquote><p><strong>当 <code>c</code> 为数字时</strong></p><p>会提取数字, 然后将数字压栈</p><p>则前面的所有子树形状不变, 循环不变式成立</p><p><strong>当 <code>c</code> 为 <code>(</code> 时</strong></p><p>会将 <code>(</code> 压栈</p><p>则前面的所有子树形状不变, 循环不变式成立</p><p><strong>当 <code>c</code> 为 <code>)</code> 时</strong></p><p>会一直逆序计算运算符直到遇到 <code>(</code></p><p>根据假定, <code>)</code> 前面的左子树, 即 <code>()</code> 表示的整棵子树是形如下图的形状</p><p><img src="https://mdpic.dreamgo.fun/img/2401_27a9da3e26-2.png" alt=""></p><p>则一直逆序计算运算符直到遇到 <code>(</code> 会计算 <code>()</code> 表示的整棵子树, 然后将计算结果作为新的节点代替原来的子树</p><p>则 <code>()</code> 表示的整棵子树被一个节点代替, 该节点会使得左子树的形状保持循环不变式的形状</p><blockquote><p>例 1 当 () 表示的整棵子树是上图的第一棵子树时</p><p>如 2 + (3) , (3) 就是上图的第一棵子树</p><p>计算结果是 2 + 3, 对应的子树保持循环不变式的形状</p><p>例 2 当 () 表示的整棵子树是上图的第一棵子树时</p><p>如 2 * (3 + 2), (3 + 2) 就是上图的第二棵子树</p><p>计算结果是 2 * 5, 对应的子树保持循环不变式的形状</p><p>例 3 当 () 表示的整棵子树是上图的第三棵子树时</p><p>如 1 + 2 * (3 + 2 * 3) * 3, (3 + 2 * 3) 就是上图的第三棵子树</p><p>计算结果是 1 + 2 * 9 * 3, 对应的子树保持循环不变式的形状</p><p>注: 此处 “对应的子树” 意为 ‘)’ 运算符前面的运算符的左子树, 即 1 + 2 * 9</p></blockquote><p><strong>当 <code>c</code> 为普通运算符时</strong></p><p>会一直逆序计算优先级比自己高的运算符</p><p>根据假定, 当前运算符前面的左子树都是形如下图的形状</p><p><img src="https://mdpic.dreamgo.fun/img/2401_3d3e09ce26-2.png" alt=""></p><p>整棵树的形状可以为下图</p><p><img src="https://mdpic.dreamgo.fun/img/2401_3fd2344a26-9.png" alt=""></p><p>一直逆序计算优先级比自己高的运算符会计算当前运算符的左子树, 并将计算结果作为当前运算符的左孩子</p><p>过程如下所示</p><p><img src="./assets/2401_4368b2c426-1.png" alt=""></p><p>所以当前循环结束后, 循环不变式保持成立</p><p><strong>终止</strong></p><p>当 <code>for</code> 循环结束后, 整棵树的形状也是循环不变式的形状</p><p><img src="https://mdpic.dreamgo.fun/img/2401_45c7841726-10.png" alt=""></p><h3 id="总结">总结</h3><p>所以在 <code>for</code> 循环结束后, 需要逆序计算运算符直至没有运算符为止, 最终整棵树计算为一个节点, 该节点就是表达式的计算结果</p><h2 id="队列">队列</h2><h3 id="模板-4">模板</h3><h4 id="普通队列">普通队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环队列">循环队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-829-模拟队列">1. <a href="https://www.acwing.com/activity/content/problem/content/866/">AcWing 829. 模拟队列</a></h3><h4 id="C-4">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            q[++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) hh ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) cout &lt;&lt; (hh &lt;= tt ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;query&quot;</span>) cout &lt;&lt; q[hh] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-3">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接用list的方法，复杂度为O(n^2), 因为pop(0)的话是O(n)的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    q = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        data = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&quot;push&quot;</span>:</span><br><span class="line">            q.append(data[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">            q.pop(<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;empty&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;NO&quot;</span> <span class="keyword">if</span> <span class="built_in">len</span>(q) <span class="keyword">else</span> <span class="string">&quot;YES&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;query&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(q[<span class="number">0</span>])</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组模拟栈，复杂度为O(n),通过下标移动可以减少时间复杂度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    q = []</span><br><span class="line">    hh, tt = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        data = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&quot;push&quot;</span>:</span><br><span class="line">            q.append(data[<span class="number">1</span>]) </span><br><span class="line">            tt += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 也可以一次性开好数组，用下标tt添加元素</span></span><br><span class="line">            <span class="comment"># tt += 1</span></span><br><span class="line">            <span class="comment"># q[tt] = data[1]</span></span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;empty&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;NO&quot;</span> <span class="keyword">if</span> hh &lt;= tt <span class="keyword">else</span> <span class="string">&quot;YES&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;query&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(q[hh])</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h5 id="Deque简介">Deque简介</h5><p>双向队列deque是栈和队列的一种广义实现，是类似于list的容器，可以快速的在队列头部和尾部添加、删除元素，deque是python的collections中的一个类。</p><ul class="lvl-0"><li class="lvl-2"><p>append()就是默认从尾部即右侧添加数据</p></li><li class="lvl-2"><p>appendleft()方法从deque队列的左侧添加数据</p></li><li class="lvl-2"><p>pop() 方法弹出元素，从尾部弹出，并且返回弹出的这个元素</p></li><li class="lvl-2"><p>popleft() 方法弹出元素，从头部弹出，并且返回弹出的这个元素、</p></li></ul><p>在队列两端插入或删除元素时间复杂度都是 O(1) ，而在列表的开头插入或删除元 素的时间复杂度为 O(N) 。</p><p>deuqe与list的区别相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。list实现出队（pop）和插入（insert）时的空间复杂度大约为O(n)，deque在出队（pop）和入队（append）时的时间复杂度是O(1)。</p><p>使用q=deque()代替q=list()，因为q.popleft()效率比q.pop(0)高这是因为：列表实现是基于数组的。pop(0)从列表中删除第一个项，它需要左移len(lst) - 1个项来填补空白。 deque()实现使用双向链表。因此无论deque有多大，deque.popleft()都需要一个常量的操作数。即deque.popleft()：T(n)=O(1)，而list.pop(0)：T(n)=O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用python库双端队列</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    q = deque([])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        data = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&quot;push&quot;</span>:</span><br><span class="line">            q.append(data[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">            q.popleft()</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;empty&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;NO&quot;</span> <span class="keyword">if</span> q <span class="keyword">else</span> <span class="string">&quot;YES&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> data[<span class="number">0</span>] == <span class="string">&quot;query&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(q[<span class="number">0</span>])</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="单调栈">单调栈</h2><p>类似于双指针算法，使用单调栈进行优化时可以首先写出暴力算法，然后研究状态之间的关系，挖掘出某些性质，使我们可以聚焦在比较少的状态中，排除冗余和非法元素/状态，得到单调性并利用单调性得到极值用于求解，实现实现从$O(k)$到$O(1)$的优化。</p><h3 id="单调栈的定义">单调栈的定义</h3><p>单调栈是栈的一中特殊形式，在栈中的元素必须满足单调性（一定是单调上升或单调下降等等的规律）。</p><p>单调栈的思想是利用不断迭代的方式，将当前的元素x与栈顶元素进行比较，按照单调性性质来决定是对栈顶元素做出栈操作还是将当前元素压栈来保证栈的单调性。</p><h3 id="单调栈的维护">单调栈的维护</h3><p>既然我们必须让元素满足单调性，那么每次插入就和栈顶作比较。如果不满足某些性质，直接弹出栈顶，直到栈为空或满足该性质插入这个元素。</p><ul class="lvl-0"><li class="lvl-2"><p>单调递增栈：在保持栈内元素<strong>单调递增</strong>的前提下（如果栈顶元素<strong>大于</strong>要入栈的元素，则将其弹出），将新元素入栈。</p></li><li class="lvl-2"><p>单调递减栈：在保持栈内元素<strong>单调递减</strong>的前提下（如果栈顶元素<strong>小于</strong>要入栈的元素，则将其弹出），将新元素入栈。</p></li></ul><h3 id="单调栈的性质">单调栈的性质</h3><p>单调栈的时间复杂度是 $O(n)$</p><p><img src="https://mdpic.dreamgo.fun/img/38262_3433145ea3-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E6%A0%88%E7%9A%84%E8%A7%84%E5%BE%8B.jpg" alt="单调栈1"></p><p>对于将要入栈的元素来说，在对栈进行更新后（即弹出了所有比自己大的元素），此时栈顶元素就是数组中左侧第一个比自己小的元素；</p><p><img src="https://mdpic.dreamgo.fun/img/38262_3c970524a3-%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88%E7%9A%84%E8%A7%84%E5%BE%8B.jpg" alt="单调栈2"></p><p>对于将要入栈的元素来说，在对栈进行更新后（即弹出了所有比自己小的元素），此时栈顶元素就是数组中左侧第一个比自己大的元素；</p><h3 id="单调栈的应用">单调栈的应用</h3><p>给定一个序列，求序列中的每一个数左边或右边<strong>第一个</strong>比他大或比他小的数在什么地方</p><h3 id="模板-5">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见模型：找出每个数左边离它最近的比它大/小的数</span></span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-830-单调栈">1. <a href="https://www.acwing.com/activity/content/problem/content/867/">AcWing 830. 单调栈</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">        <span class="comment">// compare and select</span></span><br></pre></td></tr></table></figure><p>接下来可以思考，在遍历过程中，哪些状态是非法或冗余的：</p><p>在数组中，如果<code>i &lt; j</code>且<code>a[i] &gt; a[j]</code>，则在<code>j</code>之后时，显然<code>a[j]</code>一定能完全替换掉<code>a[i]</code>（更偏左且更小），<code>a[i]</code>永远不会被用到，是冗余的。</p><p>为了去除冗余，显然我们需要维护一个单调序列，从而保证每个状态都不是冗余的。下面考虑如何维护，这需要考虑题目要求。由于我们找的是最左的一个小于当前数的值，即对于小于当前数的值，最左的优先，而不是最小的优先。因此除了需要维护单调序列之外，还需要保证序列中每个数的相对位置是从左到右排的，且优先取后加入的数作为答案，这显然是可以使用单调栈进行维护。</p><p>不妨考虑当前数<code>a[i]</code>小于<code>s[end]</code>，则需要用<code>a[i]</code>替换掉<code>s[end]</code>。然而这没有结束，还要继续和<code>s</code>中其他数进行比较，直到整个序列都是单调的。只不过，由于必须保证相对位置是从左到右排的，就必须从右往左单向逐个比较，这即单调栈的出栈入栈过程。</p><p><img src="https://mdpic.dreamgo.fun/img/55289_7a61998ec0-20201211221031165.gif" alt="55289_7a61998ec0-20201211221031165"></p><p>注意要先进行所有出栈操作，再得到当前答案，最后再将当前数入栈。栈为空说明无解。</p><h4 id="C-5">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> tt;</span><br><span class="line"><span class="type">int</span> stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="comment">// 求的是左边第一个最近最小的数，如果栈顶元素大于等于x，</span></span><br><span class="line">        <span class="comment">// 那么就说明栈顶这个数明显没有x好，所以就把stk[tt]弹出了</span></span><br><span class="line">        <span class="comment">// 使栈中序列保持单调</span></span><br><span class="line">        <span class="comment">// 注意特判栈空的情况</span></span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x)</span><br><span class="line">            tt --;</span><br><span class="line">        <span class="keyword">if</span> (!tt) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[tt]);</span><br><span class="line">        <span class="comment">// 最后将x插入栈顶；</span></span><br><span class="line">        stk[++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-4">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    nums = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    stk = []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">while</span> stk <span class="keyword">and</span> x &lt;= stk[-<span class="number">1</span>]:</span><br><span class="line">            stk.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stk:</span><br><span class="line">            res.append(<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(<span class="built_in">str</span>(stk[-<span class="number">1</span>]))</span><br><span class="line">        stk.append(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(res))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><h3 id="模板-6">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见模型：找出滑动窗口中的最大值/最小值</span></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-154-滑动窗口">1. <a href="https://www.acwing.com/activity/content/problem/content/868/">AcWing 154. 滑动窗口</a></h3><p>滑动窗口中的最值。</p><p>思路也是先写暴力算法，然后研究状态之间的关系，挖掘出某些性质，使我们可以聚焦在比较少的状态中，排除冗余和非法元素/状态，是序列始终是单调的，并利用单调性优化问题。求最值的话直接取端点即可，如果查找一个值的话，可以用二分。</p><p>窗口由于元素有进有出，且始终在一侧进另一侧出，因此可以用队列来维护。</p><p>研究队列中元素的关系，可以发现由于出队的顺序为先进先出，所以，如果后入队的元素优于先进的元素，在其入队后就完全替代了先入队的元素。本题求的是队列/窗口中的最小值，因此如果<code>a[i] &gt;= a[j]</code>，且<code> i &lt; j</code>（<code>a[i]</code>会先出队)，则<code>a[j]</code>入队后就替代<code>a[i]</code>。因此可以直接使冗余元素在<code>a[j]</code>入队同时出队，从而使队列中序列始终是单调递增的。从而最小值答案就在队头。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230330211529667.png" alt="image-20230330211529667"></p><h4 id="C-6">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 154. 滑动窗口——单调队列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"><span class="comment">// q[N]为单调队列，存储下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单调队列</span></span><br><span class="line">  <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>; </span><br><span class="line">  <span class="comment">// hh和tt用于维护滑动窗口</span></span><br><span class="line">  <span class="comment">// hh 表示滑动窗口开头的位置</span></span><br><span class="line">  <span class="comment">// tt 表示当前要存储处的前一个位置，也是滑动窗口尾端的位置（已存储的最后一个位置）</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">    <span class="comment">// i为当前滑动窗口最后一个元素的位置，窗口范围为i - k + 1到i</span></span><br><span class="line">    <span class="comment">// 需要保证滑动窗口中至少有一个元素，所以hh &lt;= tt</span></span><br><span class="line">    <span class="comment">// 另外要保证在滑动窗口范围内，所以i - k + 1 &lt;= q[hh]</span></span><br><span class="line">    <span class="comment">// 这样从hh到tt即为当前窗口的合法元素</span></span><br><span class="line">    <span class="comment">// 维护窗口大小</span></span><br><span class="line">    <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里利用单调性对队列进行优化</span></span><br><span class="line">    <span class="comment">// 由于求的是窗口中的最小值，所以只要新加入的元素比前面的元素还小，前面的元素即可删掉</span></span><br><span class="line">    <span class="comment">// 所以新加入的元素要从后往前和窗口中元素比较大小，存入最后一个比它小的元素后面</span></span><br><span class="line">    <span class="comment">// 这样就导致队列中存储的元素始终保持单调递增，最小的元素也就始终是窗口开头的元素，即a[q[hh]]</span></span><br><span class="line">    <span class="comment">// 维护序列单调性</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --;</span><br><span class="line">    <span class="comment">// 一定会入队</span></span><br><span class="line">    q[++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刚开始窗口内元素不足k时，不输出</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反过来，队列单调递减，开头元素最大</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt --;</span><br><span class="line">    q[++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-5">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">1000010</span></span><br><span class="line">    hh, tt = <span class="number">0</span>, - <span class="number">1</span></span><br><span class="line">    q = [<span class="number">0</span>] * N</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 维护窗口大小</span></span><br><span class="line">        <span class="keyword">while</span> hh &lt;= tt <span class="keyword">and</span> i - k + <span class="number">1</span> &gt; q[hh]:</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 维护队列单调性</span></span><br><span class="line">        <span class="keyword">while</span> hh &lt;= tt <span class="keyword">and</span> nums[q[tt]] &gt;= nums[i]:</span><br><span class="line">            tt -= <span class="number">1</span></span><br><span class="line">        tt += <span class="number">1</span></span><br><span class="line">        q[tt] = i</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(nums[q[hh]], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">    hh, tt = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> hh &lt;= tt <span class="keyword">and</span> i - k + <span class="number">1</span> &gt; q[hh]:</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> hh &lt;= tt <span class="keyword">and</span> nums[q[tt]] &lt;= nums[i]:</span><br><span class="line">            tt -= <span class="number">1</span></span><br><span class="line">        tt += <span class="number">1</span></span><br><span class="line">        q[tt] = i</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(nums[q[hh]], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用deque</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    q= deque([])</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 维护窗口大小</span></span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> i - k + <span class="number">1</span> &gt; q[<span class="number">0</span>]:</span><br><span class="line">            q.popleft()</span><br><span class="line">        <span class="comment"># 维护队列单调性</span></span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums[q[-<span class="number">1</span>]] &gt;= nums[i]:</span><br><span class="line">            q.pop()</span><br><span class="line">        q.append(i)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(nums[q[<span class="number">0</span>]], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">    q.clear()</span><br><span class="line">    hh, tt = <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> i - k + <span class="number">1</span> &gt; q[<span class="number">0</span>]:</span><br><span class="line">            q.popleft()</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">and</span> nums[q[-<span class="number">1</span>]] &lt;= nums[i]:</span><br><span class="line">            q.pop()</span><br><span class="line">        q.append(i)</span><br><span class="line">        <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(nums[q[<span class="number">0</span>]], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="KMP算法">KMP算法</h2><h3 id="模板-7">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"><span class="comment">// 求模式串的Next数组，只与模式串有关</span></span><br><span class="line"><span class="comment">// Next[i]存储以p[i]为结尾且与前缀匹配的最长后缀</span></span><br><span class="line"><span class="comment">// i为待匹配的后缀结尾字符，j为已匹配的前缀的结尾，j + 1表示待匹配的前缀字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];  <span class="comment">// 如果出现不匹配，就回退到上一次匹配的前缀位置</span></span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ; <span class="comment">// 如果匹配了，则前缀后移继续匹配，求出最长的匹配</span></span><br><span class="line">    ne[i] = j; <span class="comment">// 记录匹配的位置（不匹配的话会退到0）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j]; <span class="comment">// 如果出现不匹配，就回退到上一次匹配的前缀位置</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;<span class="comment">// 如果匹配了，则后移继续匹配</span></span><br><span class="line">    <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">        j = ne[j]; <span class="comment">// 回退到下一轮继续匹配的位置</span></span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-831-KMP字符串">1. <a href="https://www.acwing.com/activity/content/problem/content/869/">AcWing 831. KMP字符串</a></h3><h4 id="C-7">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespase std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;<span class="comment">// 读入字符串和其长度，注意这里数组从1开始</span></span><br><span class="line">    <span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">    <span class="comment">// 求模式串的next数组的过程；注意这里从1开始</span></span><br><span class="line">    ne[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//第一个匹配失败则一定重新开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// kmp匹配过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">            j = ne[j]; <span class="comment">// 方便下一次查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-6">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    p = <span class="string">&#x27; &#x27;</span> + <span class="built_in">input</span>()</span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + <span class="built_in">input</span>()</span><br><span class="line">    ne = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> j <span class="keyword">and</span> p[i] != p[j + <span class="number">1</span>]:</span><br><span class="line">            j = ne[j]</span><br><span class="line">        <span class="keyword">if</span> p[i] == p[j + <span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        ne[i] = j</span><br><span class="line">    </span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> j <span class="keyword">and</span> s[i] != p[j + <span class="number">1</span>]:</span><br><span class="line">            j = ne[j]</span><br><span class="line">        <span class="keyword">if</span> s[i] == p[j + <span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == n: <span class="comment"># j指向p的末尾则匹配成功</span></span><br><span class="line">            <span class="built_in">print</span>(i - j, end=<span class="string">&quot; &quot;</span>) <span class="comment"># 存储从下标1开始，但本题题目要求从0下标开始</span></span><br><span class="line">            j = ne[j]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="Tire树">Tire树</h2><p>基本用法：高效地<strong>存储和查找字符串集合</strong>地数据结构</p><p>可以查找是否出现过及出现过多少次。字符串末尾符号对应节点要打上标记，说明此字符串存在及出现次数。</p><p>利用树形结构共享存储</p><p>Tire树一般一定会限制字符范围是26个小写字母或52个大小写字母，或是很小范围内的数字</p><h3 id="模板-8">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-835-Trie字符串统计">1. <a href="https://www.acwing.com/problem/content/837/">AcWing 835. Trie字符串统计</a></h3><h4 id="C-8">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 835. Trie字符串统计</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 因为题目字符只能是小写字母，所以每个节点至多26条边</span></span><br><span class="line"><span class="comment">// 下标是0的点，既是根节点又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量，同时cnt以线性顺序表示每个节点</span></span><br><span class="line"><span class="comment">// idx表示当前用到的下标，注意下标是0的节点既是根节点又是空节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 先求当前字母对应的子节点编号，a-z映射到0-25</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++idx; <span class="comment">// 判断是否存在对应子节点，不存在则需创建</span></span><br><span class="line">        <span class="comment">// 注意这里用数组模拟链表，idx起指针作用</span></span><br><span class="line">        p = son[p][u]; <span class="comment">// 走到子节点， p存储子节点对应的cnt中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    ++ cnt[p]; <span class="comment">// 以该节点结尾的单词数量增加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 先求当前字母对应的子节点编号</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 判断是否存在对应子节点，不存在则直接返回</span></span><br><span class="line">        p = son[p][u]; <span class="comment">// 否则走进子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-7">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="built_in">int</span>(<span class="number">1e5</span> + <span class="number">5</span>)</span><br><span class="line">    son = [[<span class="number">0</span>] * <span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">    cnt = [<span class="number">0</span>] * N</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> idx</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> x:</span><br><span class="line">            u = <span class="built_in">ord</span>(v) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> son[p][u]:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">                son[p][u] = idx</span><br><span class="line">            p = son[p][u]</span><br><span class="line">        cnt[p] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">x</span>):</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> x:</span><br><span class="line">            u = <span class="built_in">ord</span>(v) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> son[p][u]:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            p = son[p][u]</span><br><span class="line">        <span class="keyword">return</span> cnt[p]</span><br><span class="line">        </span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        op, s = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            insert(s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(query(s))</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-143-最大异或对">2. <a href="https://www.acwing.com/problem/content/description/145/">AcWing 143. 最大异或对</a></h3><h4 id="C-9">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 143. 最大异或对</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">31</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], son[M][<span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; -- i)&#123;</span><br><span class="line">        <span class="type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!s) s = ++ idx;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; -- i)&#123;</span><br><span class="line">        <span class="type">int</span> s = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (son[p][!s])&#123;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = son[p][!s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = son[p][s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) res = <span class="built_in">max</span>(res, <span class="built_in">query</span>(a[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-8">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">100010</span></span><br><span class="line">    M = N * <span class="number">31</span></span><br><span class="line">    son = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(M)]</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> idx</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            u = x &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> son[p][u]:</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">                son[p][u] = idx</span><br><span class="line">            p = son[p][u]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">x</span>):</span><br><span class="line">        p, res = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            u = x &gt;&gt; i &amp; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> son[p][~u]:</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i</span><br><span class="line">                p = son[p][~u]</span><br><span class="line">            <span class="keyword">else</span>: p = son[p][u]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        insert(x)</span><br><span class="line">        res = <span class="built_in">max</span>(query(x), res)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="并查集">并查集</h2><p>操作：</p><ol><li class="lvl-3"><p>将两个集合合并</p></li><li class="lvl-3"><p>询问两个元素是否在一个集合当中</p></li></ol><p>并查集能够在近乎$O(1)$完成这两个操作</p><p>原理：</p><ul class="lvl-0"><li class="lvl-2"><p>每个集合用一棵树表示，树根的编号就是集合的编号</p></li><li class="lvl-2"><p>每个节点存储它的父节点，p[x]表示x的父节点</p></li></ul><p>技巧：</p><ol><li class="lvl-3"><p>如何判断树根：<input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">== x)</label></p></li><li class="lvl-3"><p>如何求x的集合编号：<input type="checkbox" id="checkbox4" checked="true"><label for="checkbox4">!= x) x = p[x]</label></p></li><li class="lvl-3"><p>如何合并两个集合： px是x的集合编号，py是y的集合编号，只需<input type="checkbox" id="checkbox5" checked="true"><label for="checkbox5">= y</label>（合并集合只需要增加一个从根节点到根节点的边）</p></li></ol><p>优化：</p><ul class="lvl-0"><li class="lvl-2"><p>路径压缩：找到根节点后，将走过的路径上所有节点的父节点都变成根节点（只会搜一遍，后面就不用遍历查找了）</p></li><li class="lvl-2"><p>按秩合并：在对两个不同子集连接时，按照rank来连，也就是rank低的连在rank高的下面。rank高的做父亲节点</p></li></ul><p>一般使用“路径压缩”，而“按秩合并”一般可不使用</p><p>并查集同时可以维护</p><ul class="lvl-0"><li class="lvl-2"><p>每个集合大小</p></li><li class="lvl-2"><p>每个节点到根节点的距离</p></li></ul><h3 id="模板-9">模板</h3><p>递归路径压缩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;       <span class="comment">//查找x元素所在的集合, 返回x的祖宗节点，回溯时压缩路径</span></span><br><span class="line">    <span class="keyword">if</span> (x != p[x])&#123;</span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);     <span class="comment">//回溯时的压缩路径</span></span><br><span class="line">    &#125;         <span class="comment">//从x结点搜索到祖先结点所经过的结点都指向该祖先结点</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归式</p><p>查两遍，第一遍找到祖宗节点并存储，第二遍更新路径上每个节点的父节点为祖宗节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k, j, r;</span><br><span class="line">    r = x;</span><br><span class="line">    <span class="keyword">while</span>(r != p[r])     <span class="comment">//查找根节点</span></span><br><span class="line">        r = p[r];      <span class="comment">//找到根节点，用r记录下</span></span><br><span class="line">    k = x;        </span><br><span class="line">    <span class="keyword">while</span>(k != r)&#123;            <span class="comment">//非递归路径压缩操作</span></span><br><span class="line">        j = p[k];         <span class="comment">//用j暂存parent[k]的父节点</span></span><br><span class="line">        p[k] = r;        <span class="comment">//p[x]指向跟节点</span></span><br><span class="line">        k = j;                    <span class="comment">//k移到父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;         <span class="comment">//返回根节点的值            </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) 朴素并查集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="comment">// 初始时每个节点的父节点为自身</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断操作</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并操作，合并a和b所在的两个集合</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b); <span class="comment">// 使a集合根节点插到b集合根节点下</span></span><br></pre></td></tr></table></figure><p>(2)维护集合大小size的并查集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)]; <span class="comment">// 合并时更新集合大小, 只用维护根节点size</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><p>(3)维护到祖宗节点距离的并查集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)&#123;</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">    p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; </span><br><span class="line"><span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure><h3 id="1-AcWing-836-合并集合">1. <a href="https://www.acwing.com/problem/content/838/">AcWing 836. 合并集合</a></h3><h4 id="C-10">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 836. 合并集合——朴素并查集</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d &quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];<span class="comment">// 注意这里不使用%c，防止出错</span></span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-2">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 836. 合并集合——朴素并查集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">100010</span></span><br><span class="line">    p = [<span class="number">0</span>] * N</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> p[x] != x:</span><br><span class="line">            p[x] = find(p[x])</span><br><span class="line">        <span class="keyword">return</span> p[x]</span><br><span class="line">        </span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># 注意题中编号从1开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        p[i] = i</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        m -= <span class="number">1</span></span><br><span class="line">        op, a, b = <span class="built_in">input</span>().split()</span><br><span class="line">        a, b = <span class="built_in">int</span>(a), <span class="built_in">int</span>(b)</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">            p[find(a)] = p[find(b)]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> find(a) == find(b):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-837-连通块中点的数量">2. <a href="https://www.acwing.com/problem/content/839/">AcWing 837. 连通块中点的数量</a></h3><h4 id="C-11">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 837. 连通块中点的数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        string op ;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;C&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) != <span class="built_in">find</span>(b))&#123;</span><br><span class="line">                cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];</span><br><span class="line">                p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;Q1&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-9">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 837. 连通块中点的数量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">100010</span></span><br><span class="line">    p = [<span class="number">0</span>] * N</span><br><span class="line">    cnt = [<span class="number">0</span>] * N</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> p[x] != x:</span><br><span class="line">            p[x] = find(p[x])</span><br><span class="line">        <span class="keyword">return</span> p[x]</span><br><span class="line">    </span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        p[i] = i</span><br><span class="line">        cnt[i] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        m -= <span class="number">1</span></span><br><span class="line">        op, *num = <span class="built_in">input</span>().split()</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            a, b = <span class="built_in">int</span>(num[<span class="number">0</span>]), <span class="built_in">int</span>(num[<span class="number">1</span>])</span><br><span class="line">            a, b = find(a), find(b)</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                cnt[b] += cnt[a]</span><br><span class="line">                p[a] = b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&#x27;Q1&#x27;</span>:</span><br><span class="line">            a, b = <span class="built_in">int</span>(num[<span class="number">0</span>]), <span class="built_in">int</span>(num[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> find(a) == find(b): <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>: <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = <span class="built_in">int</span>(num[<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">print</span>(cnt[find(a)])</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="堆">堆</h2><p>堆即优先队列</p><p>操作：</p><ol><li class="lvl-3"><p>插入一个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[++ size] = x; <span class="built_in">up</span>(size)</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>求集合当中的最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>删除最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>] = heap[size];</span><br><span class="line">size--;</span><br><span class="line"><span class="built_in">down</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>删除任意一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = heap[size];</span><br><span class="line">size --;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>修改任意一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heap[k] = x;</span><br><span class="line"><span class="built_in">down</span>(k);</span><br><span class="line"><span class="built_in">up</span>(k);</span><br></pre></td></tr></table></figure></li></ol><p>堆是完全二叉树，除了最后一层节点都是满的</p><p>小根堆：父节点小于两个子节点</p><p>大根堆：父节点大于两个子节点</p><p>模拟堆：使用数组存储二叉树</p><p>x左儿子：2x</p><p>x右儿子：2x+1</p><p>删除元素时之所以需要用最后一个元素替换待删除元素是因为数组模拟时显然最后一个位置方便删除而之前的位置不容易删除。所以采用替换删除的策略。</p><h3 id="模板-10">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)&#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-838-堆排序">1. <a href="https://www.acwing.com/activity/content/problem/content/888/">AcWing 838. 堆排序</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], cnt;</span><br><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// cnt为当前节点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t )&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>] &gt; h[u])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u/<span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    cnt = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// O(n)建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; -- i) <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[cnt--];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-839-模拟堆">2. <a href="https://www.acwing.com/activity/content/problem/content/889/">AcWing 839. 模拟堆</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟堆</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], cnt;</span><br><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// cnt为当前节点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u*<span class="number">2</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u*<span class="number">2</span>+<span class="number">1</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t )&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>] &gt; h[u])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u/<span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    cnt = n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// O(n)建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i;--i) <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[cnt--];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[N], backup[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i &lt; m; ++ j)&#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表">哈希表</h2><p>哈希表的作用：把庞大复杂的数据映射到较小的范围。通常的范围是0到$10<sup>5$或$10</sup>6$<br>$h(x)$ 可以把数据进行映射，称为哈希函数。我们可以这么考虑：</p><p>$\large{h(x)=x\ \text{mod}\ 10003}$ 。</p><ul class="lvl-0"><li class="lvl-2"><p>若干不同的数倍映射成相同的数，称为<strong>哈希冲突</strong>。</p></li><li class="lvl-2"><p>对于冲突的处理：根据处理方法的不同，分为<strong>拉链法</strong>和<strong>开放寻址法</strong>。</p><ul class="lvl-2"><li class="lvl-4"><p>拉链法</p><p>设 $h(11)=3$ ， $h(23)=3$，这就是一种冲突。我们可以设一个数组 h，也就是哈希的结果。对于每一个结果，建立一个链表。把映射为 $k$ 的所有数 $x$ 都放在 $h[k]$ 这个链表里。</p></li><li class="lvl-4"><p>开放寻址法</p><p>设 $h(x)=k$ 。也就是 $x$ 的哈希值为 $k$ 。如果在 $hash[k]$ 的位置已经有元素，持续往后遍历直到找到 $&gt;x$（询问）或为空（插入）为止。注意开放寻址法一般会把数组开到数据范围的 $2-3$ 倍，能提高效率。</p></li></ul></li></ul><p><strong>时间复杂度</strong> $O(1)$ ，<strong>空间复杂度</strong> $O(n)$</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230302204426872-1677763159454-1.png" alt="image-20230302204426872"></p><p><img src="https://mdpic.dreamgo.fun/img/2675_a57c16b958-1.jpg" alt="2675_a8539bec58-2"></p><p><img src="https://mdpic.dreamgo.fun/img/2675_a8539bec58-2.jpg" alt="2675_a8539bec58-2"></p><p><img src="https://mdpic.dreamgo.fun/img/2675_ac826b7458-3.jpg" alt="2675_ac826b7458-3"></p><p><img src="https://mdpic.dreamgo.fun/img/2675_9b33804c58-4.jpg" alt="2675_9b33804c58-4"></p><p><img src="https://mdpic.dreamgo.fun/img/2675_a204a13158-5.jpg" alt="2675_a204a13158-5"></p><h3 id="模板-11">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-840-模拟散列表">1. <a href="https://www.acwing.com/problem/content/842/">AcWing 840. 模拟散列表</a></h3><h4 id="C-12">C++</h4><p>拉链法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 840. 模拟散列表</span></span><br><span class="line"><span class="comment">// 哈希——拉链法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">3</span>; <span class="comment">// 取大于1e5的第一个质数，取质数冲突的概率最小。这个需要事先求一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开一个槽 h</span></span><br><span class="line"><span class="comment">// h存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int n;</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx; <span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++; <span class="comment">// 头插法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 用上面同样的 Hash函数 将x映射到 从 0-1e5 之间的数</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将槽先清空 空指针一般用 -1 来表示</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        string op; </span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开放地址法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 840. 模拟散列表</span></span><br><span class="line"><span class="comment">// 哈希——开放地址法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">3</span>; <span class="comment">// 取大于数据范围的 2~3倍的第一个质数，取质数冲突的概率最小。这个需要事先求一下</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> null = <span class="number">0x3f3f3f3f</span>; <span class="comment">//规定空指针为 null 0x3f3f3f3f，用于标记当前位置是否已被占</span></span><br><span class="line"><span class="comment">// 之所以使用0x3f3f3f3f标记，因为其在输入数据范围之外</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开一个槽 h</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// find查找对应位置，如果不存在, 则返回的是应该存储到的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)&#123;</span><br><span class="line">        t ++;</span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化，规定空指针为 0x3f3f3f3f</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        string op; </span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>) h[<span class="built_in">find</span>(x)] = x; <span class="comment">// 如果不存在, 则find()返回的是应该存储到的位置</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (h[<span class="built_in">find</span>(x)] == null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-10">Python</h4><p>拉链法</p><p>str.isalpha()实现的是如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 840. 模拟散列表</span></span><br><span class="line"><span class="comment"># 哈希——拉链法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    MAX_N = <span class="built_in">int</span>(<span class="number">1e5</span> + <span class="number">3</span>) <span class="comment"># 大于数据范围的最小质数</span></span><br><span class="line">    <span class="comment"># 头节点h初始时全部赋为空指针-1</span></span><br><span class="line">    h, e, ne = [-<span class="number">1</span>] * MAX_N, [<span class="number">0</span>] * MAX_N, [<span class="number">0</span>] * MAX_N</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找插入位置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> idx</span><br><span class="line">        <span class="comment"># 先模再加再模，可以让负数映射为自然数</span></span><br><span class="line">        k = (x % MAX_N + MAX_N) % MAX_N</span><br><span class="line">        e[idx] = x</span><br><span class="line">        ne[idx] = h[k]</span><br><span class="line">        h[k] = idx</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">x</span>):</span><br><span class="line">        k = (x % MAX_N + MAX_N) % MAX_N</span><br><span class="line">        ptr = h[k]</span><br><span class="line">        <span class="comment"># 算出映射位置后，进行遍历查找</span></span><br><span class="line">        <span class="keyword">while</span> ptr != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> e[ptr] == x:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            ptr = ne[ptr]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># str.isalpha()实现的是如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False</span></span><br><span class="line">        op, x = <span class="built_in">map</span>(<span class="keyword">lambda</span> x : x <span class="keyword">if</span> x.isalpha() <span class="keyword">else</span> <span class="built_in">int</span>(x), <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            add(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span> <span class="keyword">if</span> contains(x) <span class="keyword">else</span> <span class="string">&quot;No&quot;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>开放寻址法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 840. 模拟散列表</span></span><br><span class="line"><span class="comment"># 哈希——开放寻址法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    MAX_N = <span class="built_in">int</span>(<span class="number">2e5</span> + <span class="number">3</span>) <span class="comment"># 大于数据范围2到3倍的最小质数</span></span><br><span class="line">    hs = [<span class="literal">None</span>] * MAX_N <span class="comment"># 用None标记是否已被占用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开放寻址法，映射后找可以插入的位置（或者找到 x 的位置）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">        pos = (x % MAX_N + MAX_N) % MAX_N</span><br><span class="line">        <span class="keyword">while</span> hs[pos] != x <span class="keyword">and</span> hs[pos] != <span class="literal">None</span>:</span><br><span class="line">           pos = (pos + <span class="number">1</span>) % MAX_N</span><br><span class="line">        <span class="keyword">return</span> pos</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># str.isalpha()实现的是如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False</span></span><br><span class="line">        op, x = <span class="built_in">map</span>(<span class="keyword">lambda</span> x : x <span class="keyword">if</span> x.isalpha() <span class="keyword">else</span> <span class="built_in">int</span>(x), <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            hs[find(x)] = x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span> <span class="keyword">if</span> hs[find(x)] != <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&quot;No&quot;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="字符串哈希">字符串哈希</h2><p>字符串哈希用于快速比较两个子串是否完全相同，复杂度为$O(n)+O(m)$ ，原理本质上是<strong>前缀哈希+前缀和</strong>。</p><p>全称字符串前缀哈希法，把字符串变成一个 p 进制数字（哈希值），实现不同的字符串映射到不同的数字。对形如 $X_1X_2X_3\cdots X_{n-1}X_n$ 的字符串, 采用字符的 ASCII 码乘上 P 的次方来计算哈希值。</p><p>映射公式<br>$$<br>(X_1 \times P^{n-1} + X_2 \times P^{n-2} + \cdots + X_{n-1} \times P^1 + X_n \times P^0) \bmod Q<br>$$</p><p>注意点：</p><ol><li class="lvl-3"><p>任意字符不可以映射成 0，否则会出现不同的字符串都映射成 0 的情况，比如 A,AA,AAA 皆为 0</p></li><li class="lvl-3"><p>冲突问题：通过巧妙设置 P (131 或 13331) , Q $(2^{64})$ 的值，一般可以理解为不产生冲突。</p><p>M=998244353</p></li></ol><p>问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。</p><p>前缀和公式:<br>$$<br>h[i+1] = h[i] \times P + s[i], \ i \in [0,n-1]<br>$$<br>h 为前缀和数组，s 为字符串数组</p><p>区间和公式:<br>$$<br>h[l,r] = h[r] - h[l-1] \times P^{r-l+1}<br>$$</p><p>区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，乘上 $P^2$ 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。</p><p><img src="https://mdpic.dreamgo.fun/img/2675_6024b68258-3.jpg" alt="2675_6024b68258-3"></p><p><img src="https://mdpic.dreamgo.fun/img/2675_63495d4a58-4.jpg" alt="2675_63495d4a58-4"></p><p><img src="https://mdpic.dreamgo.fun/img/image-202303022040266.png" alt="image-202303022040266"></p><p><img src="https://mdpic.dreamgo.fun/img/2675_5cc1dc5458-2.jpg" alt="2675_5cc1dc5458-2"></p><h3 id="模板-12">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-AcWing-841-字符串哈希">1. <a href="https://www.acwing.com/problem/content/843/">AcWing 841. 字符串哈希</a></h3><p>判断任意两个区间包含的子串是否完全相同</p><h4 id="C-13">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 841. 字符串哈希</span></span><br><span class="line"><span class="comment">// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字</span></span><br><span class="line"><span class="comment">// 使用场景： 两个字符串的子串是否相同</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N], p[N]; </span><br><span class="line"><span class="comment">// h[i]前i个字符的hash值</span></span><br><span class="line"><span class="comment">// 用 p 数组存储 p 的幂, p[i] 表示 p 的 i 次幂</span></span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第0位对应位权为1</span></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 与前缀和相同，下标从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="comment">// 采用前缀和的方法计算 P进制每位的位权 和 字符串前缀对应的hash值</span></span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P; </span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i - <span class="number">1</span>]; <span class="comment">// 注意这里str的i-1对应于h的i(str下标从0开始)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果子串对应hash值相同，则两字符串完全相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-11">Python</h4><p>C++ 可以使用 <code>unsigned long long</code> 自动溢出来对 <code>(1 &lt;&lt; 64) - 1</code> 取模，Python / Java 需手动取模并注意取模时的括号范围。</p><p>内置函数 ord ()用于返回字符的ASCII码用法：<code>ord('C')</code>参数是一个字符，不能是字符串，返回该字符对应的Unicode码</p><p>对应的还是有ord()函数的配对函数chr()<br>chr()的作用是：输入一个十进制或十六进制数字，返回其在Unicode编码中对应的文字或符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 841. 字符串哈希</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    P, MOD = <span class="number">131</span>, (<span class="number">1</span> &lt;&lt; <span class="number">64</span>)</span><br><span class="line">    <span class="comment"># P取131或13331，M取1 &lt;&lt; 64，一般不产生冲突</span></span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    hs, bs = [<span class="number">0</span>] * (n + <span class="number">1</span>), [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 注意由于前缀和从1开始，所以需要多开一位</span></span><br><span class="line">    <span class="comment"># bs[0] 应为1（0次幂）， hs[0] 应为0（避免影响前缀和）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">l, r</span>):</span><br><span class="line">        <span class="comment"># 取 [L, R] 范围内的字符串哈希值</span></span><br><span class="line">        <span class="comment"># 通过这种方式减去高位（[0, L] 范围内的字符串）的哈希值</span></span><br><span class="line">        <span class="keyword">return</span> (hs[r] - hs[l - <span class="number">1</span>] * bs[r - l + <span class="number">1</span>]) % MOD</span><br><span class="line">        <span class="comment"># 无法自动溢出，需要取模hash</span></span><br><span class="line">        </span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    <span class="comment"># 所以需要多开一位</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 取模hash</span></span><br><span class="line">        bs[i] = (bs[i - <span class="number">1</span>] * P) % MOD</span><br><span class="line">        <span class="comment"># ord ()用于返回字符的ASCII码</span></span><br><span class="line">        hs[i] = (hs[i - <span class="number">1</span>] * P + <span class="built_in">ord</span>(s[i - <span class="number">1</span>])) % MOD</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        l1, r1, l2, r2 = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 哈希值相等则字符串完全相同</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span> <span class="keyword">if</span> get(l1, r1) == get(l2, r2) <span class="keyword">else</span> <span class="string">&quot;No&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课1 基础算法</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基础算法">基础算法</h1><h2 id="一-快速排序">一. 快速排序</h2><p>应用了分治思想和双指针方法，是一种暴力而优美方法，是不稳定的排序</p><p><img src="https://mdpic.dreamgo.fun/img/sort.png" alt="sort"></p><p>算法流程：快速排序算法通过多次比较和交换来实现排序，其排序流程如下：</p><ol><li class="lvl-3"><p>首先设定一个分界值，通过该分界值将数组分成左右两部分。</p></li><li class="lvl-3"><p>将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于分界值，而右边部分中各元素都大于或等于分界值。</p></li><li class="lvl-3"><p>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p></li><li class="lvl-3"><p>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。</p></li></ol><p>排序步骤：</p><ol><li class="lvl-3"><p>确定分界点:可以为左端点、右端点、中点或随机点（常用中点）</p></li><li class="lvl-3"><p>调整区间，一分为二：将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。</p></li><li class="lvl-3"><p>递归处理左右两段<br><img src="https://mdpic.dreamgo.fun/img/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt="快速排序"></p></li></ol><p>注意有许多边界问题，要熟记模板</p><h3 id="模板">模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// (l + r &gt;&gt; 1)使l+r的值右移1位，相当l+r的值除以2取整。</span></span><br><span class="line">    <span class="comment">// i，j为左右两个端点的两侧的指针。注意之所以分别加减1是因为默认会先把指针向中间移动再进行比较，所以这里先移动到左右端点的两侧</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) <span class="comment">// 一般循环结束时，i == j + 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j-- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, j), quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 注意当写成quick_sort(q, l , i - 1),quick_sort(q, l, i)，x不能取q[l]（调用左指针时，不取左端点）例如样例为1，2时会陷入死循环</span></span><br><span class="line">    <span class="comment">// 写成quick_sort(q,j + 1, r)时，x 不能取q[r]（调用右指针时，不取右端点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左端点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span>(q[i] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, j), quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-786-第k个数"><a href="https://www.acwing.com/activity/content/problem/content/820/">AcWing 786. 第k个数</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序AcWing 786. 第k个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// (l + r &gt;&gt; 1)使l+r的值右移1位，相当l+r的值除以2取整。</span></span><br><span class="line">    <span class="comment">// i，j为左右两个端点的两侧的指针。注意之所以分别加减1是因为默认会先把指针向中间移动再进行比较，所以这里先移动到左右端点的两侧</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) <span class="comment">// 一般循环结束时，i == j + 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j-- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(l, j), quick_sort(j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 注意当写成quick_sort(q, l , i - 1),quick_sort(q, l, i)，x不能取q[l]（调用左指针时，不取左端点）例如样例为1，2时会陷入死循环</span></span><br><span class="line">    <span class="comment">// 写成quick_sort(q,j + 1, r)时，x 不能取q[r]（调用右指针时，不取右端点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">        </span><br><span class="line">    quick_sort(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q[k<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><p>基本思想也是分治，分治方法与快排不同，是排序稳定。也使用了双指针算法</p><p>归并先递归再操作，快排先操作再递归</p><p>归并操作的工作原理如下：第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾</p><p>排序步骤：</p><ol><li class="lvl-3"><p>确定分界点：以数组的中间为分界点mid=(l+r)/2</p></li><li class="lvl-3"><p>递归分治排序left，right两个部分</p></li><li class="lvl-3"><p>归并——合二为一，两个有序序列从左到右进行一个个比较，大的放入数组</p><p>相等时先放第一个序列中的数，因此归并排序是稳定的</p></li></ol><p><img src="https://mdpic.dreamgo.fun/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="归并排序"></p><h3 id="模板-2">模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="comment">//递归的终止情况——双指针 l &gt;= r</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一步：分成子问题</span></span><br><span class="line">    <span class="comment">// 求出中点</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 位运算</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二步：递归处理子问题</span></span><br><span class="line">    <span class="comment">// 先递归排序两部分</span></span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第三步：合并子问题</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 利用辅助数组进行排序并归并</span></span><br><span class="line">    <span class="comment">// 辅助数组的左端点为0，而原数组左部分左端点为l，右部分左端点为mid + 1</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="comment">// 为了保持稳定，遇到相同值时先放左半部分的</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    <span class="comment">// 比较完后剩余的直接放进去即可</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里很易错，仍使用双指针</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-788-逆序对的数量"><a href="https://www.acwing.com/problem/content/790/">AcWing 788. 逆序对的数量</a></h3><p>求解逆序对的数量，我们首先理解什么是逆序对，其性质是什么。</p><p>经研究可以发现，一个数后面有多少小于它的数，这个数就会有多少逆序对。并且经过排序后，其逆序对个数等于现位置坐标 - 原位置坐标（中间插入的数的个数即为小于它且位于它后面的数的数量）。这是一种先排序再求解的思路，为了同时存储现位置和原位置，需要用到pair。</p><p>现在，让我们思考一下能否在排序的同时记录数量，这就减少了复杂度。只要我们能在一个较小数重排到较大数的前面时加1即可。这种思路显然必须要选择一种相对前后位置只发生一次变化的排序方法（避免重复记录）。这时候我们可以考虑归并排序。</p><p>归并排序是一种及其特殊的排序方法。其排序方法是递归的，且边界情况是两个相邻项的排序，这种思想和许多dp问题都是不谋而合的。相邻项一旦排好，其相对前后位置便在后续递归中不再变化。因而我们可以使用归并排序，并在排序的同时记录个数。</p><h4 id="C">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序——AcWing 788. 逆序对的数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l ,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">// 位运算</span></span><br><span class="line">    <span class="comment">// 求出中点</span></span><br><span class="line">    LL res = <span class="built_in">merge_sort</span>(l, mid) + <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 加上下层递归求得的逆序对个数</span></span><br><span class="line">    <span class="comment">// 先递归排序两部分</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 利用辅助数组进行排序并归并</span></span><br><span class="line">    <span class="comment">// 辅助数组的左端点为0，而原数组左部分左端点为l，右部分左端点为mid + 1</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="comment">// 为了保持稳定，遇到相同值时先放左半部分的</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 每当有一个右半部分的数小于左半部分的数时，就增加左半部分剩余元素数个逆序对。</span></span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    <span class="comment">// 比较完后剩余的直接放进去即可</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j= <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tmp[j];</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">merge_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序——AcWing 788. 逆序对的数量</span></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l ,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="built_in">merge_sort</span>(l, mid) + <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k =<span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) &#123;</span><br><span class="line">            res += j - mid - <span class="number">1</span>;</span><br><span class="line">            tmp[k++] = q[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)&#123; tmp[k++] = q[i++]; res += j - mid - <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; ++ i, ++ j) q[i] = tmp[j];</span><br><span class="line">    <span class="keyword">return</span> res;         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">merge_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序——AcWing 788. 逆序对的数量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">l, r</span>):</span><br><span class="line">        <span class="comment"># 区间内元素个数小于两个</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 找区间中点</span></span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.递归分治</span></span><br><span class="line">        merge_sort(l, mid)</span><br><span class="line">        merge_sort(mid + <span class="number">1</span>, r)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 归并</span></span><br><span class="line">        k, i, j = <span class="number">0</span>, l, mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> q[i] &lt;= q[j]:</span><br><span class="line">                tmp[k] = q[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp[k] = q[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># while i &lt;= mid:</span></span><br><span class="line">        <span class="comment">#     tmp[k] = q[i]</span></span><br><span class="line">        <span class="comment">#     i += 1</span></span><br><span class="line">        <span class="comment">#     k += 1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># while j &lt;= r:</span></span><br><span class="line">        <span class="comment">#     tmp[k] = q[j]</span></span><br><span class="line">        <span class="comment">#     j += 1</span></span><br><span class="line">        <span class="comment">#     k += 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 直接使用切片</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;= mid <span class="keyword">or</span> j &lt;= r:</span><br><span class="line">            st, cnt = (i, mid - i + <span class="number">1</span>) <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> (j, r - j + <span class="number">1</span>)</span><br><span class="line">            tmp[k:k + cnt] = q[st:st + cnt]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 赋值回原数组</span></span><br><span class="line">        <span class="comment"># 直接使用切片</span></span><br><span class="line">        <span class="comment"># q[l:r + 1] = tmp[:k] # 注意k最后会加1，所以切片时不是k+1</span></span><br><span class="line">        q[l:r + <span class="number">1</span>] = tmp[:r - l + <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    q = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    tmp = [<span class="number">0</span>] * n</span><br><span class="line">    merge_sort(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, q)))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="二分">二分</h2><p>有单调性一定可以二分，可以二分的题目不一定必须单调</p><p>二分的本质是，根据某一性质将区间左右一分为二，使一部分满足该性质，另一部分不满足该性质。</p><p>如果可以找到一个性质使区间左右一分为二（一部分满足，一部分不满足），二分就可以找到性质的边界。</p><p>二分问题要满足的条件：</p><ol><li class="lvl-3"><p>确定一个区间，使得目标值一定在区间中</p></li><li class="lvl-3"><p>找一个性质，满足：</p><ul class="lvl-2"><li class="lvl-6">性质具有二段性</li><li class="lvl-6">答案是二段性的分界点</li></ul></li></ol><p>二分问题一定满足1，95%满足2。</p><h3 id="整数二分">整数二分</h3><p>整数二分时根据性质分成的两部分没有交集。</p><p>分为两类：分界点在左半部分或分界点在右半部分。</p><p>二分时，根据性质将区间一分为二，每次选择答案所在区间进行进一步处理。区间长度为一时即为答案。</p><p>当分界点在左半部分时，之所以$ mid = \frac{l+r+1}{2} $多加一个1是为了避免mid = l导致更新时l = mid会不发生变化，陷入死循环（这种情况出现在l = r - 1时）。话句话说，保证区间为2时mid取右侧而不是左侧。（分界点在左侧）</p><p>最后l和r是一定相等的,但是mid不一定等于l，可能是mid-1等于l。二段性的分界点就是答案说的就是最终l等于r。l和r维护一个区间，对于整数二分，当区间长度为1时，就是分界点。</p><p>二分的一大作用：求上界函数和下界函数<img src="https://mdpic.dreamgo.fun/img/QQ%E5%9B%BE%E7%89%8720230304222111.jpg" alt="QQ图片20230304222111"></p><p>整数二分步骤：</p><ol><li class="lvl-3"><p>找一个区间[L, R]，使得答案一定在该区间中</p></li><li class="lvl-3"><p>找一个判断条件，使得该判断条件具有二段性，并且答案一定是该二段性的分界点</p></li><li class="lvl-3"><p>分析终点M在该判断条件下是否成立，如果成立，考虑答案在哪个区间；如果不成立，考虑答案再哪个区间</p><ul class="lvl-2"><li class="lvl-5">如果条件成立（性质满足）的区间在左部，则为&lt;= x型，采用L=mid模板</li><li class="lvl-5">如果条件成立（性质满足）的区间在右部，则为&lt;= x型，采用R=mid模板</li></ul></li><li class="lvl-3"><p>如果更新方式写的是R = mid，则不用做任何处理；如果更新方式写的是L = mid，则需要在计算mid时加上1</p></li></ol><h4 id="模板-3">模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 性质判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右半部分满足性质，如大于等于x的数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123; <span class="comment">// 区间长度大于等于1</span></span><br><span class="line">        <span class="comment">// 分界点在右半部分，如大于等于某个数的最小值</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//int mid = l + (r - l) / 2; // 避免溢出问题</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="comment">// 成立时，对右端点更新且包含mid(分界点在成立区间得左端)</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">// 最终l==r，l和r都是答案，但mid不一定是答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左半部分满足性质，如小于等于x的数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分界点在左半部分，如小于等于某个数的最大值</span></span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//int mid = l + (r - l + 1) / 2; // 避免溢出问题</span></span><br><span class="line">        <span class="comment">// 当分界点在左半部分时，之所以$mid = \frac&#123;l+r+1&#125;&#123;2&#125;$多加一个1是为了避免mid = l导致更新时l = mid会不发生变化，陷入死循环（这种情况出现在l = r - 1时）。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="comment">// 成立时，对左端点更新且包含mid(分界点在成立区间得右端)</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 不成立时，对右端点更新，且不包含mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">// 最终l==r，l和r都是答案，但mid不一定是答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-789-数的范围"><a href="https://www.acwing.com/problem/content/791/">AcWing 789. 数的范围</a></h4><h5 id="C-2">C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数二分——AcWing 789. 数的范围</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) <span class="comment">// 区间长度大于等于1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分界点在右半部分</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (q[mid] &gt;= k) r = mid;</span><br><span class="line">        <span class="comment">// 成立时，对右端点更新且包含mid(分界点在成立区间得左端)</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">// 最终l==r</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分界点在左半部分</span></span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 当分界点在左半部分时，之所以$mid = \frac&#123;l+r+1&#125;&#123;2&#125;$多加一个1是为了避免mid = l导致更新时l = mid会不发生变化，陷入死循环（这种情况出现在l = r - 1时）。</span></span><br><span class="line">        <span class="keyword">if</span> (q[mid] &lt;= k) l = mid;</span><br><span class="line">        <span class="comment">// 成立时，对左端点更新且包含mid(分界点在成立区间得右端)</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 不成立时，对右端点更新，且不包含mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">// 最终l==r</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="comment">// 求k的起始位置，利用 x &gt;= k的性质二分</span></span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">bsearch_1</span>(<span class="number">0</span>, n<span class="number">-1</span>, k);</span><br><span class="line">        <span class="comment">// 注意判断是否存在的方法——如果边界值不等于k，说明数组中不存在k</span></span><br><span class="line">        <span class="keyword">if</span> (q[a] != k) <span class="built_in">puts</span>(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> b = <span class="built_in">bsearch_2</span>(<span class="number">0</span>, n<span class="number">-1</span>, k);</span><br><span class="line">            <span class="comment">// 求k的终止位置，利用 x &lt;= k的性质二分</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Python">Python</h5><p>手写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整数二分——AcWing 789. 数的范围</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lower_bound</span>(<span class="params">l, r</span>):</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> q[mid] &gt;= k: r = mid</span><br><span class="line">            <span class="keyword">else</span>: l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">upper_bound</span>(<span class="params">l ,r</span>):</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> q[mid] &lt;= k: l = mid</span><br><span class="line">            <span class="keyword">else</span>: r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line">        </span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    q = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        l = lower_bound(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> q[l] != k:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-1 -1&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = upper_bound(<span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(l, r)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ ==  <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>使用bisect库，速度略慢点</p><p>bisect.bisect和bisect.bisect_right返回大于x的第一个下标(相当于C++中的upper_bound)</p><p>bisect.bisect_left返回大于等于x的最左侧第一个下标</p><p>当x存在多个时，bisect_left返回最左边的x的索引bisect_right返回最右边的x的索引加1；如果元素不存在，则返回将其插入到何处<br>eg: l = [1, 4, 5]，bisect_left(l, 4)返回1，bisect_left(l, 2)返回1，bisect_left(l, 6)返回3</p><p>因为bisect返回大于x的最左的第一个下标，所以其减一即得到小于等于x的最右侧的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整数二分——AcWing 789. 数的范围</span></span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect, bisect_left</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    q = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        k = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        l = bisect_left(q, k)</span><br><span class="line">        <span class="comment"># 这里需要注意，如果元素不存在，则返回将其插入到何处，因而返回值可能越界（插在最后一个元素后面），需要特判</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= n <span class="keyword">or</span> q[l] != k: </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-1 -1&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = bisect(q, k) - <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(l, r)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ ==  <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="实数-浮点数二分">实数/浮点数二分</h3><p>二分时，根据二段性性质将区间一分为二，每次选择答案所在区间进行进一步处理。浮点数二分没有整除问题，每次区间严格缩小一半，因而比较容易写。但由于区间长度可以无限小，一般无法求出精确的分界点。通常区间长度为足够小时（规定一个精度）即为答案。一般取得精度要求的答案小两位。或者规定迭代次数，迭代到规定次数即为答案（每循环一次区间长度缩小二分之一）。</p><h4 id="模板-4">模板</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">double</span> x)</span>&#123;&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;  </span><br><span class="line">    <span class="comment">//精度一般比要求保留的位数大2就可以</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)&#123; <span class="comment">// 区间长度大于精度</span></span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-790-数的三次方根"><a href="https://www.acwing.com/problem/content/792/">AcWing 790. 数的三次方根</a></h4><p>三次方根具有单调性，因而可以直接使用二分法求解。要求精度是6位，相当于数据数量级在$ 10^{10} $ ，而$n &lt;= n^{18} $时都可以使用$O(logn)$的二分算法。</p><h5 id="C-3">C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浮点数二分——AcWing 790. 数的三次方根</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="comment">//精度一般比要求保留的位数大2就可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> l = <span class="number">-100</span>, r = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 根据数据范围确定解的区间范围</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)<span class="comment">// 区间长度大于精度即可返回</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid * mid &gt;= x) r = mid;</span><br><span class="line">        <span class="comment">// 使用二分法求解三次方根</span></span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="python-2">python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点数二分——AcWing 790. 数的三次方根</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    l, r = -<span class="number">100</span>, <span class="number">100</span></span><br><span class="line">    x = <span class="built_in">float</span>(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">    eps = <span class="number">1e-8</span></span><br><span class="line">    <span class="keyword">while</span> r - l &gt; eps:</span><br><span class="line">        mid = (l + r ) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid ** <span class="number">3</span> &gt;= x:</span><br><span class="line">            r = mid </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%.6f&quot;</span> % l)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="高精度加法">高精度加法</h2><h3 id="AcWing-791-高精度加法">AcWing 791. 高精度加法</h3><p>为了便于进位，要把数在数组中倒置存储（个位存最前面），因为在数组的末尾补数更容易。</p><p>每一位单独进行运算并处理进位问题</p><p>减法要处理借位问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size()) <span class="keyword">return</span> add(B, A);</span><br><span class="line">    <span class="comment">// 位数多的放前面</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// t用于表示进位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++ i)&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i]; </span><br><span class="line">        <span class="comment">// 注意判断较小数的位数</span></span><br><span class="line">        <span class="comment">// 加上当前位的数值</span></span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">// 求出进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="comment">// 最后的进位单独处理</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++ i)&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++ i)&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt;B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-791-高精度加法-2"><a href="https://www.acwing.com/problem/content/793/">AcWing 791. 高精度加法</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度加法——不压位——AcWing 791. 高精度加法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size()) <span class="keyword">return</span> add(B, A);</span><br><span class="line">    <span class="comment">// 位数多的放前面</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// t用于表示进位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++ i)&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i]; </span><br><span class="line">        <span class="comment">// 注意判断较小数的位数</span></span><br><span class="line">        <span class="comment">// 加上当前位的数值</span></span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">// 求出进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="comment">// 最后的进位单独处理</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 不建议使用scanf 输入string类型字符串</span></span><br><span class="line">    <span class="comment">// 如果使用scanf，必须要为string提前分配足够空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">// 字符串转化为整数数组</span></span><br><span class="line">    <span class="comment">// 注意倒着存储，高位在后，方便进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度加法——压九位——AcWing 791. 高精度加法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size()) <span class="keyword">return</span> add(B, A);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % base);</span><br><span class="line">        t /= base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        s += (a[i] - <span class="string">&#x27;0&#x27;</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            A.push_back(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.size() - <span class="number">1</span>, s = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        s += (b[i] - <span class="string">&#x27;0&#x27;</span>) * t;</span><br><span class="line">        j ++, t *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">9</span> || i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            B.push_back(s);</span><br><span class="line">            s = j = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = add(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; C.back();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i -- ) <span class="built_in">printf</span>(<span class="string">&quot;%09d&quot;</span>, C[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>##高精度减法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>;i &lt; A.size(); ++ i)&#123;</span><br><span class="line">        <span class="comment">// t表示借位</span></span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="comment">// 先减去借位</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i];</span><br><span class="line">        <span class="comment">// 注意判断较小数的位数</span></span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// (a + r) % r得到的余数一定是正余数</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// t &lt; 0说明借位了，借位一定是借了1</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 没借位则t为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="comment">// 注意需要处理前导零的问题（这里高位在后，前导零也在最后），但当只有一位是0必须保留</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.size(); ++ i)&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i];</span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.size(); ++ i)&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i];</span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-792-高精度减法"><a href="https://www.acwing.com/problem/content/794/">AcWing 792. 高精度减法</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度减法——AcWing 792. 高精度减法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断A和B的大小关系，A更大返回true，B更大返回false</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() !=  B.size()) <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意一位一位比较时，从最高位开始比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i]) </span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.size(); ++ i)&#123;</span><br><span class="line">        <span class="comment">// t表示借位</span></span><br><span class="line"></span><br><span class="line">        t = A[i] - t; <span class="comment">// 先减去借位</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i]; <span class="comment">// 注意判断较小数的位数</span></span><br><span class="line"></span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// (a + r) % r得到的余数一定是正余数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// t &lt; 0说明借位了，借位一定是借了1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>; <span class="comment">// 没借位则t为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="comment">// 注意需要处理前导零的问题（这里高位在后，前导零也在最后），但当只有一位是0必须保留</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a, b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 不建议使用scanf 输入string类型字符串</span></span><br><span class="line">    <span class="comment">// 如果使用scanf，必须要为string提前分配足够空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">// 字符串转化为整数数组</span></span><br><span class="line">    <span class="comment">// 注意倒着存储，高位在后，方便进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = b.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) B.push_back(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; </span><br><span class="line">    C;    </span><br><span class="line">    <span class="comment">// 判断A和B的大小关系，默认A更大</span></span><br><span class="line">    <span class="keyword">if</span> (cmp(A,B)) C = sub(A, B);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>); <span class="comment">// 小减大，先输出负号，然后当作大减小处理</span></span><br><span class="line">        <span class="comment">// 别错用成puts(&quot;-&quot;)，会多换行</span></span><br><span class="line">        C = sub(B, A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="高精度乘低精度">高精度乘低精度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// t 用来表示进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; ++ i)&#123;</span><br><span class="line">        <span class="comment">// 注意把最后处理进位的问题合并到了一起，只要t不为0最后就会执行下去</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i] * b; </span><br><span class="line">        <span class="comment">// 注意这里是高精度乘低精度，所以直接用低精度数乘以每一位即可</span></span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">// 求出进位 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="comment">// 注意需要处理前导零的问题（这里高位在后，前导零也在最后），但当只有一位是0必须保留</span></span><br><span class="line">    <span class="comment">// 之所以会产生前导零</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;B)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-793-高精度乘法"><a href="https://www.acwing.com/problem/content/795/">AcWing 793. 高精度乘法 </a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度乘低精度——AcWing 793. 高精度乘法 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// t 用来表示进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.size() || t; ++ i)&#123;</span><br><span class="line">        <span class="comment">// 注意把最后处理进位的问题合并到了一起，只要t不为0最后就会执行下去</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i] * b; </span><br><span class="line">        <span class="comment">// 注意这里是高精度乘低精度，所以直接用低精度数乘以每一位即可</span></span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">// 求出进位 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();;</span><br><span class="line">    <span class="comment">// 注意需要处理前导零的问题（这里高位在后，前导零也在最后），但当只有一位是0必须保留</span></span><br><span class="line">    <span class="comment">// 之所以会产生前导零</span></span><br><span class="line">    <span class="keyword">return</span> C;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 不建议使用scanf 输入string类型字符串</span></span><br><span class="line">    <span class="comment">// 如果使用scanf，必须要为string提前分配足够空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">// 字符串转化为整数数组</span></span><br><span class="line">    <span class="comment">// 注意倒着存储，高位在后，方便进位</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = mul(A, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="高精度除以低精度">高精度除以低精度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>; <span class="comment">// r为除法的余数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)&#123;</span><br><span class="line">        <span class="comment">// 注意虽然除法也是倒着存储的，但是从高位开始运算的</span></span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        <span class="comment">// 当前的被除数是上一位除后剩余的数加上当前位上的数</span></span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(), C.end());</span><br><span class="line">    <span class="comment">// 注意除法是从高位开始的，所以结果需要倒置（使高位在后）</span></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="comment">// 处理前导0的问题</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AcWing-794-高精度除法"><a href="https://www.acwing.com/problem/content/796/">AcWing 794. 高精度除法</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高精度除以低精度——AcWing 794. 高精度除法   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>; <span class="comment">// r为除法的余数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)&#123;</span><br><span class="line">        <span class="comment">// 注意虽然除法也是倒着存储的，但是从高位开始运算的</span></span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        <span class="comment">// 当前的被除数是上一位除后剩余的数加上当前位上的数</span></span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(), C.end());</span><br><span class="line">    <span class="comment">// 注意除法是从高位开始的，所以结果需要倒置（使高位在后）</span></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="comment">// 处理前导0的问题</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="type">int</span> b, r;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">// 不建议使用scanf 输入string类型字符串</span></span><br><span class="line">    <span class="comment">// 如果使用scanf，必须要为string提前分配足够空间</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">// 字符串转化为整数数组</span></span><br><span class="line">    <span class="comment">// 注意倒着存储，高位在后，方便进位</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = div(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = C.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前缀和">前缀和</h2><p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。作用是<strong>快速求出任意区间的和</strong>。前缀和可以在O(n)时间统计和修改，<strong>在O(1)时间内查询统计任意区间之和</strong>；</p><p>前缀和下标一般从1开始，方便将前缀和作为任意区间和的特殊情况，不需要额外处理。</p><p>前缀和是一种空间换时间的思想</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">定义式</th><th style="text-align:center">递推式</th></tr></thead><tbody><tr><td style="text-align:center">一维前缀和</td><td style="text-align:center">$S[i] = \sum\limits_{j=0}^{i}a[j]$</td><td style="text-align:center">$S[i] = S[i-1] + a[i]$</td></tr><tr><td style="text-align:center">二维前缀和</td><td style="text-align:center">$S[x][y] = \sum\limits_{i=0}<sup>{x}\sum\limits_{j=0}</sup>{y}a[i][j]$</td><td style="text-align:center">$S[x][y] = S[x-1][y] + S[x][y-1] - S[x-1][y-1] + a[x][y]$</td></tr></tbody></table><h3 id="一维前缀和">一维前缀和</h3><p>一维前缀和数组:$$S_i = a_1 + a_2 + \cdots + a_i，边界S_0 = 0$$</p><p>作用：可以通过一次运算<strong>求解原数组任意区间内所有数的和</strong>（区间长度位1时即为每个元素的值）<br>$$<br>\sum\limits_{i=l}^r a_i = S_r - S_l<br>$$</p><p>如果使用暴力解法，每次都遍历一遍给出的区间，计算出答案，这样时间复杂度会达到$O(n*m)$，极有可能会 TLE。</p><p>使用前缀和来做的话，能将时间复杂度降到$O(n+m)$，极大地减少了时间。</p><p>前缀和数组的第$i$项就是一个序列前面$i$个数的总和，求法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于已经求出的前缀和，区间$[L,R]$的和即为$res = s[r] - s[l - 1]$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[r] - s[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-795-前缀和"><a href="https://www.acwing.com/problem/content/797/">AcWing 795. 前缀和</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀和——AcWing 795. 前缀和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="comment">// 前缀和的初始化，本质是利用前缀和的递推式和差分数组来求前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 读取数据和初始化可整合在一起</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= n; ++ i)&#123;</span></span><br><span class="line"><span class="comment">        scanf(&quot;%d&quot;, &amp;s[i]);</span></span><br><span class="line"><span class="comment">        s[i] += s[i - 1];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]); </span><br><span class="line">        <span class="comment">// 区间和的计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维前缀和：">二维前缀和：</h3><p>快速求出任意子矩阵的所有元素的和。求解利用了容斥原理。</p><p><code>a[i][j]</code>表示第<code>i</code>行<code>j</code>列的元素<code>S[i][j]</code>为<code>a[i][j]</code>左上角子矩阵的所有元素的和</p><p>以<code>(1, 1)</code>为左上角，<code>(x, y)</code>为右下角的子矩阵的和为：<br>$$<br>S[x][y] = S[x-1][y] + S[x][y-1] - S[x-1][y-1] + a[x][y]<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理，求以(i,j)为右下角、(1,1)为左上角的矩阵中的元素和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当给出$x_1, y_1, x_2, y_2$时，要查询的子矩阵的和即为<br>$$<br>res = s[x_2][y_2] - s[x_1 - 1][y_2] - s[x_2][y_1 - 1] + s[x_1 - 1][y_1 - 1]<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-796-子矩阵的和"><a href="https://www.acwing.com/problem/content/798/">AcWing 796. 子矩阵的和</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维前缀和——AcWing 796. 子矩阵的和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="comment">// 前缀和的初始化，本质是利用前缀和的递推式和差分数组来求前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 读取数据和初始化可整合在一起</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= n; ++ i)</span></span><br><span class="line"><span class="comment">        for (int j = 1; j &lt;= m; ++ j)&#123;</span></span><br><span class="line"><span class="comment">            scanf(&quot;%d&quot;, &amp;s[i][j]);</span></span><br><span class="line"><span class="comment">            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i-1][j-1];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">        <span class="type">int</span> x1, x2, y1, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 区间和的计算, 类似容斥原理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-1230-K倍区间"><a href="https://www.acwing.com/problem/content/description/1232/">AcWing 1230. K倍区间</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1230. K倍区间</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">LL s[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;s[i]);</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = s[i] % k</span><br><span class="line">        res += cnt[t] ++;</span><br><span class="line">        <span class="comment">// 利用同余性质:(a - b) % p = (a % p - b % p ) % p可以发现</span></span><br><span class="line">        <span class="comment">// (S[r] - S[l]) % k == (S[r] % k - S[l] % k) % k</span></span><br><span class="line">        <span class="comment">// 又S[r] % k &lt; k, S[l] % k &lt; k必得出结论：</span></span><br><span class="line">        <span class="comment">// S[r]与S[l]要同余</span></span><br><span class="line">        <span class="comment">// 结果中不用求解排列组合，而是利用每次循环，每多一个元素就增加原先元素数个K倍区间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if (t == 0) res ++;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="差分">差分</h2><ul class="lvl-0"><li class="lvl-2"><p><a href="https://zhuanlan.zhihu.com/p/108064211">前缀和&amp;&amp;差分</a></p></li><li class="lvl-2"><p><a href="https://zhuanlan.zhihu.com/p/268883850">前缀和与差分</a></p></li></ul><p>前缀和与差分是逆运算。差分可看作前缀和的“逆运算”，可在O(1)时间操作任意区间；</p><p>已知原数组$a_1, a_2, a_3,\cdots,a_n$，构造数组$b_1,b_2,\cdots,b_n$，使得$a_i= b_1 + b_2 + b_i$，则a数组是b数组得前缀和，b数组是a数组的差分。差分数组可以<strong>将对a数组任意区间加减同一值的操作优化到$O(1)$</strong>。</p><h3 id="一维差分">一维差分</h3><p>一维差分可以快速地实现如下两个操作：</p><p><strong>1. 区间修改（给原数组任意连续区间加减固定值），时间复杂度为$O(1)$</strong></p><p>假如现在要将原数列$a[]$区间$[L, R]$ 上的每个数都加上 $c$，那么通过上述定义可以知道：</p><ul class="lvl-0"><li class="lvl-2"><p>第一个受影响的差分数组中的元素为$b[L]$，所以令$b[L] +=c$，那么后面数列元素在计算过程中都会加上c。最后一个受影响的差分数组中的元素为$b[R]$，所以令$b[R+1]-=c$，那么可以保证不会影响到R之后数列元素的计算。这样一来，就不必对区间内每一个数进行处理，只需处理两个端点即可。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    b[L] += x;</span><br><span class="line">    b[R + <span class="number">1</span>] -= x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 查询单点(求前缀和)，时间复杂度为$O(n)$</strong></p><p>这一操作其实就是求解前缀和的过程：我们利用差分数组和前缀和的递推关系来求解前缀和。</p><p>根据上述定义，差分数组$b[i]$的前缀和就是原序列$a[i]$的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何构造差分数组？">如何构造差分数组？</h4><p>初始化：不需要过分关注差分数组b是怎么构造出来的，只需要知道差分与前缀和是互逆运算即可。事实上，根本就不需要去构造差分数组b。</p><p>一开始可以把原数组$a$想象成全是0，即$a=[{0,0,\cdots,0}]$，此时相应的差分数组$b$也全是0， 即$b=[{0,0,\cdots,0}]$，接下来，对原数组$a$的初始值可以作如下考虑：</p><ul class="lvl-0"><li class="lvl-2"><p>$a[1]$相当于区间 $[1,1]$ 的每个数都加上$a[1]$</p></li><li class="lvl-2"><p>$a[2]$相当于区间 $[2,2]$ 的每个数都加上$a[n]$<br>…</p></li><li class="lvl-2"><p>$a[n]$相当于区间 $[n,n]$ 的每个数都加上$a[n]$</p></li></ul><p>即我们把原数组也当作是差分出来的。这样，用上面的区间修改操作$insert()$即可完成赋初始值，构造出差分数组。</p><h4 id="AcWing-797-差分"><a href="https://www.acwing.com/problem/content/799/">AcWing 797. 差分</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维差分——AcWing 797. 差分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">insert</span>(i ,i , a[i]);</span><br><span class="line">    <span class="comment">// 求差分数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="type">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l ,r, c);</span><br><span class="line">        <span class="comment">// 区间操作，给原数组任意连续区间加减固定值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) b[i] += b[i <span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 求前缀和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维差分——AcWing 797. 差分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span>  r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">insert</span>(i, i, a[i]);</span><br><span class="line">        <span class="comment">// 求差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m --)&#123;</span><br><span class="line">        <span class="type">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">        <span class="comment">// 区间操作，给原数组任意连续区间加减固定值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; ++ i) &#123;</span><br><span class="line">        b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维差分">二维差分</h3><p>定义：假设有原数组 $a[][]$，现构造出一个数组 $b[][]$，使得 $a[i][j]$ 等于 $b[i][j]$ 格子左上部分所有元素的和，那么 $b[][]$ 就称为 $a[][]$ 的差分，$a[][]$ 就称为$b[][]$的前缀和。可以发现，差分与前缀和是逆运算。</p><p>类比于一维差分，二维差分同样可以快速地实现如下两个操作：</p><p><strong>1.将原数组$a[][]$ 的以$(x_1, y_1)$ 为左上角、$(x_2, y_2)$为右下角的矩形区域里的每个数都加上$c$。</strong></p><p>$$ b[x_1, y_1] += c,\  b[x_2 + 1, y_1] -= c,$$$$ b[x_1, y_2 + 1] -= c,\  b[x_2 + 1, y_2 + 1] += c $$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.查询单点，差分数组$b[i][j]$前缀和就是原数组 $a[i][j]$ 的值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求以(i,j)为右下角、(1,1)为左上角的矩阵中的元素和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] +</span><br><span class="line">             b[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + b[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，不需要过分关注二维差分数组 $b[][]$是如何构造出来的，仅仅依靠上面的 $insert()$ 操作即可完成赋初值。</p><h4 id="AcWing-798-差分矩阵"><a href="https://www.acwing.com/problem/content/800/">AcWing 798. 差分矩阵</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维差分——AcWing 798. 差分矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>] [y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j= <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br><span class="line">            <span class="comment">// 求差分数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">        <span class="comment">// 子矩阵操作，给原数组任意子矩阵加减固定值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维差分——AcWing 798. 差分矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br><span class="line">            <span class="comment">// 求差分数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q --)&#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">        <span class="comment">// 子矩阵操作，给原数组任意子矩阵加减固定值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求前缀和并输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打表法">打表法</h2><p>打表，通俗理解就是“预处理”的意思，把所有可能的情况都求出来，你要哪一个我直接查表，把表中的结果给你。</p><p>在程序中一次性计算出所有用到的结果，之后的查询直接取这些结果。</p><p>具体的，我们可以创建一个 静态数据结构 来存储打表信息（需确保全局唯一，即使存在多组测试数据只生成一次打表数据）。</p><p>如果打表逻辑计算量接近 [公式] 上限，可以考虑放到本地去做，这里数据量较少，直接放到 static 代码块去做即可。</p><p>模拟法和打表法，经常会同时出现，因为打表就要按照题目的意思去模拟。</p><h3 id="AcWing-3646-分水果"><a href="https://www.acwing.com/problem/content/solution/3649/1/">AcWing 3646. 分水果</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 3646. 分水果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="双指针算法">双指针算法</h2><p>一般分为两类</p><ol><li class="lvl-3"><p>对于一个序列，用两个指针指向同一序列的两端，用于维护一段区间</p></li><li class="lvl-3"><p>对于两个序列，两个指针分别指向两个序列，用于维护某种次序，比如归并排序中合并两个有序序列的操作</p></li><li class="lvl-3"><p>常见问题分类：<br>(1) 对于一个序列，用两个指针维护一段区间<br>(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</p></li></ol><h3 id="模板-5">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">    <span class="comment">// i、j起始位置不固定</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ; <span class="comment">// 对j进行更新</span></span><br><span class="line">    <span class="comment">// j &lt; i象征性表示要判断j是否满足范围限制</span></span><br><span class="line">    <span class="comment">// check()指满足某种性质</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面写具体问题的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想：双指针算法的最核心用途是进行优化，将暴力枚举的双重循环做法优化到单循环。复杂度由$O(n^2)$优化到$O(n)$。</p><p>优化的关键在于需要用到一些特殊的性质，如单调性等。<br>i和j的单调关系可以类似于i每次增加时，j也不会减小</p><p>求解时可以首先写出双重循环的暴力算法，然后研究问题，利用性质进行优化。</p><p>和动态规划一样，在双指针中i，j表示的具体含义也是一个要思考的关键点（注意i，j表示的状态不一定同类）。</p><p>虽然双指针算法看上去是两重循环，但实质上两个指针都只会遍历一次，总复杂度是$O(2n)$</p><p>有些双指针也可以理解成一个指针+一个标记</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230328230115557.png" alt="image-20230328230115557"></p><h3 id="AcWing-799-最长连续不重复子序列"><a href="https://www.acwing.com/problem/content/801/">AcWing 799. 最长连续不重复子序列</a></h3><p>使用双指针算法时可以首先实现暴力算法，然后再研究性质进行优化，思考双重循环的指针<code>i</code>和<code>j</code>之间的关系与性质。</p><p>这里进行优化的核心性质是j随i的增大也单调递增，利用这种单调性可以使用双指针算法进行优化，将复杂度由$O(n^2)$优化到$O(n)$。</p><p><strong>这本质是利用<code>i</code>和<code>j</code>来维护状态</strong>，且<strong>利用了当前状态和前面状态的相关性进行优化</strong>，每个状态都对印古从<code>j</code>到<code>i</code>的区间，<code>j</code>和<code>i</code>都不会回溯只会增大。</p><p>本题的<strong>动态统计区间内元素数的技巧——哈希判重</strong>要熟记，使用数组<code>s[i]</code>动态维护每个区间中个元素个数，<code>s[a[i]]</code>表示<code>a[i]</code>这个数出现的次数，类似于哈希。进入区间时对应元素s[i]++，离开区间时对应元素s[i]–。数据过大时，可以用哈希表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 799. 最长连续不重复子序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], s[N];</span><br><span class="line"><span class="comment">// s[]用于动态统计区间内元素数</span></span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双指针算法</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// i和j的大小满足单调关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        s[q[i]] ++;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; i &amp;&amp; s[q[i]] &gt; <span class="number">1</span>) s[q[j ++]] --;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="位运算">位运算</h2><ol><li class="lvl-3"><p>求n的二进制表示中第k位是几：<code>n &gt;&gt; k &amp;&amp; 1</code><br>先把第k位移到最后一位(<code>n &gt;&gt; k</code>)，然后取出最后一位( <code>n &gt;&gt; k &amp;&amp; 1</code>)</p></li><li class="lvl-3"><p><code>lowbit(x)</code>操作，返回x最右端一位的1(最后一位1）所代表的大小<code>x &amp; -x</code><br>负数的补码是原码取反加1<code>x &amp; -x == x &amp; (~x + 1)</code>。已知其补码相对于原码，<strong>最右端的1和其右面的0是不变的，其余全部取反</strong>，因而<code>x &amp; -x</code>后只剩下最右端的1了，其余全变成0。这是树状数组的一个基本操作。</p><p>用途之一是<strong>可以用来求一个数<code>x</code>二进制表示中1的个数</strong>。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计x二进制表示中1的个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> namepace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x最右端一位的1所代表的大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)</span><br><span class="line">    <span class="keyword">while</span> (n --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">            x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">            <span class="comment">// 每次减去x的最后一个1所代表的数值</span></span><br><span class="line">            ++ res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="离散化">离散化</h2><p>这里特指整数的离散化，且不改变顺序（保序）。把原来的数字，用它们的相对大小来替换原来的数值，而相对顺序仍然不变。</p><p>数据的值域范围比较大，但个数比较少，非常稀疏。此时如何存储？需映射到从0开始得自然数。</p><p>离散化的两个问题：</p><ul class="lvl-0"><li class="lvl-2"><p>去重：可能有重复元素，需要去重，可使用库函数。</p></li><li class="lvl-2"><p>快速映射：需要能够快速算出离散化后的值，使用二分来查找</p></li></ul><p>要求求解的量与绝对位置无关</p><p>映射到对应下标</p><p>注意所有用到的数都要存进去。要开30000，插入和查询的位置都要存进去。</p><p>把数字看成数组下标，却只考虑相对大小关系</p><p>离散化经常用于树状数组或权值线段树</p><h3 id="模板-6">模板</h3><h4 id="C-4">C++</h4><p>去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 找到第一个大于等于x的位置</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-2">Python</h4><p>不去重，重复数字离散化后不一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">sorted</span>(a)</span><br><span class="line"><span class="keyword">for</span> i <span class="built_in">range</span>(<span class="built_in">len</span>(b)):</span><br><span class="line">    a[a.index(b[i])] = i + <span class="number">1</span> <span class="comment"># 由于从1开始映射，需加1</span></span><br><span class="line">    <span class="comment"># a.index(x)查找x在a中位置，从列表中获取指定索引元素的第一个匹配位置</span></span><br><span class="line">    <span class="comment"># 由于a会被更新，前面重复的都被变成了相对位置，就避免了查找位置不变的问题</span></span><br></pre></td></tr></table></figure><p>去重写法，重复数字离散化后一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="built_in">list</span>(<span class="built_in">set</span>(a)) <span class="comment"># 利用集合去重</span></span><br><span class="line">b.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    a[i] = b.index(a[i]) + <span class="number">1</span> <span class="comment"># 为保持一致，就要查找不被改变的b，由于b的index就对应于相对大小顺序，所以直接加1</span></span><br></pre></td></tr></table></figure><h2 id="区间合并">区间合并</h2><p>将有交集的区间合并</p><p>维护与更新</p><p>为了便于维护和更新，迭代顺序很重要——需要先按照左端点大小排序。</p><p>区间贪心也是类似思路。</p><h3 id="模板-7">模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)&#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯专题备赛—二分</title>
      <link href="/2023/03/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E4%B8%93%E9%A2%98%E5%A4%87%E8%B5%9B%E2%80%94%E4%BA%8C%E5%88%86/"/>
      <url>/2023/03/07/%E8%93%9D%E6%A1%A5%E6%9D%AF%E4%B8%93%E9%A2%98%E5%A4%87%E8%B5%9B%E2%80%94%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯专题备赛—二分">蓝桥杯专题备赛—二分</h1><p>二分问题常用于求具有二段性的某一性质的边界值问题。</p><p>只要性质具有二段性或单调性，就可以尝试用二分。二分的复杂度为$O(logn)$，作为一种搜索方法常结合循环等使用。事实上，二分是一种优化暴力方法的常用方法，和暴力思路结合的很紧密。</p><p>一些最值问题其实就是性质的边界值问题，此时可以用二分求解。</p><p>二分的本质是，根据某一性质将区间左右一分为二，使一部分满足该性质，另一部分不满足该性质。</p><p>如果可以找到一个性质使区间左右一分为二（一部分满足，一部分不满足），二分就可以找到性质的边界。</p><p>二分问题要满足的条件：</p><ol><li class="lvl-3"><p>确定一个区间，使得目标值一定在区间中</p></li><li class="lvl-3"><p>找一个性质，满足：</p><ul class="lvl-2"><li class="lvl-6">性质具有二段性</li><li class="lvl-6">答案是二段性的分界点</li></ul></li></ol><h2 id="整数二分">整数二分</h2><h3 id="整数二分步骤">整数二分步骤</h3><ol><li class="lvl-3"><p>找一个区间[L, R]，使得答案一定在该区间中</p></li><li class="lvl-3"><p>找一个判断条件，使得该判断条件具有二段性，并且答案一定是该二段性的分界点</p></li><li class="lvl-3"><p>分析终点M在该判断条件下是否成立，如果成立，考虑答案在哪个区间；如果不成立，考虑答案再哪个区间</p><ul class="lvl-2"><li class="lvl-5">如果条件成立（性质满足）的区间在左部，则为&lt;= x型，采用L=mid模板</li><li class="lvl-5">如果条件成立（性质满足）的区间在右部，则为&lt;= x型，采用R=mid模板</li></ul></li><li class="lvl-3"><p>如果更新方式写的是R = mid，则不用做任何处理；如果更新方式写的是L = mid，则需要在计算mid时加上1</p></li></ol><h3 id="整数二分的常见类型">整数二分的常见类型</h3><h4 id="问题形式角度">问题形式角度</h4><ol><li class="lvl-3"><p>数据序列的二段性：问题中的数据序列具有单调性、二段性、适用于排序，在处理数据时进行二分</p></li><li class="lvl-3"><p>解（最值）的二段性：一般适用于最值问题，即求解给定条件下的最值。如果发现，针对题目的约束条件，以最值为边界点具有二段性（一段一定满足约束，一段不满足），即可使用二分对解进行搜索。数据的二段性只是将二段性直接变现出来了，其本质也是解（最值）的二段性。</p></li></ol><p>常见特征词：求”最大值“、”最小值“、”平均值“的最大/最小值</p><p>二分重要性质：<strong>将假设的解作为已知条件，将问题转化为判定问题</strong></p><ul class="lvl-0"><li class="lvl-2"><p>二分搜索解时，假设的解实际上可以作为已知条件进行使用。二分本质上可以让我们多一个条件（假设出解），将问题转化为判断问题（判断当前的解是否成立）。善用这一性质往往能极大化简问题！</p></li></ul><h4 id="二分性质角度">二分性质角度</h4><p>确定为二分问题后就要找到二段性，尽管问题的场景多种多样，但一般二段性只有两类：</p><p><img src="https://mdpic.dreamgo.fun/img/%E4%B8%A4%E7%B1%BB%E4%BA%8C%E5%88%86.png" alt="两类二分"></p><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;= x</code>类：check函数&lt;= x时返回真，左半部分都是真，边界点属于左半部分</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左半部分满足性质，如&lt;=x的数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_left</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="comment">// 分界点在左半部分，如小于等于某个数的最大值</span></span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//int mid = l + (r - l + 1) / 2; // 避免溢出问题</span></span><br><span class="line">        <span class="comment">// 当分界点在左半部分时，之所以$mid = \frac&#123;l+r+1&#125;&#123;2&#125;$多加一个1是为了避免mid = l导致更新时l = mid会不发生变化，陷入死循环（这种情况出现在l = r - 1时）。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="comment">// 成立时，对左端点更新且包含mid(分界点在成立区间得右端)</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 不成立时，对右端点更新，且不包含mid</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">// 最终l==r，l和r都是答案，但mid不一定是答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><code>&gt;= x</code>类：check函数&gt;=x时返回真，右半部分都是真，边界点属于右半部分</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右半部分满足性质，如&gt;=x的数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_right</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123; <span class="comment">// 区间长度大于等于1</span></span><br><span class="line">        <span class="comment">// 分界点在右半部分，如大于等于某个数的最小值</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//int mid = l + (r - l) / 2; // 避免溢出问题</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="comment">// 成立时，对右端点更新且包含mid(分界点在成立区间得左端)</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">// 最终l==r，l和r都是答案，但mid不一定是答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将二分问题都转化为这两类中的一种</p><h3 id="判断函数的确定">判断函数的确定</h3><p>二分最难的地方就在于 $ check $ 函数的写法，一般而言首先可以结合时间复杂度进行 $ check $ 函数的形式进行估计。由于二分的时间复杂度是<code>O(logn)</code> ，</p><ul class="lvl-0"><li class="lvl-2"><p>当$ n≤10^2 $，总时间复杂度要小于$ O( n^3 logn) $ ，$ check $ 函数中一般只能三重循环</p></li><li class="lvl-2"><p>当$ n≤10^3 $，总时间复杂度要小于$ O( n^2 logn) $ ，$ check $ 函数中一般只能两重循环</p></li><li class="lvl-2"><p>当$ n≤10^5 $，总时间复杂度要小于$ O( n logn) $，$ check $ 函数中一般只能一重循环</p></li></ul><h2 id="AcWing-730-机器人跳跃问题"><a href="https://www.acwing.com/activity/content/problem/content/1572/">AcWing 730. 机器人跳跃问题</a></h2><p>来源：今日头条2019，笔试题题型：二分、递归</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分 + 递推——AcWing 730. 机器人跳跃问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分的主体代码往往相同，不同点在于check()函数</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> e)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        e = e * <span class="number">2</span> - h[i];</span><br><span class="line">        <span class="keyword">if</span> (e &gt;= <span class="number">1e5</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 没有这一步会爆int</span></span><br><span class="line">        <span class="comment">// check()函数中能尽早判断出是否满足性质就要尽早</span></span><br><span class="line">        <span class="comment">// 因而要充分研究问题性质，用数学方法放缩出一些显然成立的情况，简化问题</span></span><br><span class="line">        <span class="keyword">if</span> (e &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e5</span>;</span><br><span class="line">    <span class="comment">// 二分的一大关键点在于恰当地确定最初地区间端点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我最初用的暴力硬解的方法，十分不好</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20</span> &amp;&amp; i &lt;= n; ++ i)&#123;</span><br><span class="line">        sum = <span class="number">2</span> * sum + h[i];</span><br><span class="line">        res = max(res, (<span class="type">int</span>)<span class="built_in">ceil</span>(sum / (<span class="number">1</span> &lt;&lt; i)));</span><br><span class="line">        <span class="comment">// printf(&quot;%f %f\n&quot;,sum, sum / (1 &lt;&lt; i) + 0.5);</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="AcWing-1227-分巧克力"><a href="https://www.acwing.com/problem/content/1229/">AcWing 1227. 分巧克力</a></h2><p>来源：2017年第八届蓝桥杯省赛C++A/B组题型：二分</p><p>本题的一个首先的关键也在于充分理解和挖掘题目性质</p><p>首先要明确如果确定对于给定大小的切除巧克力，原巧克力能切除多少块。不难发现满足以下公式：<br>$$<br>块数 = \lfloor\frac{H_i}{x} \rfloor*\lfloor \frac{W_i}{x}\rfloor<br>$$</p><p>同时进行数学建模，问题可表述为：<br>$$<br>max\ (巧克力大小) \\<br>s.t.\ \  数量 &gt;= k<br>$$</p><p>其次研究问题要求解的最值量是否具有二段性或单调性的性质，显然可以发现：能切出的巧克力数量随切除的巧克力大小具有单调递减的变化规律。总量不变时，巧克力越大，数量一定越少。存在一个临界值，满足数量 &gt;= k，且巧克力最大。（注意这里不一定刚好切除数量为k，故约束条件是数量 &gt;= k）。</p><p>不难发现，二分研究的性质往往就是约束量随目标量的变化关系，其具有二段性或单调性时，可用二分求解边界值（最值）。</p><p>check()的过程往往是一个循环或递推、具体求解问题的过程。</p><h4 id="C">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1227. 分巧克力  </span></span><br><span class="line"><span class="comment">// 二分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> h[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt;= n; ++ i)&#123;</span><br><span class="line">        res += (h[i] / mid) * (w[i] / mid);</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= k) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;h[i], &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 1227. 分巧克力  </span></span><br><span class="line"><span class="comment"># 二分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    h, w = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        h[i], w[i] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mid</span>):</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cnt += (h[i] // mid) * (w[i] // mid)</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= k</span><br><span class="line">    </span><br><span class="line">    l, r = <span class="number">0</span>, <span class="built_in">max</span>(h)</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check(mid): l = mid</span><br><span class="line">        <span class="keyword">else</span>: r = mid - <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="AcWing-1221-四平方和"><a href="https://www.acwing.com/problem/content/1223/">AcWing 1221. 四平方和 </a></h2><p>打表法化三重循环为两个二重循环，再利用搜索求解。</p><p>搜索方法可以采用二分法或数组模拟哈希</p><p>本题的一个关键问题时排序问题。指定固定排序的问题等价于组合问题。只需按照排序方式求解即可避免排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 打表法 + 二分——AcWing 1221. 四平方和 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> s, c, d;</span><br><span class="line">    <span class="comment">// 有多个关键字的排序，按主关键字序排序</span></span><br><span class="line">    <span class="type">bool</span> operator&lt; (<span class="type">const</span> Sum &amp;t)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s != t.s) <span class="keyword">return</span> s &lt; t.s; <span class="comment">// 一定注意 if 语句里要用!=不等号而不能用小于号</span></span><br><span class="line">        <span class="keyword">if</span> (c != t.c) <span class="keyword">return</span> c &lt; t.c;</span><br><span class="line">        <span class="keyword">return</span> d &lt; t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sum[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c * c &lt;= n; ++ c)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = c;  c + d * d &lt;= n; ++ d)</span><br><span class="line">            sum[m ++ ] = &#123;c * c + d *d , c , d&#125;;</span><br><span class="line">            <span class="comment">// 打表</span></span><br><span class="line"></span><br><span class="line">    sort(sum, sum + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a * a &lt;= n; ++ a)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; a * a + b * b &lt;= n; ++ b)&#123;</span><br><span class="line">            <span class="type">int</span> t = n - a * a - b * b;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (sum[mid].s &gt;= t) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum[l].s == t)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a, b , sum[l].c, sum[l].d);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="AcWing-3176-扫地机器人"><a href="https://www.acwing.com/problem/content/description/3179/">AcWing 3176. 扫地机器人</a></h2><p>难度：简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 3176. 扫地机器人</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] - t &lt;= l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt;= l)  l = s[i] + t - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n , &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(s, s + k);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span> * (l - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-3153-矩阵翻硬币"><a href="https://www.acwing.com/problem/content/description/3156/">AcWing 3153. 矩阵翻硬币</a></h2><p>蓝桥云课链接：<a href="https://www.lanqiao.cn/problems/219/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=%E4%BA%8C%E5%88%86">矩阵翻硬币 - 蓝桥云课</a></p><p>出处：2014年第五届蓝桥杯省赛JAVAB/C组难度：中等类型：数论（约数）二分</p><h3 id="问题思路">问题思路</h3><p>本题难点在分析出主要问题。</p><p>最后，所有的硬币都是向上的，但是 “聪明” 的小 M 说了，如果再按照 Q 操作玩一次，就可以恢复原状，现在问原来有多少硬币是向下的。明确几点：<br><strong>1.</strong> 从最后开始，先不管 P 操作究竟是怎么样的，只要某个硬币，被翻得次数是奇数次的，那么肯定要变成向下的。<br><strong>2.</strong> 接下来请仔细看 P 操作，对 i × x 和 j × y，注意是 “<strong>所有的</strong>”，也就是说只要你这个 i*x 不超过最大的 n，那么所有可能的<code>i</code>都得取到。比如说现在最大的 n 是 20，x 现在是 2，那么 i 必须要取 2,3,4,5,6,7,8,9,10, 意思是<strong>所有在 n 范围内 x 的倍数都得取到</strong>。那么同理，<strong>所有在 m 范围内 y 的倍数也必须取到</strong>。<br><strong>3.</strong> 明确了第二点，那么分析，对于某个点，假设坐标为（a，b），那么这个点被翻过的次数就是 <strong>a 的约数个数 × b 的约数个数</strong>。<br><strong>4.</strong> 明确了第三点，那么想找到被翻过次数是奇数个的点，那么 a 和 b 的约数个数的乘积必须是是个奇数，如果 a 和 b 约数个数乘积必须是奇数，那么 a 和 b 他俩任何一个约数的个数都不能有 2，也就意味着，a 和 b 的约数个数都必须也是奇数乘出来才可能是奇数。<br><strong>5.</strong> 明确了第四点，现在要寻找，什么样的数，才有奇数个约数呢？答案是——<strong>完全平方数</strong>！比如 0,4,9,16,25, 等等这些数字是完全平方数，也就是某个自然数的平方。那么也就是要求 a 和 b 都得是完全平方数。那么一个自然数，究竟包括了多少个完全平方数（不含 0，因为本题要求坐标从 1 开始），需要对这个数开方取整即可。比如 10，开方之后为 3. 几，意思是他包含了 3 个完全平方数，就是 1 4 9。<br><strong>6.</strong> 最后，问题就转化成求 n 和 m 包括的完全平方数的个数再相乘，也就是根号 n 乘 根号 m 的结果，注意先取整再计算。</p><p><strong>7.</strong> 可以采用给高精度开方，或者采用二分法寻找根。python 和 java 可直接使用高精度数！C++ 需继续搜寻为高精度开方的方法</p><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line"><span class="comment"># 二分法开根</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">x</span>):</span><br><span class="line">  L = <span class="number">1</span></span><br><span class="line">  R = x</span><br><span class="line">  <span class="keyword">while</span> L &lt; R:</span><br><span class="line">    mid = L + R + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> mid ** <span class="number">2</span> &lt;= x:</span><br><span class="line">      L = mid</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      R = mid - <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sqrt(n)*sqrt(m))</span><br></pre></td></tr></table></figure><h2 id="AcWing-2556-第八大奇迹"><a href="https://www.acwing.com/problem/content/description/2558/">AcWing 2556. 第八大奇迹</a></h2><p>出处：2019第十届蓝桥杯国赛C++B组难度：困难类型：树状数组 二分</p><h3 id="题意">题意</h3><p>给定一个长度为 N 的序列 A，序列的初始值全为 0。现有 M 次操作，操作分为以下两种：</p><ul class="lvl-0"><li class="lvl-4"><p><code>C x y</code> 表示将 Ax 的值改为 y，即 $A[x]=y$</p></li><li class="lvl-4"><p><code>Q l r</code> 询问区间 $Al,Al+1,…,Ar $的第八大的数值是多少（若不存在则输出 0）</p></li></ul><h3 id="分析">分析</h3><p>这显然是道<strong>动态区间第 k 大的问题</strong>，本题的 k=8，动态为单点修改。</p><p>处理<strong>动态区间第 k 大的问题</strong>，有两种常用方法：</p><ol><li class="lvl-4"><p>树套树（树状数组套主席树 or 树状数组套平衡树）</p></li><li class="lvl-4"><p>整体二分</p></li></ol><ul class="lvl-0"><li class="lvl-4"><p><strong>树状数组套主席树：</strong> 前置知识：<strong>前缀和</strong>，<strong>树状数组</strong>（2014 年 B 组第 10 题，小朋友排队），<strong>主席树</strong>（可持久化权值线段树，2015 年 A 组 t10 灾后重建和 2017 年 A 组 t10 油漆面积都用到了线段树）。</p></li></ul><ol><li class="lvl-4"><p>Q：如果是静态（即没有对序列的数进行修改）求整个序列的第 k 大怎么做呢？</p><p>A：直接对序列 sort（从小到大） 一遍，那么 A[k] 即为所求时间复杂度 O(nlogn)，空间复杂度 O(n)。</p></li><li class="lvl-4"><p>Q： 如果是动态（会对序列的数单点修改）求整个序列的第 k 大怎么做呢？</p><p>A：开一棵权值线段树，树上每个位置的值表示这个位置对应的那个数在序列中有多少个，并向上维护和。</p><p>查询时从树的根节点出发，先查询左子树和（记为sum），比较 k 和 sum 的大小关系：若 k≤sum 则说明第 k 小数在左子树中，递归查询左子树；否则，这个数对应的就是右子树中第 k−sum 小的数，令 k−=sum，然后递归查询右子树。</p><p>时间复杂度 O(nlogn)，空间复杂度 O(n)。</p></li><li class="lvl-4"><p>Q：如果是静态（即没有对序列的数进行修改）求<strong>某个区间</strong>的第 k 大怎么做呢？</p><p>A：建立 n 棵前缀权值线段树，那么任意一段区间均可以用两棵权值线段树作差来表示，即区间 [L,R] 的信息可以由第 R 棵权值线段树 - 第 L 棵权值线段树得到。不过每个前缀开一棵权值线段树空间复杂度 O(n2)，无法开出这么大空间，而考虑到后一个位置相比于前一个位置的更改只有 logn 个节点，所以使用<strong>主席树来优化空间</strong>。</p><p>时间复杂度 O(nlogn) 空间复杂度 O(nlogn)</p></li><li class="lvl-4"><p>Q：<strong>如果是动态（有对序列的数进行修改）求某个区间的第 k 大怎么做呢（本题）？</strong></p><p>A：还是要想办法维护前缀和。</p><p><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">的值修改为 y (进行一次操作)。即令 $a[x]=y$ ，则受到影响的会有 $tree[x],tree[x+1],…,tree[n]$。</label></p><p>我们需要去更新 $tree[x],tree[x+1],…,tree[n] $的信息。更新一个 tree 需要的时间复杂度 O(log)，而 x∼n 最坏有 n 个 tree 需要更新，那么更新的总时间复杂度为 O(nlog)，而这只是一次操作。而本题一共有 m 次操作，如果每次操作都是最坏的情况，那么时间复杂度为$ O(NMlogN)$ ，显然会超时。那有什么办法可以快速维护前缀信息呢？不难想到树状数组。</p><p>通常树状数组是用来维护一个序列的，本题也类似，只不过原来的序列的每个元素都是一个数值，而本题的序列是由 n 棵主席树构成的序列，序列的每个元素都是一棵树。于是要修改 $tree[x],tree[x+1],…,tree[n] $只要 $log×log$ 的复杂度即可(第一个 log 是主席树的，第二个 log 是树状数组的)。</p><p>总时间复杂度为 O(mlog2n)</p></li></ol><ul class="lvl-0"><li class="lvl-4"><p><strong>整体二分：</strong></p><p>前置知识：<strong>分治</strong></p><p>按操作的时间顺序排列各个操作，对于修改操作拆为删除和加入操作：</p><ol><li class="lvl-8"><p>删除之前插入的数字</p></li><li class="lvl-8"><p>加入新的数字</p></li></ol><p>整体二分的做法是，对于每一个单独的询问，我们可以很容易设计一个 nlogn 的二分答案的算法，但是我们发现如果我们对每一个询问都这样处理的话会有很多重复的操作，于是我们考虑把所有询问一起二分。</p><p>用 $solve(l,r,x,y)$ 表示 l 到 r 的询问所在的答案的区间为 [x,y]，然后我们每次根据 mid=2(x+y) 把所有的操作分成两份，左边是插入（删除）值小于 mid 的修改和询问，右边是大于 mid 的修改和询问，然后继续分治下去。其中修改我们需要用个数据结构来快速修改（比如树状数组 or 线段树），总时间复杂度为 O(nlog2n)。</p></li></ul><h3 id="解法一（树状数组套主席树）">解法一（树状数组套主席树）</h3><p><a href="https://oi-wiki.org/ds/persistent-in-bit/">树状数组套主席树 - OI Wiki</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">`<span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n , m ;</span><br><span class="line"><span class="type">int</span> a[N] ;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x) ; &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> up , cnt ;</span><br><span class="line">    <span class="type">int</span> lson[N * <span class="number">100</span>] , rson[N * <span class="number">100</span>] , sum[N * <span class="number">100</span>] ;</span><br><span class="line">    <span class="type">int</span> rt[N * <span class="number">100</span>] ;</span><br><span class="line">     </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vx , vy ;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        up = <span class="number">1e9</span> , cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">memset</span>(lson , <span class="number">0</span> , <span class="keyword">sizeof</span> lson);</span><br><span class="line">        <span class="built_in">memset</span>(rson , <span class="number">0</span> , <span class="keyword">sizeof</span> rson);</span><br><span class="line">        <span class="built_in">memset</span>(sum  , <span class="number">0</span> , <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="built_in">memset</span>(rt   , <span class="number">0</span> , <span class="keyword">sizeof</span> rt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;now , <span class="type">int</span> l , <span class="type">int</span> r , <span class="type">int</span> x , <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now == <span class="number">0</span>)  now = ++ cnt ;</span><br><span class="line">        sum[now] += y ;</span><br><span class="line">        <span class="keyword">if</span>(l == r)  <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= mid)  <span class="built_in">update</span>(lson[now] , l , mid , x , y) ;</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">update</span>(rson[now] , mid + <span class="number">1</span> , r , x , y) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i , <span class="type">int</span> x , <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i ; j &lt;= n ; j += <span class="built_in">lowbit</span>(j))</span><br><span class="line">        <span class="built_in">update</span>(rt[j] , <span class="number">0</span> , up , x , y) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l , <span class="type">int</span> r , <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r)  <span class="keyword">return</span> l ;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span> , mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="type">int</span> sizx = vx.<span class="built_in">size</span>() , sizy = vy.<span class="built_in">size</span>() ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : vx)  num -= sum[lson[x]] ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y : vy)  num += sum[lson[y]] ;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= num)</span><br><span class="line">        &#123;        </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; sizx ; i ++) vx[i] = lson[vx[i]] ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; sizy ; i ++) vy[i] = lson[vy[i]] ;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(l , mid , k) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; sizx ; i ++)  vx[i] = rson[vx[i]] ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; sizy ; i ++)  vy[i] = rson[vy[i]] ;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(mid + <span class="number">1</span> , r , k - num) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l , <span class="type">int</span> r , <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vx.<span class="built_in">clear</span>() , vy.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l - <span class="number">1</span> ; j &gt;= <span class="number">1</span> ; j -= <span class="built_in">lowbit</span>(j))  vx.<span class="built_in">push_back</span>(rt[j]) ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = r ; j &gt;= <span class="number">1</span> ; j -= <span class="built_in">lowbit</span>(j))  vy.<span class="built_in">push_back</span>(rt[j]) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">0</span> , up , k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tree ;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>) , cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    tree.<span class="built_in">init</span>() ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++)  tree.<span class="built_in">add</span>(i , a[i] , <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l , r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="type">int</span> k = r - l + <span class="number">1</span> - <span class="number">8</span> + <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> res = tree.<span class="built_in">ask</span>(l , r , k);</span><br><span class="line">            cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x , y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            tree.<span class="built_in">add</span>(x , a[x] , <span class="number">-1</span>) ;</span><br><span class="line">            a[x] = y ;</span><br><span class="line">            tree.<span class="built_in">add</span>(x , a[x] , <span class="number">1</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二（整体二分）">解法二（整体二分）</h3><p><a href="https://oi-wiki.org/misc/parallel-binsearch/">整体二分 - OI Wiki</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">`<span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x) ; &#125;</span><br><span class="line"><span class="type">int</span> n , m , tot = <span class="number">1</span> , qid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x , y , k , id , ch;</span><br><span class="line">&#125; q[N] , q1[N] , q2[N];</span><br><span class="line"><span class="type">int</span> a[N] , ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tree[N];</span><br><span class="line">    <span class="type">int</span> maxn;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tree , <span class="number">0</span> , <span class="keyword">sizeof</span> tree);</span><br><span class="line">        maxn = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos , <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = pos ; i &lt;= maxn ; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            tree[i] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = pos ; i ; i -= <span class="built_in">lowbit</span>(i)) ans += tree[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> ql,<span class="type">int</span> qr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &gt; qr) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = ql ; i &lt;= qr ; i ++) <span class="keyword">if</span>(q[i].ch == <span class="number">2</span>) ans[q[i].id] = l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> L = <span class="number">0</span> , R = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = ql ; i &lt;= qr ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i].ch == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q[i].x &lt;= mid)</span><br><span class="line">            &#123;</span><br><span class="line">                bit.<span class="built_in">add</span>(q[i].id , q[i].y);</span><br><span class="line">                q1[L ++] = q[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> q2[R ++] = q[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> res = bit.<span class="built_in">ask</span>(q[i].y) - bit.<span class="built_in">ask</span>(q[i].x - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(res &gt;= q[i].k) q1[L ++] = q[i];</span><br><span class="line">            <span class="keyword">else</span> q[i].k -= res , q2[R ++] = q[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; L ; i ++) <span class="keyword">if</span>(q1[i].ch == <span class="number">1</span>) bit.<span class="built_in">add</span>(q1[i].id, -q1[i].y);</span><br><span class="line">    <span class="type">int</span> now = ql;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; L ; i ++) q[now ++] = q1[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; R ; i ++) q[now ++] = q2[i];</span><br><span class="line">    <span class="built_in">solve</span>(ql , ql + L - <span class="number">1</span> , l , mid);</span><br><span class="line">    <span class="built_in">solve</span>(ql + L , ql + L + R - <span class="number">1</span> , mid + <span class="number">1</span> , r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    bit.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++) q[tot ++] = Query&#123;<span class="number">0</span> , <span class="number">1</span> , <span class="number">0</span> , i , <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= m ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l , r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="type">int</span> k = r - l + <span class="number">1</span> - <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">            q[tot++]=Query &#123;l,r,k,qid++,<span class="number">2</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x , y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            q[tot ++] = Query&#123;a[x] , <span class="number">-1</span> , <span class="number">0</span> , x , <span class="number">1</span>&#125;;</span><br><span class="line">            a[x] = y;</span><br><span class="line">            q[tot ++] = Query&#123;a[x] , <span class="number">1</span> , <span class="number">0</span> , x , <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span> , tot - <span class="number">1</span> , <span class="number">0</span> , <span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt; qid ; i ++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-519-跳石头"><a href="https://www.acwing.com/problem/content/solution/521/1/">AcWing 519. 跳石头</a></h2><p>蓝桥云课链接：<a href="https://www.lanqiao.cn/problems/364/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;name=%E8%B7%B3%E7%9F%B3%E5%A4%B4">跳石头 - 蓝桥云课 (lanqiao.cn)</a><br>出处：NOIP2015提高组难度：中等类型：二分+贪心， $O(NlogL)$</p><h3 id="问题分析">问题分析</h3><p>本题属于二分的标准套路题：最大值最小化，最小值最大化，属于解（最值）的二分。</p><p>二段性：如果长度 $Len$ 可以满足，那么当长度小于 $Len$ 时也可以满足，所以我们可以二分出最大的 $Len$。</p><h3 id="判定函数确定——贪心策略">判定函数确定——贪心策略</h3><p>本题$ check $ 函数还是稍微要思考一下的。主要还是要把思路从判定问题转变为判定问题来处理。</p><p>$check$函数返回真的限制条件是：</p><ul class="lvl-0"><li class="lvl-2"><p>至多移走$M$个石头</p></li><li class="lvl-2"><p>剩下石头间距离大于等于$Len$</p></li></ul><p>需注意，这里不要被至多移走m个石头所困惑，把问题想的过于复杂。实际上，由于现在是判定问题而不是求解问题，我们不需要从所有约束条件出发去推可行解，完全可以一个一个约束地处理，或从先满足一个约束来推出解，再看其是否满足其他约束。总之，判定问题的思路要灵活！</p><p>本题中剩下的问题是如何判断给定 $Len$ 的情况下，能否最多拿走 $M$ 块石头，使得所有相邻两块石头之间的距离不小于 $Len$。</p><p>这一步可以贪心来做。从前往后扫描，并记一下上一块石头的位置。</p><ul class="lvl-0"><li class="lvl-2"><p>如果当前石头和上一块石头的距离小于 $Len$，则将当前石头拿走。</p><p>这里给出证明：如果某个最优解中是拿走了上一块石头，那么我们可以改成留下上一块石头，拿走当前这块石头，这样总共拿走的石头数量不变，所以当前选法也是一组最优解。</p></li><li class="lvl-2"><p>如果当前石头和上一块石头的距离大于等于 $Len$，则将上一块石头更新成当前这块。</p></li></ul><p>扫描结束后判断拿走的石头数量是否小于等于 $M$。</p><h3 id="时间复杂度分析">时间复杂度分析</h3><p>总共二分 $O(logL)$ 次，每次贪心的计算是 $O(N)$，因此总时间复杂度是 $O(NlogL)$</p><h4 id="C-2">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 519. 跳石头</span></span><br><span class="line"><span class="comment">// 二分 + 贪心</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L, n, m;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (d[i] - last &lt; mid) cnt ++ ;</span><br><span class="line">        <span class="keyword">else</span> last = d[i];</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;L, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">    d[ ++ n] = L;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-2">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 519. 跳石头</span></span><br><span class="line"><span class="comment"># 二分 + 贪心</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    l, n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    d = [<span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># 易错点：别忘了中间最后一个岩石和终点岩石的距离也要大于等于len</span></span><br><span class="line">    <span class="comment"># 所以要把最后一个岩石也加入距离序列</span></span><br><span class="line">    d.append(l)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mid</span>):</span><br><span class="line">        cnt = <span class="number">0</span> <span class="comment"># 移动岩石数</span></span><br><span class="line">        last= <span class="number">0</span> <span class="comment"># 当前位置到起点距离</span></span><br><span class="line">        <span class="comment"># 易错点：初始位置是在起点，距离为0而不是d[0]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前位置岩石与下个岩石距离小于mid，就取走下一个岩石</span></span><br><span class="line">            <span class="keyword">if</span> d[i] - last &lt; mid:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 否则更新当前位置，跳到下个岩石上</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                last = d[i]</span><br><span class="line">        <span class="comment"># 是否满足数量限制</span></span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m</span><br><span class="line">    </span><br><span class="line">    l, r = <span class="number">0</span>, <span class="built_in">max</span>(d)</span><br><span class="line">    <span class="comment"># &gt;= x型，左模板</span></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            l = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid - <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="AcWing-1460-我在哪？（每日一题）"><a href="https://www.acwing.com/problem/content/1462/">AcWing 1460. 我在哪？（每日一题）</a></h2><p>本题的本质时确定一个最小长度k，使任意长度为k的子串都互不相同。</p><p>直接暴搜的话是四重循环，复杂度为$ O(n^4) $，其实可以过。</p><p><img src="https://mdpic.dreamgo.fun/img/%E6%88%91%E5%9C%A8%E5%93%AA.png" alt="我在哪"></p><p>优化</p><ul class="lvl-0"><li class="lvl-2"><p>二分优化：对于最外层循环，可以使用二分进行优化。本题显然具有二段性，只要长度大于等于ans，子串就一定互不相同。</p></li><li class="lvl-2"><p>哈希：对于分别枚举任意两个子串进行比较的循环，可以通过哈希打表记录出现次数，用空间换时间。</p></li><li class="lvl-2"><p>字符串哈希</p></li></ul><h4 id="C-3">C++</h4><p><code>string.substr(start&lt;,length&gt;)</code><br>start:从string 的start位置开始提取字符串<br>length:待提取的字符串的长度，若length为一下情况时，返回整个字符串的所有字符。</p><p><code>iterator **find** (const key_type&amp; k);</code><br>在容器中搜索键值等于 k 的元素，如果找到，则返回一个指向该元素的迭代器，否则返回一个指向unordered_map :: end的迭代器。</p><p>二分 + 哈希，时间复杂度为$O(n^2 logn)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1460. 我在哪？（每日一题）</span></span><br><span class="line"><span class="comment">// 二分 + 哈希</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">// unordered_map&lt;string, bool&gt; hash;</span></span><br><span class="line">    unordered_set&lt;string&gt; hash;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; ++ i)&#123;</span><br><span class="line">        string t = s.<span class="built_in">substr</span>(i, k);</span><br><span class="line">        <span class="comment">// if (hash.find(t) == hash.end()) m[t] = true;</span></span><br><span class="line">        <span class="comment">// else return false;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(t)) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">else</span> hash.<span class="built_in">insert</span>(t); <span class="comment">// 复杂度为O(n)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分 + 字符串哈希，时间复杂度为$O(nlogn)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1460. 我在哪？（每日一题）</span></span><br><span class="line"><span class="comment">// 二分 + 字符串哈希</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">103</span>, P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">ULL hs[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hs[r] - hs[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + k - <span class="number">1</span> &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">get</span>(i + <span class="number">1</span>, i + k); <span class="comment">// 注意字符串哈希下表下标从1开始，所以这里要加1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">count</span>(t)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> hash.<span class="built_in">insert</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        hs[i] = hs[i - <span class="number">1</span>] * P + s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-3">Python</h4><p>集合/哈希</p><p>判断字符串是否在集合中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 1460. 我在哪？（每日一题）</span></span><br><span class="line"><span class="comment"># 暴力 + 集合/哈希</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    k, hs = <span class="number">1</span>, <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>): <span class="comment"># 枚举长度</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - l + <span class="number">1</span>):</span><br><span class="line">            tmp = s[i:i+l] <span class="comment"># 注意切片:后要是末端下标+1</span></span><br><span class="line">            <span class="keyword">if</span> tmp <span class="keyword">in</span> hs: <span class="comment"># 判断字符串是否在集合中</span></span><br><span class="line">                k = l + <span class="number">1</span></span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hs.add(tmp)</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">print</span>(k)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>二分 + 集合/哈希</p><p>这里使用了一种非常巧妙的方法：不用注意判断子串是否在集合中，直接将所有子串放到集合中，如果没有相同的，则集合中元素数量等于<code>n-k+1</code>，<code>k</code>为子串长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 1460. 我在哪？（每日一题）</span></span><br><span class="line"><span class="comment"># 二分 + 集合/哈希</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    l, r, hs = <span class="number">1</span>, n, <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 集合中元素数量等于n-mid+1，说明所有元素互不相同，没有重复子串</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>([s[i:i+mid] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - mid + <span class="number">1</span>)])) == n - mid + <span class="number">1</span>:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(l)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>二分 + 字符串哈希</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 1460. 我在哪？（每日一题）</span></span><br><span class="line"><span class="comment"># 二分 + 字符串哈希</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    s = <span class="built_in">input</span>()</span><br><span class="line">    P, MOD = <span class="number">131</span>, <span class="number">2</span> &lt;&lt; <span class="number">64</span> - <span class="number">1</span></span><br><span class="line">    hs, bs = [<span class="number">0</span>] * (n + <span class="number">1</span>), [<span class="number">1</span>] * (n + <span class="number">1</span>) <span class="comment"># 注意下标从1开始，需要多开一位</span></span><br><span class="line">    l, r, <span class="built_in">hash</span> = <span class="number">1</span>, n, <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>): <span class="comment"># 注意下标从1开始，需要多开一位</span></span><br><span class="line">        bs[i] = (bs[i - <span class="number">1</span>] * P) % MOD</span><br><span class="line">        hs[i] = (hs[i - <span class="number">1</span>] * P + <span class="built_in">ord</span>(s[i - <span class="number">1</span>])) % MOD</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mid</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - mid + <span class="number">1</span>):</span><br><span class="line">            l, r = i + <span class="number">1</span>, i + mid</span><br><span class="line">            <span class="comment"># 求字符串哈希值</span></span><br><span class="line">            v = (hs[r] - hs[l - <span class="number">1</span>] * bs[r - l + <span class="number">1</span>]) % MOD</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">hash</span>.add(v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> check(mid):</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(l)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="123-蓝桥云课"><a href="https://www.lanqiao.cn/problems/1591/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=%E4%BA%8C%E5%88%86">123 - 蓝桥云课</a></h2><p>出处：蓝桥杯2021国赛难度：中等类型：二分</p><p>善于观察形式特点和性质</p><p>双重求和，第一层求和为等差数列公式求和，第二层求和为前缀和求和</p><p>确定第i个数所在的区间使用了二分法由<br>$$<br>\sum n^2 = 1^2 + 2^2 + 3^2+ \ldots + n^2 = \frac{ n *(n+1) * (2n+1) }{6}<br>$$<br>得，</p><p>$$<br>\begin{align}<br>\sum n * (n+1) &amp; = \sum ( n^2 + n ) \\<br>&amp; = \frac{ n * (n+1) * (2n+1) }{6} + \frac{ n* (n+1) }{2} \\<br>&amp; = \frac{ n * (n+1) * (2n+4) }{6} \\<br>&amp; = \frac{ n * (n+1) * (n+2) }{3} \\<br>\end{align}<br>$$</p><p>数列中的每一个连续的部分可以看作一个小区间。</p><p>每一个小区间都是一个 $ a_1 = 1$， $d=1 $ 的等差数列，且区间的长度也能构成等差数列。</p><p>由于$ l, r \leq 1012 $ ，即<br>$$<br>2(1+n) \times n \geq 10^{12}<br>$$<br>所以最多有 <code>1414214</code> 个小区间构成该数列，满足任意 <code>l</code>，<code>r</code> 都能落在里面。</p><p>这意味着虽然我们不能直接查询某一位置的前缀和，但可以通过这些小区间来定位和计算某一位置的前缀和。</p><ul class="lvl-0"><li class="lvl-4"><p>第 <code>i </code>个区间的元素个数为<code> i</code>。</p></li><li class="lvl-4"><p>定义<code> a[i]</code> 表示前<code> i</code> 个小区间的元素个数（<code>1 ~ n</code> 的和）。则有：$ a[i] = a[i−1] + i $</p></li><li class="lvl-4"><p>定义<code> s[i]</code> 表示前 <code>i</code> 个小区间的和。则有：$ s[i] = s[i−1] + a[i]$</p></li><li class="lvl-4"><p>对于数列中任意位置<code> i</code> ，一定存在一个最大的<code>j</code>满足 $ a[j] \leq i $，这表示第<code>i</code>个数落在第 <code>j+1</code> 区间内。</p></li><li class="lvl-4"><p>对于数列中任意位置<code> i</code>，当它落在第 <code>j+1 </code>个区间，它是该区间第<code>k</code>个数，则它在数列中的前缀和为：$ s[j] + a[k] $，其中 $ k = i − a[j] $。</p></li></ul><p>时间复杂度：$O(C+T×logC)$，C=1414215 是常数。<br>空间复杂度：$O ( C ) $</p><h3 id="C-4">C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀和 + 二分 + 等差求和公式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> n)</span></span>&#123; <span class="comment">// 等差数列前n的和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * n * (n+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 公式法求解复杂度最小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123; <span class="comment">// 求解区间[1, x]的元素和</span></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>,r = N<span class="number">-10</span>; <span class="comment">// 二分法搜索</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(mid) &lt;= x) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res += sum[l];</span><br><span class="line">    <span class="type">int</span> n = x-<span class="built_in">get</span>(l);</span><br><span class="line">    res += <span class="built_in">get</span>(n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">        sum[i]=<span class="built_in">get</span>(i);</span><br><span class="line">        sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">// 求解区间[1, x]的元素和</span></span><br><span class="line">        <span class="comment">// 前缀和的思想</span></span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        ll res=<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 前缀和</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-4">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 123 - 蓝桥云课</span></span><br><span class="line"><span class="comment"># 二分 + 求和公式</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">getp</span>(<span class="params">x</span>): <span class="keyword">return</span> x*(x+<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">gets</span>(<span class="params">x</span>): <span class="keyword">return</span> x*(x+<span class="number">1</span>)*(x+<span class="number">2</span>) // <span class="number">6</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">x</span>):</span><br><span class="line">    l, r = <span class="number">1</span>, <span class="built_in">int</span>(<span class="number">2e6</span>+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">      mid = r + l &gt;&gt; <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> getp(mid) &gt;= x: r = mid</span><br><span class="line">      <span class="keyword">else</span>: l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> l, x - getp(l-<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">    L, R = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    pl, nl = search(L-<span class="number">1</span>)</span><br><span class="line">    pr, nr = search(R)</span><br><span class="line">    <span class="built_in">print</span>(gets(pr - <span class="number">1</span>) + getp(nr) - gets(pl - <span class="number">1</span>) - getp(nl))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h2 id="区间移位-蓝桥云课"><a href="https://www.lanqiao.cn/problems/111/learning/?page=1&amp;first_category_id=1&amp;sort=students_count&amp;second_category_id=3&amp;tags=%E4%BA%8C%E5%88%86">区间移位 - 蓝桥云课</a></h2><p>出处：蓝桥杯2017国赛难度：困难类型：二分 枚举</p><h3 id="问题分析-2">问题分析</h3><p>本题是典型的二分套路题：最大值最小化</p><p><img src="https://mdpic.dreamgo.fun/img/%E5%8C%BA%E9%97%B4%E7%A7%BB%E4%BD%8D.png" alt="区间移位"></p><p><img src="https://mdpic.dreamgo.fun/img/%E5%8C%BA%E9%97%B4%E7%A7%BB%E4%BD%8D1.png" alt="uid1787145-20220327-1648372878604"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">20000</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; reg;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;node&gt; <span class="title">tmp</span><span class="params">(reg)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">node now = tmp[i];</span><br><span class="line"><span class="type">int</span> ta = now.a;</span><br><span class="line"><span class="type">int</span> tb = now.b;</span><br><span class="line"><span class="keyword">if</span> (ta - x &lt;= k &amp;&amp; tb + x &gt;= k)&#123;</span><br><span class="line">found = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> len = tb-ta;</span><br><span class="line"><span class="comment">// if(ta+x&gt;=k) k += len;</span></span><br><span class="line"><span class="comment">// else k = tb+x;</span></span><br><span class="line">        k += <span class="built_in">min</span>(len, tb + x - k);</span><br><span class="line">tmp.<span class="built_in">erase</span>(tmp.<span class="built_in">begin</span>()+i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!found || k&gt;=maxn) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k &gt;= maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">a *= <span class="number">2</span>;</span><br><span class="line">b *= <span class="number">2</span>;</span><br><span class="line">reg.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(reg.<span class="built_in">begin</span>(),reg.<span class="built_in">end</span>(),cmp);</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = maxn;</span><br><span class="line"><span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) </span><br><span class="line">         r = mid;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">double</span> ans = r / <span class="number">2.0</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Python-5">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">  </span><br><span class="line">  q = <span class="built_in">sorted</span>([[<span class="built_in">int</span>(x) * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">input</span>().split()] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], </span><br><span class="line">  key = <span class="keyword">lambda</span> x: (x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mid</span>):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    cq = q.copy()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      flag = <span class="literal">False</span></span><br><span class="line">      <span class="keyword">for</span> x <span class="keyword">in</span> cq:</span><br><span class="line">        l, r = x[<span class="number">0</span>], x[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> l - mid &lt;= s &lt;= r + mid:</span><br><span class="line">          s += <span class="built_in">min</span>(r -  l, r + mid - s)</span><br><span class="line">          <span class="comment"># if  q[i][0] + mid &gt;= s:</span></span><br><span class="line">          <span class="comment">#   s += q[i][1] -  q[i][0] </span></span><br><span class="line">          <span class="comment"># else:</span></span><br><span class="line">          <span class="comment">#   s = q[i][1] + mid</span></span><br><span class="line">          flag = <span class="literal">True</span></span><br><span class="line">          cq.remove(x)</span><br><span class="line">          <span class="keyword">break</span> </span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> flag <span class="keyword">or</span> s &gt;= <span class="number">2e4</span>: <span class="keyword">return</span> s &gt;= <span class="number">2e4</span></span><br><span class="line"></span><br><span class="line">  l, r = <span class="number">0</span>, <span class="built_in">int</span>(<span class="number">2e4</span>)</span><br><span class="line">  <span class="keyword">while</span> l &lt; r:</span><br><span class="line">    mid = l + r &gt;&gt; <span class="number">1</span> </span><br><span class="line">    <span class="keyword">if</span> check(mid): </span><br><span class="line">      r = mid</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">      l = mid + <span class="number">1</span></span><br><span class="line">  <span class="built_in">print</span>(l / <span class="number">2</span> <span class="keyword">if</span> l % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">else</span> l // <span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">  n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">  </span><br><span class="line">  q = <span class="built_in">sorted</span>([<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], </span><br><span class="line">  key = <span class="keyword">lambda</span> x: (x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">mid</span>):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    cq = q.copy()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      flag = <span class="literal">False</span></span><br><span class="line">      <span class="keyword">for</span> x <span class="keyword">in</span> cq:</span><br><span class="line">        l, r = x[<span class="number">0</span>], x[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> l - mid &lt;= s &lt;= r + mid:</span><br><span class="line">          s += <span class="built_in">min</span>(r - l, r + mid - s)</span><br><span class="line">          <span class="comment"># if  q[i][0] + mid &gt;= s:</span></span><br><span class="line">          <span class="comment">#   s += q[i][1] -  q[i][0] </span></span><br><span class="line">          <span class="comment"># else:</span></span><br><span class="line">          <span class="comment">#   s = q[i][1] + mid</span></span><br><span class="line">          flag = <span class="literal">True</span></span><br><span class="line">          cq.remove(x)</span><br><span class="line">          <span class="keyword">break</span> </span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> flag <span class="keyword">or</span> s &gt;= <span class="number">1e4</span>: <span class="keyword">return</span> s &gt;= <span class="number">1e4</span></span><br><span class="line"></span><br><span class="line">  l, r = <span class="number">0</span>, <span class="number">1e4</span></span><br><span class="line">  eps = <span class="number">1e-3</span></span><br><span class="line">  <span class="keyword">while</span> r - l &gt; eps:</span><br><span class="line">    mid = (l + r)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> check(mid): </span><br><span class="line">      r = mid</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">      l = mid</span><br><span class="line">  x = (l + r) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">abs</span>(<span class="built_in">round</span>(x)-x)&lt;<span class="number">0.05</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">round</span>(x))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">int</span>(<span class="built_in">round</span>(x*<span class="number">10</span>))/<span class="number">10</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯备赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯备赛 </tag>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认清现实，迎接挑战</title>
      <link href="/2023/03/04/%E8%AE%A4%E6%B8%85%E7%8E%B0%E5%AE%9E%EF%BC%8C%E8%BF%8E%E6%8E%A5%E6%8C%91%E6%88%98/"/>
      <url>/2023/03/04/%E8%AE%A4%E6%B8%85%E7%8E%B0%E5%AE%9E%EF%BC%8C%E8%BF%8E%E6%8E%A5%E6%8C%91%E6%88%98/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="04f140a3aa8ce873f323731b63580ee74b49b50d35fb0ac9beca0d21574cd998">0a9f54710ab1d21f49485fe815ff4acb17b1c8e849c48203da8f36a71122f74ea1a5a14477d4173fe30151ae9d18ce0cc845ee2eb1bef07fa2038970e31e17c892776f191f3a51a2a2d0fd9e02881f8a334af1470832451901d2bfa8b7f1941d2a924904b441e0b19bbcc863a426ba0d78631a53414bfa814a76a5cb4db62f56d916c836453103553e262d32f51e83e03151209e70e58fbb5327de0ba2a177c8dc60f7ae59c11d12758ddf19a34e5e8ea6aa85e93aee12a3089fa33289c0de3021b61359d62a3ebe7b851ddb5025f84eabc065088bf57f6b4f7f50e97765bc31082c8f1e05c921f38c189ce8e7849b2c9bd011d3c85a7deb207cc3872149361ef3a5780bf151e8caafe21c18dba5f1c3adceca096a0e25782d4b3e94f1602d0616dd2057adbcfbe48f72dd04112cc640b37022e09f2ddbf9b8f696bb8cbd0f085e5e46d6a26fb7e032e58b04433573f401e296d764912d2cfc230561a6dfb52cc467aa71501f6255619acc510b6055f2c9ed0557d8ac7c0e772bc37fa4a8e2bd279355bc96e4a6dcb9687fafcd18d9820850dfc379e02ee7339a8a1547519ccffc31b83d7af3e263eabb559a010d3f678f6d9c2851ae1ae6c3d9fdafce350489e936bf550de2d5478b9d7d3da648310bae085ae7de186a0192ed0c31bf1167f26ba318fd582000e30976f316e75649ed037a3434754f911f61a7d2c33badebf68c569df3bb9f9265bca7f48e68e097643c2fe846086f469cfec20a2fdf42dc6d7ababd81800caf5438d3c4bf994a22762ea30b85f7b04dfc2d0e42ea2c08aa5817000b2d873be35959b17e61823d97809b082bf2a2386636d9190a9819e3c500eff918ff70c917cb647e1c4cc85bb390a4132acec29676fbb7e5d72bfefc69716960878bff264d861c39238bcb203264312b5b5e6e7ea56f4d06eac64059e8f4f2b3391bbcb17ccb819bdc1ea73a46aea1fdc5a99121e595dda1a83fb15e68885886b6f577e87ddb5c4e7c09a1033e34a032dd92f69838efcd3f7760280fafde43ebc8bd1fe635efda1cace92c68b35034ff1a9fc73ca4ca019f47ffb308ef8761b8b3cb6782c9d627d44e5d0e83b823a99821e4c8b1015053af3a8402f426fdd8d66c34cd9416bed7036b1e5230389ff36e82c80b25f6785a38b05c3ebc7c2ddb1f706e1ffee62a52da1304ab986e6dec9d45efbddb0aa21b30e113048ca980d00f834db0af70532e87ccbdfa1e544bee62d84c9748be6ac20b19d9b9081e00c251f50cfed63adcbd1b96d78c21049fd989d467061c0af05e31dc62837ce340</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">🐶嘿嘿, 你没有权限进入呢！🐕.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视觉信息的捕获——感受野</title>
      <link href="/2023/02/28/%E8%A7%86%E8%A7%89%E7%9A%84%E7%94%9F%E7%89%A9%E6%9C%BA%E5%88%B6-20230228-%E8%A7%86%E8%A7%89%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8D%95%E8%8E%B7%E2%80%94%E2%80%94%E6%84%9F%E5%8F%97%E9%87%8E/"/>
      <url>/2023/02/28/%E8%A7%86%E8%A7%89%E7%9A%84%E7%94%9F%E7%89%A9%E6%9C%BA%E5%88%B6-20230228-%E8%A7%86%E8%A7%89%E4%BF%A1%E6%81%AF%E7%9A%84%E6%8D%95%E8%8E%B7%E2%80%94%E2%80%94%E6%84%9F%E5%8F%97%E9%87%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="视觉信息的捕获——感受野">视觉信息的捕获——感受野</h1><blockquote><p>本文主要整理自危辉教授《类脑计算》，期望通过学习视觉的生物机制，能够为后面计算机视觉的科研提供借鉴与启发</p></blockquote><p>生物视觉系统可以看成一个黑箱处理器，它的输入时图像，输出是心理物理学的响应 。如同计算机视觉系统那样，<strong>人类视觉系统首先要对信号采样、量化和编码，然后作进一步的处理</strong>。<strong>信号数字化从本质上看是把信息从连续的模拟域映射到被采样和量化的数字阵列</strong>。人类视觉系统的”数字化器“就是<strong>视网膜阵列</strong>。它起的作用就是<strong>对输入的图像在时间域和空间域进行采样</strong>。</p><p>（这里真得强调《信号和系统》这门课好重要，作为计算机的学生，后面真的要好好补一下！😭)</p><p>物体在眼球中成像以后，在细胞层次上对信号做处理的是神经节细胞。它所完成的处理与视网膜上的感光细胞在空间上是如何以所谓”感受野“形式组织起来有关。信息的处理首先依托于信息的捕获机制。</p><p>感受野是指当视网膜上某一特定区域受到光刺激时，引起视觉通路较高层次上单一神经纤维或单一神经细胞的电反应，这个区域便是该神经纤维或细胞的感受野。在视觉通路不同层次上的单个细胞都有一定的感受野。</p><h2 id="同心圆拮抗式的经典感受野">同心圆拮抗式的经典感受野</h2><p>空间整合特性：处理图像区域亮度对比信息、提取图像的边缘信息。相当于高频滤波器</p><h2 id="非经典感受野">非经典感受野</h2><p>非经典感受野是在经典感受野之外的一个大范围区域，单独刺激该区域并不能直接引起细胞的反应，但对经典感受野内刺激所引起的反应有调制作用。相当于低频滤波器。</p><p>视网膜神经节细胞的非经典感受野主要是去抑制性的，因此可以在一定程度上弥补由经典感受野所造成的低空间频率信息的损失，在保持边界增强功能的同时，传递图像的区域亮度梯度信息，显示大面积表面上亮度的缓慢变化。</p>]]></content>
      
      
      <categories>
          
          <category> 视觉的生物机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感受野机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络与生物机制的对比思考</title>
      <link href="/2023/02/28/%E8%A7%86%E8%A7%89%E7%9A%84%E7%94%9F%E7%89%A9%E6%9C%BA%E5%88%B6-20230228-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%94%9F%E7%89%A9%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94%E6%80%9D%E8%80%83/"/>
      <url>/2023/02/28/%E8%A7%86%E8%A7%89%E7%9A%84%E7%94%9F%E7%89%A9%E6%9C%BA%E5%88%B6-20230228-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E7%94%9F%E7%89%A9%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="29cd037c150cf90a9c4514a9a5a58d540d085fe109a9b1941e92379d5135c170">0a9f54710ab1d21f49485fe815ff4acbd008780628f3e1bbd17e596a77d61bc4589dea7a5ef0853e55219e4c3b27b63f159d40ff38aa1efa7d5b92131db8bbf081fc9d47bef665d85e32ab43e706fc91a2c19e53b09a013c4bee2877fa6271f22349bf1fccd8353bd8f0817f4bd78b15419dea7aed5492c97788a115bb35f0b64d2561fe2ebf62192f0cf12aafc8ada5c2d4c4987de74f82194721912456c738f9035b9a8e4c2e4ddd37896d93f08e772f8885d2aa8d76a259865d6152703bc43445a16032a634b8b0f31ded9d342ff0449eb693c29f314a39ee5a1f7daf7370e0d86a4d4d33165cfe7edc48369f2048665991830d6e464bc644eb97421b2ae69b31061ebf8851e7d9d82ede5edd97081bbdf707cd9b229186c890ec384b0e832a62e29236b7121b08eed728cc425dc71054a6fd935f5ec777e40aed29ebf2b3e0cedeeb7170a982a8f50e578a4ad255b8b3d73a83a09c3e798df5ecd0333b34b5531c402e54eb8780eb1118cc3a30ee5bbf1754e71c4b20da80a5d6801324b416c380570d4d839cf6f18a0b29348718008e40f017022d7d2158d7c7873d2248f19b4d09a40ccc7a19fa92b73fb47a451b31c580488c8149a9257a2611b75fbb06db60d2d4f98ce2ef5059239bc9313c159d9118d809ab34a1987144bd470294eeece007ed2162b99369a78c6d2bcc60e19ecd7615e9af8a0cd5d121597852e8b0aec89cd5b515dae18677bc2628b17c4c0a3294dce7b1a5971de2eb2b831916c4491707303a5497ff59694a2badb5c524e1c0f384f8bb388c7ba7c0d7fcea2c44061f27058b2435ca2629cd937eeeef108af5908350e0b2153910397a6b7d535c06006a179c0d97f20bb98a20e6021739eafca5329d9ca58db8a59ada4545de8be7f2b9f40249277b4acbd245bc0291cd3a79731b75026963e545006760e3e043d27a2b049dcf522ee3a5e20eab7c8c82b2a661b5ad2c4f89c614e6c786d1b151db2b322dd8b7c3196ab221423784a5bca686b73d01405f3821cbf1927ce70eb51742ab89d42c8fa750c9d80d8b1d41e9e73917e2a7e1bf1f6538d69c790038c0cbac9bfc4ab88ad1d0439bb372637bbb1700f0769e07befaa54061dac087231971749e1fecfe48578e2908ff0d0e3bbbf45c24e517968b0f9bf119e36689aecf8ff97dce1b7b372aebb51ca49c252a4203df4e4b1024be22faabcf765f8c532e0aa35dcda539a4a025359688d94f37fbc7df658ce942495fbf927be644ae460361ec374c210475c44ec94a4ddc49166fc2ecde86ccdb1d0c3bb97a93cab5f4a161de154814e6948a85ce79b2312bc360f8535461ca95dadcba4598d5bca9a525f31416b2840a6ee53ae8007584b6ad8120cd7467b7295fe501a258404da930d736b4e528aaa5995dcdb16691d4bd5466e22a887a9cb321b733b6d6c1372af3452262cd33a4e195aef329ef23336119010e206c65cf0f5998ee544a3d1e94ca0cd9381ea7f1e279a6f1c7395a4b7e171861dbdf61a1d4a915c7559adf662693b562804623d41decf3a279c073abdaead17958ecefa4b106c1541a1469facd914b3e7203245be5eba466d60908cb6205ef147ad38389609d8b1bfdbdb6722f549d839dc945670c5eb32f2180a08130b98ed0add00242d05d0368aa6c14e57dcba3741331b09496b1998ad0e3a70bed8506791efc7f078116d317a377252c69bd16db1b7b9ce688f62b360d7a1046a1a10062584c2de1ddd64f17014e4d5d9fefcb987e488c8726b4fb1b47330e9d2015e63d616065683c0af73f1182b19b1ccd628a8f1174d3f196d1ccfdabde0800791f50db3c545d15979bb7b82cee304750207a0f7f4850be7212fa3e789c25fd4e14f3b0b5bf2257a5aa9a990d9d1815c2b48a013c4666df9aa05d8806f5d70c643132c677063c972638e461036df465b985e3014ccce7efa969371dc518f61c5ab68bc089d880ad47a600710be87cf0730656bae1f4565046ceb7cc349c50f8a4e6d781b22078e2bdd9ecf150e2a730d13dba39d637fd4dcd7863b0c84e45ca1432295ce4288bbca0de858ebbf5f32a603608452e94590c17bc6aa4e40ed3acf28b83be4cda599bf705d900bc8d9753acbe04515381010b1787e2fadc2c27c641102e113229376f28114b4a0fc0a036d35bfb47f79bda939b63df2082040de4698571e825af5843c9628423ddbf7ffdb2f50f890670eca2cbc6c21ffae9cd111b7d7ce5217112d83a79ba806160f51800ed9e517052012c0e35c4050bfffcd5802c821c5e07f883ab30fd3226aa9514a8ac03e377ad23f341c8c4e84698c2f0bb61df233e76a00c57c72af242de75678c1c5b834eb07f76648d89797708ce466932dab202f37c0911bc920c58c881dd1c0e680db77b1b3418ca4cc15904d41147f90479f7aebf6334b2012023d48e110581eda3047c896215f1503448b8157ea2d6a8c4f177ed453ed9ae983a5273a4a06b89c4db4a568de9044b2fcd59eaf0f9dbacc128775b0c229fc8100dc46796532fa0ec750e3ac6eef9856591315fdb0965225482321b005b3987246ac7c5fe53365bd171decafd29c93a3f27844136c658f454fcb1dbc8f8a691a5075f3245d26f59b928051b9f8e382d4351768a9b20c6ff1a099210cae7f0116d135d2b8ef05c2b4733d974e81ab577670d349944d528fdf5c2c169b26c4d68b3fc54ae308953fb64bffc546adcc3865513015b93b0daa61eb397145ad95af0f9e52e731e450784be04bdd744e6e87a77884283d6cb71f340490b3cf7893e4951e4d7cefa3df664a44e1bd5f552ac5d515d770be1774817e3831dbd066d1d7385ad5568aa127824afc78fbd14774705aa425596a648acd58ea2930cd6cee89e1b1d6ff12532</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">🐶嘿嘿, 你没有权限进入呢！🐕.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 视觉的生物机制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 加密 </tag>
            
            <tag> 视觉认知思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2.3 DFS之迭代加深、双向DFS、IDA*</title>
      <link href="/2023/02/28/2-2-3-DFS%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E3%80%81%E5%8F%8C%E5%90%91DFS%E3%80%81IDA/"/>
      <url>/2023/02/28/2-2-3-DFS%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E3%80%81%E5%8F%8C%E5%90%91DFS%E3%80%81IDA/</url>
      
        <content type="html"><![CDATA[<h1 id="2-2-3-DFS之迭代加深、双向DFS、IDA">2.2.3 DFS之迭代加深、双向DFS、IDA*</h1><h2 id="一-DFS之迭代加深-IDDFS">一. DFS之迭代加深(IDDFS)</h2><p>针对某些分支非常深，但答案却在比较浅的分支的层中，为防止进入深分支的”无底洞“而浪费过多时间，需要设置每次搜索的深度，使用迭代加深的DFS搜索。尤其是某些题目会限制搜索步长，如”10以内搜索不到结果就算无解”。</p><p>迭代加深设置一个层数上限max_depth，搜索时如果当前层数大于max_depth后则直接返回。相当于每次把层数大于max_depth的层先全部剪掉，也可以把max_depth看成划定了搜索区域，每次一片区域一片区域的搜，可以有效地减小搜索空间。</p><p><img src="https://mdpic.dreamgo.fun/img/2675_69ed07da7c-1.png" alt="2675_69ed07da7c-1"></p><p>迭代加深和宽搜的区别：</p><ul class="lvl-0"><li class="lvl-3"><p>宽搜搜索空间的复杂度每次是指数级别的，每次把该层的节点全部记录到队列中。</p></li><li class="lvl-2"><p>迭代加深本质仍是深度优先搜索，每次只会记录当前分支（路径）的信息，空间复杂度是O(n)的，与高度成正比</p></li></ul><p><img src="https://mdpic.dreamgo.fun/img/image-20230226233001792.png" alt="image-20230226233001792"></p><p>迭代加深水从存在重复搜索的问题，每次更新max_depth进行搜索时都是从头开始搜索，会对浅层进行重复搜索。如当深度限制为d是，会重复搜索1~d-1层的节点，但是当搜索树节点分支数目较多时，随着层数的深入，每层节点数会呈指数级增长，因此重复的搜索和深层子树的规模相比可以忽略不计。如以满二叉树为例，前n-1层总节点数为$2^1 + 2^2 + \ldots + 2^{n-1} = 2^{n} - 1$，而第n层的节点数为$2^n$，当分支数更多时这种差距更大，所以对于浅层的重复搜索可以忽略不计。</p><p>迭代加深后的DFS具有类似BFS性质，当从0开始一层层加深时depth能够记录最小步长。</p><h3 id="1-AcWing-170-加成序列">1. <a href="https://www.acwing.com/problem/content/172/">AcWing 170. 加成序列 </a></h3><h3 id="搜索顺序：">搜索顺序：</h3><p>​枚举前面的所有数<code>i</code>，<code>j</code>（<code>i</code>可以等于<code>j</code>），填写当前位置的数</p><h3 id="剪枝">剪枝</h3><ol><li class="lvl-3"><p>优化搜索顺序：从大到小枚举<code>i</code>和<code>j</code></p></li><li class="lvl-3"><p>排除等效冗余：不同<code>i</code>和<code>j</code>，<code>X[i]+X[j]</code>可能相等，枚举的组合出现实质冗余，需要判重</p></li><li class="lvl-3"><p>可行性剪枝：由于序列一定是严格单调递增的，所以当前节点值 $V_u$ 大于目标值<code>n</code>，或小于等于前一节点值 $V_{u-1}$ 时，直接剪枝</p><p>注意由于每个位置的填写都是枚举前面任意两节点值的和，所以是可能出现枚举得到的值$V_{u}$小于等于 $V_{u-1}$ 的，必须要判断并剪枝，不要忽略！</p></li></ol><p>可以注意到分支最短时是第<code>k</code>位取<code>k-1</code>位的两倍，即 $2^u$ ，分支指数增长。而分支最短的是每次加1，第k层大小为<code>u</code>。由此可以发现不同分支为了达到某一数量级的，深度差距很大。同时由于可以是任意两个数的组合，所以分支非常多，且分支数随深度成平方级增长 $(C_u^2)$ 。由此，可以使用迭代加深。</p><p><img src="https://mdpic.dreamgo.fun/img/2675_b66a50cb7c-4.png" alt="2675_b66a50cb7c-4"></p><h4 id="进一步优化剪枝">进一步优化剪枝</h4><p>在优化搜索顺序时，除了先枚举较大的数，其实可以发现只需枚举前一层第<code>u-1</code>层与前<code>u-1</code>层所有数字能否组合出合法序列，而不用任意枚举两个数的组合！</p><p>且这样枚举一定能保证$V_{u}$大于$V_{u-1}$的，满足单调递增要求。</p><h4 id="C">C++</h4><p>恢复现场版，慢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 170. 加成序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == depth) <span class="keyword">return</span> path[u - <span class="number">1</span>] == n;</span><br><span class="line">    <span class="comment">// if (u &gt; depth) return false;</span></span><br><span class="line">    <span class="comment">// if (path[u - 1] == n) return true;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; -- j)&#123;</span><br><span class="line">            <span class="type">int</span> v = path[i] + path[j];</span><br><span class="line">            <span class="comment">// 可行性剪枝：由于序列一定是严格单调递增的，所以当前节点值V_u大于目标值n，或小于等于前一节点值V_&#123;u-1&#125;时，直接剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (v &gt; n || v &lt;= path[u - <span class="number">1</span>] || st[v]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 剪枝之排除等效冗余：不同i和j，X[i]+X[j]可能相等，枚举的组合出现实质冗余，需要判重</span></span><br><span class="line">            st[v] = <span class="literal">true</span>;</span><br><span class="line">            path[u] = v;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, depth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 恢复现场</span></span><br><span class="line">            st[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        path[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 起始节点一定是1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置迭代加深的最大深度depth</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 每次搜索失败则加大搜索深度</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, depth)) depth ++; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不恢复现场版，速度比恢复现场版快一半多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 170. 加成序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == depth) <span class="keyword">return</span> path[u - <span class="number">1</span>] == n;</span><br><span class="line">    <span class="comment">// if (u &gt; depth) return false;</span></span><br><span class="line">    <span class="comment">// if (path[u - 1] == n) return true;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> st[N] = &#123;<span class="number">0</span>&#125;; <span class="comment">// st数组每轮递归都会被重开，避免恢复现场，速度更快</span></span><br><span class="line">    <span class="comment">// 剪枝之优化搜索顺序：从大到小枚举i和j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; -- j)&#123;</span><br><span class="line">            <span class="type">int</span> v = path[i] + path[j];</span><br><span class="line">            <span class="comment">// 可行性剪枝：由于序列一定是严格单调递增的，所以当前节点值V_u大于目标值n，或小于等于前一节点值V_&#123;u-1&#125;时，直接剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (v &gt; n || v &lt;= path[u - <span class="number">1</span>] || st[v]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 剪枝之排除等效冗余：不同i和j，X[i]+X[j]可能相等，枚举的组合出现实质冗余，需要判重</span></span><br><span class="line">            st[v] = <span class="literal">true</span>;</span><br><span class="line">            path[u] = v;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, depth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 这里不需要恢复现场，因为path[u]会被直接覆盖，而st数组每轮递归都会被重开</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        path[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 起始节点一定是1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置迭代加深的最大深度depth</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 每次搜索失败则加大搜索深度</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, depth)) depth ++; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步优化剪枝，速度再次降一半</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 170. 加成序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == depth) <span class="keyword">return</span> path[u - <span class="number">1</span>] == n;</span><br><span class="line">    <span class="comment">// if (u &gt; depth) return false;</span></span><br><span class="line">    <span class="comment">// if (path[u - 1] == n) return true;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> st[N] = &#123;<span class="number">0</span>&#125;; <span class="comment">// st数组每轮递归都会被重开，避免恢复现场，速度更快</span></span><br><span class="line">    <span class="comment">// 剪枝之优化搜索顺序：从大到小枚举i和j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = u - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)&#123;    </span><br><span class="line">        <span class="type">int</span> v = path[i] + path[u - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 可行性剪枝：由于序列一定是严格单调递增的，所以当前节点值V_k大于目标值n，或小于等于前一节点值V_&#123;k-1&#125;时，直接剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (v &gt; n || v &lt;= path[u - <span class="number">1</span>] || st[v]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 剪枝之排除等效冗余：不同i和j，X[i]+X[j]可能相等，枚举的组合出现实质冗余，需要判重</span></span><br><span class="line">        st[v] = <span class="literal">true</span>;</span><br><span class="line">        path[u] = v;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, depth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 这里不需要恢复现场，因为path[u]会被直接覆盖，而st数组每轮递归都会被重开</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n)&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        path[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 起始节点一定是1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置迭代加深的最大深度depth</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 每次搜索失败则加大搜索深度</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">1</span>, depth)) depth ++; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; ++ i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python">Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 170. 加成序列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># u 为当前层数 / path 下标，depth为最大搜索层数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u, depth</span>):</span><br><span class="line">        <span class="comment"># 限制搜索层数</span></span><br><span class="line">        <span class="keyword">if</span> u == depth:</span><br><span class="line">            <span class="keyword">return</span> path[u - <span class="number">1</span>] == n</span><br><span class="line">        vis = [<span class="literal">False</span>] * MAX_D</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 优化搜索顺序，先枚举较大的数</span></span><br><span class="line">        <span class="comment"># 且只需枚举第u-1个数字与前u-1个数字能否组合出合法序列</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(path[:u]):</span><br><span class="line">            v = x + path[u - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> v &gt; n <span class="keyword">or</span> vis[v]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 剪枝之排除等效冗余</span></span><br><span class="line">            vis[v] = <span class="literal">True</span></span><br><span class="line">            path[u] = v</span><br><span class="line">            <span class="keyword">if</span> dfs(u + <span class="number">1</span>, depth):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    MAX_D = <span class="number">110</span></span><br><span class="line">    path = [<span class="number">1</span>] * MAX_D </span><br><span class="line">    <span class="comment"># 这里对起始节点path[0]进行了初始化，其一定为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 迭代加深像是 「限制层数的广搜」 版本的深搜</span></span><br><span class="line">    <span class="comment"># 优势在于空间复杂度低，代码量低</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        depth = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> dfs(<span class="number">1</span>, depth):</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, path[:depth])))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="二-双向DFS">二. 双向DFS</h2><p>双向DFS原理与双向BFS相同，通过双向搜索来减少搜索空间。使用双向搜索要求题目具有明确的初态和终态，从而从两端开始搜索。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230227142845608.png" alt="image-20230227142845608"></p><p><img src="https://mdpic.dreamgo.fun/img/2675_357470bf81-1.png" alt="2675_357470bf81-1"></p><h3 id="1-AcWing-171-送礼物">1. <a href="https://www.acwing.com/problem/content/173/">AcWing 171. 送礼物</a></h3><h4 id="问题分析">问题分析</h4><p>本题数据范围为：$1 \le N \le 46$，$1 \le W, G[i] \le 2^{31}-1$ ，其中N表示礼物个数，<code>G[i]</code>表示第<code>i</code>个礼物重量，<code>W</code>表示容量上限</p><p>这题可以看作背包问题，但DP方法的时间复杂度是O(N*V)，$2^{31}$ 在 $2 \times 10^9$ 级别， $ N * 2^{31} $会超时，因此不能用求解。</p><p>但我们发现N相对较小，可以尝试使用暴搜。而直接暴搜的话需要枚举每个物品选或不选，时间复杂度是$2^{46}$，更会超时。由此我们想到使用双向DFS，尝试把时间复杂度降到$C * 2^{23} $ 级别，$ 2^{23} = 8,388,608$ 。</p><p>为此我们可以将物品划分成两部分，先将前K件物品能够凑出的所有重量枚举出来并打表。同时为了优化，存储时可以进行排序并判重。然后先将剩余N-K件物品能够凑出的所有重量枚举，并通过直接查表与前一部分的重量进行组合，得到合法方案。同时在两部分组合时可以使用贪心策略，利用二分直接找到与当前后部分重量能够组合的前部分最优重量（满足条件下的最大重量），减少枚举。</p><p><img src="https://mdpic.dreamgo.fun/img/image-20230227152016595.png" alt="image-20230227152016595"></p><p>需要使用以下方法</p><ul class="lvl-0"><li class="lvl-2"><p>双向DFS暴搜</p></li><li class="lvl-2"><p>空间换时间的思想，先对前部分的所有情况打表，后面可直接使用而不用再搜索</p></li><li class="lvl-2"><p>二分法快速找到集合中满足条件（小于等于某数）的最大的数</p><p>注意二分不能用哈希代替，设当前后部分枚举重量为S，我们要做的是在前部分找到小于等于W-S的最大数，而不是确定W-S是否存在</p></li></ul><h4 id="基本思路">基本思路</h4><ol><li class="lvl-3"><p>将所有物品按重量从大到小排序</p></li><li class="lvl-3"><p>先将前K件物品能够凑出的所有重量打表，然后排序判重</p></li><li class="lvl-3"><p>搜索剩下的N-K件物品的选择方式，然后在表中二分出不超过W的最大值</p></li></ol><h4 id="进一步剪枝优化">进一步剪枝优化</h4><ol><li class="lvl-3"><p>优化搜索顺序</p><p>把礼物按照重量降序排序后再分半，搜索。（先搜较大的数，使分支更少）</p></li><li class="lvl-3"><p>选取适当的“折半划分点”</p><p>当直接对半划分时复杂度为$2^{ \frac{N}{2} } + 2^{ \frac{N}{2} } * \frac{N}{2} $，前后两部分不均衡</p><p>由于复杂度分为两部分——前半部分的枚举 $2^k$ ，后半部分的枚举与匹配 $ 2^{N-k} * k $，为了实现两部分的均衡，进一步减少复杂度，需要选取适当的“折半划分点”。<br>$$<br>\frac{2^k}{ (2^{N-k} * k) } =  \frac{ 2^{2k - N} }{k}<br>$$<br>当k取25时，两者之比最接近1</p><p>然而实际情况下这种均衡并不好实现，一般还是对半分。例如，本题中$\frac{N}{2} + 2$ 就不一定更均衡。</p><p>首先需要处理特殊情况n = 1 造成的内存溢出问题。</p><p>其次，由于加大k是为了平衡后半部分DFS时二分的系数， 但是这个系数只会在叶子结点出现，由于剪枝的存在，这些点的二分并不一定能使整个DFS时间明显变得更大，这种情况下k加大2反而影响了前半和后半的平衡。</p></li><li class="lvl-3"><p>可行性剪枝，不超过上限</p></li></ol><p><img src="https://mdpic.dreamgo.fun/img/2675_3b100ab781-3.png" alt="2675_3b100ab781-3"></p><h5 id="C-2">C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 171. 送礼物</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意爆int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">25</span>; </span><br><span class="line"><span class="comment">// 前半部分物品个数k最大是25， 因此最多可能有2^25种方案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// n表示物品总个数，m表示重量上限，k表示前半部分物品个数</span></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> g[<span class="number">50</span>]; <span class="comment">// 存储所有物品的重量</span></span><br><span class="line"><span class="type">int</span> w[N]; <span class="comment">// w存储能凑出来的所有组合重量</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">// cnt记录前部分所有组合重量的个数（需去重）</span></span><br><span class="line"><span class="type">int</span> ans; <span class="comment">// 用ans来记录一个全局最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// u表示当前枚举到哪个数了，s表示当前重量的和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_s</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打表</span></span><br><span class="line">    <span class="comment">// 如果我们当前已经枚举完第k个数（下标从0开始的）了， </span></span><br><span class="line">    <span class="comment">// 就把当前的s加到w数组中去，进行打表</span></span><br><span class="line">    <span class="keyword">if</span> (u == k)&#123;</span><br><span class="line">        w[cnt ++] = s; <span class="comment">// 记录重量</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举当前不选这个物品</span></span><br><span class="line">    <span class="built_in">dfs_s</span>(u + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举选这个物品, 做一个可行性剪枝</span></span><br><span class="line">    <span class="comment">//计算和的时候转成long long防止溢出</span></span><br><span class="line">    <span class="keyword">if</span> ((LL)s + g[u] &lt;= m) &#123; </span><br><span class="line">        <span class="built_in">dfs_s</span>(u + <span class="number">1</span>, s + g[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u表示当前枚举到哪个数了，s表示当前重量的和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_e</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 二分匹配</span></span><br><span class="line">    <span class="comment">// 如果已经找完了n个节点，就得到了后半部分当前的重量组合</span></span><br><span class="line">    <span class="comment">// 那么需要通过二分进行前后部分的匹配</span></span><br><span class="line">    <span class="keyword">if</span> (u == n)&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// if (w[mid] + (LL)s &lt;= m) </span></span><br><span class="line">            <span class="keyword">if</span> (w[mid] &lt;= m - s)</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里需主要由于l从0开始，而w[0] = 0，所以可以解决s恰等于n的情况（只从后半部分选），因而不同单独判断</span></span><br><span class="line">     <span class="comment">// 且由于前面递归时始终保证了s &lt;= m（否则不会选择物品进行下一层的递归)，所以二分时是一定能找到可行的数的（最极端就是取w[0]=0)，因而循环结束后w[l] + (LL)s &lt;= m一定成立</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, w[l] + s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不选择当前这个物品</span></span><br><span class="line">    <span class="built_in">dfs_e</span>(u + <span class="number">1</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择当前这个物品</span></span><br><span class="line">    <span class="comment">// 虽然m，s，g[u]在int范围内，但s + g[u]可能会爆int，要转成LL</span></span><br><span class="line">    <span class="keyword">if</span> ((LL)s + g[u] &lt;= m)</span><br><span class="line">        <span class="built_in">dfs_e</span>(u + <span class="number">1</span>, s + g[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剪枝之优化搜索顺序，重量从大到小排序后再分组、枚举</span></span><br><span class="line">    <span class="built_in">sort</span>(g, g + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="comment">// reverse(g, g + n);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举前k个物品的重量组合并打一个表</span></span><br><span class="line">    k = n &gt;&gt; <span class="number">1</span>; <span class="comment">// 或者k = n / 2; 需注意防止 n = 1时，出现死循环</span></span><br><span class="line">    <span class="comment">// min((n &gt;&gt; 1) + 2, n - 1)这种策略实际发现并不可行</span></span><br><span class="line">    <span class="built_in">dfs_s</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 做完之后，把w数组从小到大排序，从而方便二分</span></span><br><span class="line">    <span class="built_in">sort</span>(w, w + cnt);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判重，只取不重复的</span></span><br><span class="line">    <span class="comment">// int t = 1;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt; cnt; ++ i)</span></span><br><span class="line">    <span class="comment">//     if (w[i] != w[i - 1])</span></span><br><span class="line">    <span class="comment">//         w[t ++] = w[i];</span></span><br><span class="line">    <span class="comment">// cnt = t;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去重后尾地址减首地址得到个数</span></span><br><span class="line">    <span class="comment">// unique函数可以删除有序数组中的重复元素。</span></span><br><span class="line">    <span class="comment">// 注意：</span></span><br><span class="line">    <span class="comment">// a. 这里的删除不是真的delete，而是将重复的元素放到容器末尾</span></span><br><span class="line">    <span class="comment">// b. unique函数的返回值是去重之后的尾地址（去重后最后一个不重复元素后的元素的地址）</span></span><br><span class="line">    <span class="comment">// c. 一定要先对数组进行排序才可以使用unique函数</span></span><br><span class="line">    cnt = <span class="built_in">unique</span>(w, w + cnt) - w;</span><br><span class="line">    <span class="comment">// 这里有一点需要格外注意，由于w的空间是大于需要值的，所以数组中实际上含有0</span></span><br><span class="line">    <span class="comment">// 而因此在从小到大排序并去重后，w[0] = 0并不表示物品的重量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从k开始后半部分的枚举， 当前的和是0</span></span><br><span class="line">    <span class="built_in">dfs_e</span>(k, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Python-2">Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># 剪枝之优化搜索顺序，重量从大到小排序后再分组、枚举</span></span><br><span class="line">    g = <span class="built_in">sorted</span>([<span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 将数组分割成两部分，让两部分计算的时间复杂度尽可能接近</span></span><br><span class="line">    <span class="comment"># k 做特殊处理，当 n = 1 时，k 不能大于 n</span></span><br><span class="line">    res, k = <span class="number">0</span>, n &gt;&gt; <span class="number">1</span></span><br><span class="line">    w = <span class="built_in">set</span>()</span><br><span class="line">    <span class="comment"># 先使用集合避免重复问题，再排序转成list</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将两个 DFS 进行合并，使用 lim 值的不同来标记当前是第几次搜索</span></span><br><span class="line">    <span class="comment"># u表示当前枚举到哪个数了，s表示当前重量的和</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u, s</span>):</span><br><span class="line">        <span class="keyword">if</span> u &gt;= lim:</span><br><span class="line">             <span class="comment"># lim == k 表示是第一个 DFS</span></span><br><span class="line">            <span class="keyword">if</span> lim == k:</span><br><span class="line">                 <span class="comment"># 打表，使用 set 记录第一个 DFS 搜索到的组合答案</span></span><br><span class="line">                w.add(s)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 二分法进行前后匹配，找到一个小于等于m - s的最大值</span></span><br><span class="line">                <span class="keyword">nonlocal</span> res</span><br><span class="line">                <span class="comment"># bisect.bisect和bisect.bisect_right返回大于x的第一个下标(相当于C++中的upper_bound)</span></span><br><span class="line">                <span class="comment"># bisect.bisect_left返回大于等于x的最左侧第一个下标</span></span><br><span class="line">                <span class="comment"># 当x存在多个时，bisect_left返回最左边的x的索引bisect_right返回最右边的x的索引加1</span></span><br><span class="line">                <span class="comment"># 如果元素不存在，则将其插入到何处</span></span><br><span class="line">                <span class="comment"># eg:l = [1, 4, 5]，bisect_left(l, 4)返回1，bisect_left(l, 2)返回1</span></span><br><span class="line">                <span class="comment"># bisect_left(l, 6)返回3</span></span><br><span class="line">                pos = bisect(w, m - s) - <span class="number">1</span> <span class="comment"># 这里要使用bisect而不是bisect_left</span></span><br><span class="line">                <span class="comment"># 因为bisect返回大于x的最左的第一个下标，所以其减一即得到小于等于x的最右侧的数</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, s + w[pos])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 不选择当前这个物品</span></span><br><span class="line">        dfs(u + <span class="number">1</span>, s)</span><br><span class="line">        <span class="comment"># 选择当前这个物品</span></span><br><span class="line">        <span class="keyword">if</span> s + g[u] &lt;= m:</span><br><span class="line">            dfs(u + <span class="number">1</span>, s + g[u])</span><br><span class="line">        </span><br><span class="line">    lim = k</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    w.add(<span class="number">0</span>) <span class="comment"># 这里额外插入0，否则二分后需进行特判找不到元素的情况（即s==n</span></span><br><span class="line">    <span class="comment"># 做完之后，把w数组从小到大排序，从而方便二分</span></span><br><span class="line">    <span class="comment"># 注意虽然set是无序的，但sorted会先进行排序并返回一个列表，此时w变成一个列表</span></span><br><span class="line">    w = <span class="built_in">sorted</span>(w)</span><br><span class="line">    </span><br><span class="line">    lim = n</span><br><span class="line">    <span class="comment"># 从k开始后半部分的枚举， 当前的和是0</span></span><br><span class="line">    dfs(k, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="三-IDA">三. IDA*</h2><p>IDA*将估价函数与DFS相结合，一般配合迭代加深一起食用，在每个节点我们都会预估一下当前节点最少需要多少步才能得到答案，如果最小步数多于迭代加深设置的最大层数max_depth，则直接剪枝，提前退出。</p><p>其实质是通过启发估计给迭代加深增加一个额外的剪枝：若当前深度+未来估计步数&gt;深度限制，则立即从当前分支回溯</p><p>IDA*的核心也在于设计一个估价函数，估算从每个状态到目标状态需要的步数。估价函数需要<strong>遵守“估计值不大于未来实际步数”的准则</strong>。设计时一般可以采用贪心策略，考虑最理想的情况。</p><h3 id="1-AcWing-180-排书">1. <a href="https://www.acwing.com/problem/content/description/182/">AcWing 180. 排书</a></h3><h4 id="思路分析">思路分析</h4><p>先考虑每一步的决策数量：当抽取长度为 <code>i</code> 的一段时，有 <code>n - i + 1</code> 种抽。对于每种抽法，还剩下<code>n-i</code>本书，一共有<code>n - i + 1</code>个位置可以插入这些书，除去原来的位置，有 <code>n - i</code> 种放法。另外，将某一段向前移动，等价于将跳过的那段向后移动，因此每种移动方式被算了两遍，所以每个状态总共的分支数量是：<br>$$<br>\sum _{i=1}^n(n-i) * (n - i + 1) / 2 = (15 * 14 + 14 * 13 + … + 2 * 1) / 2 = 560<br>$$<br>这里利用了：<br>$$<br>n\times(n-1)+(n-1)\times(n-2)+…+2\times1=\frac{(n-1)\times n\times(n+1)}{3}<br>$$</p><p>考虑在四步以内解决，最多有 $560^4$ 个状态，直接暴搜会超时。可以使用双向 BFS 或者 IDA * 来优化。</p><p>我们用 IDA * 来解决此题。</p><p>IDA* 与 A*算法的选择：</p><ul class="lvl-0"><li class="lvl-2"><p>需要最小字典序时，状态表示很大，指数增长加快，使用IDA*</p></li><li class="lvl-2"><p>若状态容易表示，指数增长较慢时，使用A* （注意需要最小字典序时不能使用A* ，因为它不是按照顺序搜索的）。</p></li></ul><h4 id="估价函数设计详解">估价函数设计详解</h4><ul class="lvl-0"><li class="lvl-2"><p>估价函数需要满足：<strong>不大于实际步数</strong>。且本题中，在最终状态下，每本书后面的书的编号应该比当前书多 1。</p></li><li class="lvl-2"><p>为了确定最小步数，<strong>就需要理解每步操作的实质</strong>。</p><p>首先我们需要理解何为排好序或不排好序，其实<strong>只用考察相邻两个数的后继关系</strong>是否正确。排好序后n 的后继应该是 n+1。</p><p><strong>每部操作的实质就是改变一些数的后继关系，并且每次操作最多会断开三个相连的位置，再重新加入三个相连的位置，因此我们会更改 3 个元素的后继关系</strong>，如下图：</p></li></ul><p><img src="https://mdpic.dreamgo.fun/img/image-20230227230909939.png" alt="image-20230227230909939"></p><p>也因此，最多会将 3 个错误的连接修正。每次迭代前，我们可以计算出当前有多少个后继关系是不正确的，假设一共有$tot$个后继关系不正确，则修复这些后继需要的最少步数为：<br>$$<br>\lceil \frac{tot}{3} \rceil = \lfloor \frac{tot+2}{3} \rfloor<br>$$<br>因此当前状态 $s$ 的估价函数可以设计成<br>$$<br>f(s) = \lceil \frac {tot }{3} \rceil = \lfloor \frac{tot+2}{3} \rfloor<br>$$<br>如果当前层数加上 $f(s)$ 大于迭代加深的层数上限，则直接从当前分支回溯。</p><h4 id="搜索顺序">搜索顺序</h4><ul class="lvl-0"><li class="lvl-2"><p>首先枚举移动长度<code>i</code></p></li><li class="lvl-2"><p>只考虑后移操作，对于每段书<code>i</code>枚举被移动的起始位置<code>l</code>和后移后的起始位置<code>k</code></p><p>如下图：</p></li></ul><p><img src="https://mdpic.dreamgo.fun/img/image-20230227225944040.png" alt="image-20230227225944040"></p><h3 id="优化">优化</h3><p>上述操作实际进行了优化，进行了排除等效冗余。可以发现，由于对称性，将前面一段后移就等价于将对应后面一段前移。因此我们排除冗余，只考虑搜索后移的情况即可。</p><h4 id="时间复杂度">时间复杂度</h4><p>理论上最多搜索 $560^4$ 个状态，使用 IDA * 后实际搜索的状态数量很少。</p><h5 id="C-3">C++</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 180. 排书</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N]; <span class="comment">// 书的编号</span></span><br><span class="line"><span class="type">int</span> w[<span class="number">5</span>][N]; <span class="comment">// 用于存储操作前当前的序列，恢复现场使用</span></span><br><span class="line"><span class="comment">// 这里需要理解为什么需要开5个，因为每层递归都需要恢复现场，且浅层要在深层后恢复</span></span><br><span class="line"><span class="comment">// 而最多五层，所以开5个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 估价函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tot = <span class="number">0</span>; <span class="comment">// 统计错误后继个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (q[i + <span class="number">1</span>] != q[i] + <span class="number">1</span>)</span><br><span class="line">            tot ++;</span><br><span class="line">    <span class="keyword">return</span> (tot + <span class="number">2</span>) / <span class="number">3</span>; <span class="comment">// 最小步数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查序列是否已经有序，即检查所有后继关系是否正确</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (q[i + <span class="number">1</span>] != q[i] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u: 当前迭代深度; depth: 迭代加深最大深度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">    <span class="comment">// IDA*剪枝</span></span><br><span class="line">    <span class="comment">// 若当前深度+未来估计步数&gt;深度限制，则立即从当前分支回溯</span></span><br><span class="line">    <span class="keyword">if</span> (u + <span class="built_in">f</span>() &gt; depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (u == depth &amp;&amp; <span class="built_in">check</span>()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 这里不要判断</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先枚举长度len</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; ++ len)</span><br><span class="line">        <span class="comment">// 然后枚举移动前左端点l</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l + len - <span class="number">1</span> &lt; n; ++ l)&#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>; <span class="comment">// 减1别忘了</span></span><br><span class="line">            <span class="comment">// 再枚举后移后插入的右端点k，</span></span><br><span class="line">            <span class="comment">// 剪枝之排除等效冗余，只考虑后移操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = r + <span class="number">1</span>; k &lt; n; ++ k)&#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(w[u], q, <span class="keyword">sizeof</span> q); <span class="comment">// 拷贝当前序列，用于恢复现场</span></span><br><span class="line">                <span class="comment">// 后移操作需要两步，首先将移动段落右端点后到后移插入的起始端点中间的部分前移</span></span><br><span class="line">                <span class="comment">// 然后再将移动段落插入</span></span><br><span class="line">                <span class="type">int</span> x, y; <span class="comment">// x使用记录移入数的位置，y始终记录要修改位置</span></span><br><span class="line">                <span class="comment">// 将当前移动段落后面的序列前移，即将上图中绿色部分移动到红色部分</span></span><br><span class="line">                <span class="comment">// 注意k是插入的右端点</span></span><br><span class="line">                <span class="keyword">for</span> (x = r + <span class="number">1</span>, y = l; x &lt;= k; x ++, y ++) q[y] = w[u][x];</span><br><span class="line">                <span class="comment">// 移动段落插入</span></span><br><span class="line">                <span class="keyword">for</span> (x = l; x &lt;= r; x ++, y ++) q[y] = w[u][x];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, depth)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 恢复现场</span></span><br><span class="line">                <span class="built_in">memcpy</span>(q, w[u], <span class="keyword">sizeof</span> q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 另一种枚举防止，直接枚举左端点，右端点，插入点（插入的右端点），更简单</span></span><br><span class="line">    <span class="comment">// for (int l = 0; l &lt; n; l ++ )</span></span><br><span class="line">    <span class="comment">//     for (int r = l; r &lt; n; r ++ )</span></span><br><span class="line">    <span class="comment">//         for (int k = r + 1; k &lt; n; k ++ )&#123;</span></span><br><span class="line">    <span class="comment">//             memcpy(w[u], q, sizeof q);</span></span><br><span class="line">    <span class="comment">//             int x, y;</span></span><br><span class="line">    <span class="comment">//             for (x = r + 1, y = l; x &lt;= k; x ++, y ++ ) q[y] = w[u][x];</span></span><br><span class="line">    <span class="comment">//             for (x = l; x &lt;= r; x ++, y ++ ) q[y] = w[u][x];</span></span><br><span class="line">    <span class="comment">//             if (dfs(u + 1, depth)) return true;</span></span><br><span class="line">    <span class="comment">//             memcpy(q, w[u], sizeof q);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 注意depth要从0开始，以处理原本就有序的特殊情况</span></span><br><span class="line">        <span class="keyword">while</span> (depth &lt; <span class="number">5</span> &amp;&amp; !<span class="built_in">dfs</span>(<span class="number">0</span>, depth)) depth ++;</span><br><span class="line">        <span class="keyword">if</span> (depth &gt;= <span class="number">5</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;5 or more&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 由于我们使用了迭代加深，所以depth恰好等于最少需要操作次数</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Python-3">Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 180. 排书</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 估价函数：不连续的数对数量除三，向上取整</span></span><br><span class="line">    f = <span class="keyword">lambda</span>: (<span class="built_in">sum</span>(<span class="built_in">int</span>(q[i + <span class="number">1</span>] != q[i] + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>)) + <span class="number">2</span>) // <span class="number">3</span></span><br><span class="line">    <span class="comment"># 检查是否排好</span></span><br><span class="line">    check = <span class="keyword">lambda</span>: <span class="built_in">all</span>(q[i + <span class="number">1</span>] == q[i] + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># check = lambda: all(arr[i] == i + 1 for i in range(n))</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">IDAstar</span>(<span class="params">level</span>):</span><br><span class="line">        <span class="comment"># IDA*剪枝</span></span><br><span class="line">        <span class="comment"># 若当前深度+未来估计步数&gt;深度限制，则立即从当前分支回溯</span></span><br><span class="line">        <span class="keyword">if</span> level + f() &gt; depth:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> level == depth <span class="keyword">and</span> check():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 枚举左端点，右端点，插入点（插入的右端点）</span></span><br><span class="line">        <span class="keyword">for</span> L <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> R <span class="keyword">in</span> <span class="built_in">range</span>(L, n):</span><br><span class="line">                <span class="keyword">for</span> K <span class="keyword">in</span> <span class="built_in">range</span>(R + <span class="number">1</span>, n):</span><br><span class="line">                    <span class="comment"># 后移操作</span></span><br><span class="line">                    <span class="comment"># 这里使用 Python 的切片来进行数组中 [L, R] 和 [R + 1, K] 两段的交换</span></span><br><span class="line">                    length, fst, sec = K - R, q[L:R+<span class="number">1</span>], q[R+<span class="number">1</span>:K+<span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># 注意这里切片范围</span></span><br><span class="line">                    q[L:L+length], q[L+length:K+<span class="number">1</span>] = sec, fst</span><br><span class="line">                    <span class="keyword">if</span> IDAstar(level + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="comment"># 恢复现场</span></span><br><span class="line">                    q[L:R+<span class="number">1</span>], q[R+<span class="number">1</span>:K+<span class="number">1</span>] = fst, sec</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">        n, depth = <span class="built_in">int</span>(<span class="built_in">input</span>()), <span class="number">0</span></span><br><span class="line">        q = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">        <span class="comment"># 迭代加深 + IDA* 优化</span></span><br><span class="line">        <span class="keyword">while</span> depth &lt; <span class="number">5</span> <span class="keyword">and</span> <span class="keyword">not</span> IDAstar(<span class="number">0</span>): depth += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5 or more&quot;</span> <span class="keyword">if</span> depth &gt;= <span class="number">5</span> <span class="keyword">else</span> depth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">     main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-181-回转游戏">2. <a href="https://www.acwing.com/problem/content/183/">AcWing 181. 回转游戏 </a></h3><h4 id="问题分析-2">问题分析</h4><p>本题采用 IDA* 算法，即迭代加深的 A* 算法。</p><p>在这题中，每次操作循环移动一格，不断的移动可能导致某些子树的深度很深，但是根据直觉，最优解的操作步数不会处于太深的位置，所以可以用迭代加深来做，再通过题目本身可以构造一个估价函数，即可以使用 IDA* 算法求解。</p><p>显然本题属于外部搜索（最小步数模型），需要搜索状态图，因此本题真的核心难点时状态存储和操作表示。</p><p>如何保证答案的字典序最小？</p><ul class="lvl-0"><li class="lvl-2"><p>由于最短操作步数是一定的，因此每一步枚举时先枚举字典序小的操作即可。</p></li></ul><h4 id="状态存储与操作表示——打表法">状态存储与操作表示——打表法</h4><p>可以使用编码的技巧实现存储与表示。</p><ul class="lvl-0"><li class="lvl-2"><p>位置编码：由于图为 # 形，为了将其存入数组中，我们可以对每个位置设定一个编号，进行手动打表。寻找元素值时只需查表即可。</p></li><li class="lvl-2"><p>操作编码：八种操作虽然操作对象不同，但是本质上都是进行循环移动——将头元素放到末尾，同时其他元素前移。同样，我们也可以给每个操作设定一个编号，并把其对应的位置操作用位置编号表示处理，并进行存储打表。使用操作时也只用查表即可。</p></li></ul><p>具体编号见下图：</p><p><img src="https://mdpic.dreamgo.fun/img/20230228122722.png" alt="61813_fe1427dc8a-image-20210321172207678"></p><h4 id="估价函数">估价函数</h4><p>为了得到估价函数，我们同样需要理解操作的实质影响，并利用贪心思想等得到理想情况下的最优解。</p><p>可以发现，我们的目标是中心区域，而<strong>每次拉动操作，只会改变中心区域内的一个值</strong>，其他都保持不变。为了最快使最中间的 8个格子里的数字相同，可以使用以下贪心策略：先找出这个区域内个数最多的数字，记个数为k，那么理想情况下（接下来每步操作都是有效的），至少还需要8-k步操作来去除其他数字。由此当前状态 $s$ 的估价函数可以设计成<br>$$<br>f(s) = 8 - k<br>$$</p><p>总结一下：</p><ul class="lvl-0"><li class="lvl-2"><p>统计中间 8 个方格中出现次数最多的数出现了多少次，记为 $k$ 次。</p></li><li class="lvl-2"><p>每次操作会从中间 8 个方格中移出一个数，再移入一个数，所以最多会减少一个不同的数。</p></li><li class="lvl-2"><p>因此估价函数可以设为 $8 - k$。</p></li></ul><h4 id="搜索框架">搜索框架</h4><p>整个框架是IDA*，从0开始枚举层数，然后在每一层搜索时计算估价函数</p><ul class="lvl-0"><li class="lvl-2"><p>如果当前层加上估价函数大于目前最优解则return</p></li><li class="lvl-2"><p>否则遍历8个操作进行状态转换，并递归搜索</p></li></ul><h4 id="剪枝-2">剪枝</h4><ul class="lvl-0"><li class="lvl-2"><p>排除等效冗余：记录上一次的操作，本次操作避免枚举上一次的逆操作。</p><p>可以发现相对的两个操作互为逆操作，两者作用相反。如果两者接连使用，效果会抵消，导致无效操作甚至死循环。为此，需要进行打表，记录每个操作对应的逆操作。当使用某操作后，下一个操作一定不能是其逆操作。</p><p>为了记录上一层的操作，使用传入形参last</p></li></ul><h4 id="时间复杂度-2">时间复杂度</h4><p>假设答案最少需要 $k$ 步，每次需要枚举 $7$ 种不同操作（除了上一步的逆操作），因此最坏情况下需要枚举 $7^k$ 种方案。但加入启发函数后，实际枚举到的状态数很少。</p><h4 id="C-4">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 181. 回转游戏</span></span><br><span class="line"><span class="comment">/* 打表——进行位置编码和操作编码</span></span><br><span class="line"><span class="comment">           A(0)  B(1)</span></span><br><span class="line"><span class="comment">           0     1</span></span><br><span class="line"><span class="comment">           2     3</span></span><br><span class="line"><span class="comment">H(7) 4  5  6  7  8  9  10 C(2)</span></span><br><span class="line"><span class="comment">           11    12</span></span><br><span class="line"><span class="comment">G(6) 13 14 15 16 17 18 19 D(3)</span></span><br><span class="line"><span class="comment">           20    21</span></span><br><span class="line"><span class="comment">           22    23</span></span><br><span class="line"><span class="comment">           F(5)  E(4)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N]; <span class="comment">// 存储当前状态图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8个方向操作对应的数据编号</span></span><br><span class="line"><span class="type">int</span> op[<span class="number">8</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">22</span>&#125;, </span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>&#125;,</span><br><span class="line">    &#123;<span class="number">23</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">22</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 存储每个操作的逆操作，用于排除等效冗余</span></span><br><span class="line"><span class="type">int</span> opposite[<span class="number">8</span>] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// 中心八个数据的位置编号</span></span><br><span class="line"><span class="type">int</span> center[<span class="number">8</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> path[<span class="number">100</span>]; <span class="comment">// path用于存储方案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 估价函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 由于只有三种数字1，2，3，所以可以统计每个数字的次数，然后取最大值</span></span><br><span class="line">    <span class="type">int</span> s[<span class="number">4</span>] =&#123;<span class="number">0</span>&#125;; <span class="comment">// 注意初始化为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// static int sum[4]; // 静态数组，不用每次重开浪费空间时间</span></span><br><span class="line">    <span class="comment">// memset(sum, 0, sizeof sum); // 需要每次memset重新赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++ i) s[q[center[i]]] ++; <span class="comment">// 计算1 2 3出现次数</span></span><br><span class="line">    <span class="type">int</span> maxv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++ i) maxv = <span class="built_in">max</span>(maxv, s[i]); <span class="comment">// 统计出现最多的次数，不用管具体是哪个数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> - maxv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行对应的操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 操作都有共性，最后都是将首部添加到尾部</span></span><br><span class="line">    <span class="type">int</span> t = q[op[x][<span class="number">0</span>]]; <span class="comment">// 取出头元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++ i) q[op[x][i]] = q[op[x][i + <span class="number">1</span>]]; <span class="comment">// 其他元素前移</span></span><br><span class="line">    <span class="comment">// 首部添加到尾部</span></span><br><span class="line">    q[op[x][<span class="number">6</span>]] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u: 当前迭代深度, depth: 迭代加深最大深度, last: 上一次操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> depth, <span class="type">int</span> last)</span></span>&#123;</span><br><span class="line">    <span class="comment">// IDA*剪枝</span></span><br><span class="line">    <span class="comment">// 若当前深度+未来估计步数&gt;深度限制，则立即从当前分支回溯</span></span><br><span class="line">    <span class="keyword">if</span> (u + <span class="built_in">f</span>() &gt; depth) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 估价函数为0，表明格子内数全部相同</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">f</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举八个操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++ i)</span><br><span class="line">        <span class="comment">// 剪枝之排除等效冗余，避免逆操作相互抵消</span></span><br><span class="line">        <span class="keyword">if</span> (opposite[i] != last)&#123; <span class="comment">// 由于初始时last=-1，所以不使用oppsite[last] != i的写法</span></span><br><span class="line">            <span class="built_in">operate</span>(i);</span><br><span class="line">            path[u] = i; <span class="comment">// 深度恰好对应操作数</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(u + <span class="number">1</span>, depth, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 回溯恢复现场</span></span><br><span class="line">            <span class="built_in">operate</span>(opposite[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[<span class="number">0</span>]), q[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 注意depth要从0开始，以处理原本就满足要求的特殊情况</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">dfs</span>(<span class="number">0</span>, depth, <span class="number">-1</span>)) depth ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!depth) <span class="built_in">printf</span>(<span class="string">&quot;No moves needed&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 迭代加深的depth能够记录最小步长</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;A&#x27;</span> + path[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d\n&quot;</span>, q[<span class="number">6</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Python-4">Python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 181. 回转游戏</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打表——进行位置编码和操作编码</span></span><br><span class="line"><span class="comment">#           A(0)  B(1)</span></span><br><span class="line"><span class="comment">#           0     1</span></span><br><span class="line"><span class="comment">#           2     3</span></span><br><span class="line"><span class="comment"># H(7) 4  5  6  7  8  9  10 C(2)</span></span><br><span class="line"><span class="comment">#           11    12</span></span><br><span class="line"><span class="comment"># G(6) 13 14 15 16 17 18 19 D(3)</span></span><br><span class="line"><span class="comment">#           20    21</span></span><br><span class="line"><span class="comment">#           22    23</span></span><br><span class="line"><span class="comment">#           F(5)  E(4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"><span class="keyword">import</span> copy </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    op = ((<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">22</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">23</span>),</span><br><span class="line">          (<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>), (<span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>),</span><br><span class="line">          (<span class="number">23</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>), (<span class="number">22</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">          (<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>))</span><br><span class="line">    </span><br><span class="line">    oppo, center = (<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>), (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>)</span><br><span class="line">    </span><br><span class="line">    log = &#123;i: ch <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="string">&quot;ABCDEFGH&quot;</span>)&#125; <span class="comment"># 用于输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 估价函数：中心元素数 - 中心区域频次最高的元素数量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">        cnt = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> center:</span><br><span class="line">            cnt[q[x]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span> - <span class="built_in">max</span>(cnt)</span><br><span class="line">    <span class="comment"># 需注意这里不能压行使用lambda函数，会超时</span></span><br><span class="line">    <span class="comment"># f = lambda: 8 - Counter(arr[x] for x in mid).most_common(1)[0][1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 额外递归函数速度会慢很多，直接在IDAstar中实现</span></span><br><span class="line">    <span class="comment"># 进行对应的操作</span></span><br><span class="line">    <span class="comment"># def helper(idx):</span></span><br><span class="line">    <span class="comment">#     temp = q[op[idx][0]]</span></span><br><span class="line">    <span class="comment">#     for i in range(6):</span></span><br><span class="line">    <span class="comment">#         q[op[idx][i]] = q[op[idx][i + 1]]</span></span><br><span class="line">    <span class="comment">#     q[op[idx][6]] = temp</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">IDAstar</span>(<span class="params">level, pre</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> q</span><br><span class="line">        assume = f()</span><br><span class="line">        <span class="comment"># 当前深度+未来估计步数&gt;深度限制，则立即从当前分支回溯</span></span><br><span class="line">        <span class="comment"># 找到答案返回 True</span></span><br><span class="line">        <span class="keyword">if</span> level + assume &gt; depth <span class="keyword">or</span> <span class="keyword">not</span> assume:</span><br><span class="line">            <span class="keyword">return</span> assume == <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举8个操作</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            <span class="keyword">if</span> pre != oppo[i]:</span><br><span class="line">                tmp = copy.copy(q) <span class="comment"># 用于恢复现场，比使用逆操作速度更快</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 进行对应的操作</span></span><br><span class="line">                <span class="comment"># helper(i)</span></span><br><span class="line">                temp = q[op[i][<span class="number">0</span>]]</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">                    q[op[i][j]] = q[op[i][j + <span class="number">1</span>]]</span><br><span class="line">                q[op[i][<span class="number">6</span>]] = temp</span><br><span class="line">                </span><br><span class="line">                path[level] = i <span class="comment"># 记录当前的操作</span></span><br><span class="line">                <span class="keyword">if</span> IDAstar(level + <span class="number">1</span>, i):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    </span><br><span class="line">                <span class="comment"># helper(oppo[i])</span></span><br><span class="line">                q = copy.copy(tmp) <span class="comment"># 恢复现场</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    path = [<span class="number">0</span>] * <span class="number">100</span></span><br><span class="line">    <span class="comment"># 输入和输出优化</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> stdin:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>: <span class="keyword">break</span></span><br><span class="line">        q, depth = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, line.split())), <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> IDAstar(<span class="number">0</span>, -<span class="number">1</span>): depth += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;&#x27;</span>.join(log[x] <span class="keyword">for</span> x <span class="keyword">in</span> path[:depth])&#125;</span>&quot;</span> <span class="keyword">if</span> depth </span><br><span class="line">        <span class="keyword">else</span> <span class="string">&quot;No moves needed&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(q[<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2.2 DFS之剪枝</title>
      <link href="/2023/02/26/2-2-2-DFS%E4%B9%8B%E5%89%AA%E6%9E%9D/"/>
      <url>/2023/02/26/2-2-2-DFS%E4%B9%8B%E5%89%AA%E6%9E%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="2-2-2-DFS之剪枝">2.2.2 DFS之剪枝</h1><p>深搜和宽搜都可以对应一颗搜索树，一般在叶子节点存的都是方案，提前判断不合法就是剪枝。</p><h2 id="剪枝优化的常用策略">剪枝优化的常用策略</h2><ol><li class="lvl-3"><p>优化搜索顺序大部分情况下，我们应该优先搜索分支较少的结点(子节点比较少)，即选择策略较少的结点。可通过从大到小排序等手段。这样结合剪枝就能搜索更少的点如背包问题，先选大物体，再选小物体。</p></li><li class="lvl-3"><p>排除等效冗余不要搜索重复状态。如组合型问题，不考虑顺序。可以规定一个特定顺序。又如分组问题，规定新开一组时，直接将待放的第一个放入，因为组和组之间没有差别。分析时着重思考有没有两种搜索方案会是本质相同的，产生冗余。</p></li><li class="lvl-3"><p>可行性剪枝不合法(不满足题目条件)则提前退出</p></li><li class="lvl-3"><p>最优性剪枝已经差于当前最优解则退出</p></li><li class="lvl-3"><p>记忆化搜索(DP)</p></li></ol><h2 id="1-AcWing-165-小猫爬山">1. <a href="https://www.acwing.com/problem/content/167/">AcWing 165. 小猫爬山</a></h2><h3 id="搜索问题的思考顺序">搜索问题的思考顺序</h3><p>先思考搜索顺序和决策操作，再尝试剪枝</p><p>本题和<a href="https://www.acwing.com/problem/content/1120/">AcWing 1118. 分成互质组</a>很相似，但本题由于对每组的总重量有限制，因而就不能采用贪心策略了——不具有最优子结构。需要额外进行总重量的判断。</p><p>因而本题只能够以枚举每只猫作为搜索顺序。从前往后枚举每只小猫应该放入哪个车上。</p><h3 id="决策操作">决策操作</h3><ol><li class="lvl-3"><p>依次尝试放入已开的车</p></li><li class="lvl-3"><p>放入一个新开的车注意这里新开一辆车是一种必备的方案，一定会被讨论。而<a href="https://www.acwing.com/problem/content/1120/">AcWing 1118. 分成互质组</a>中由于贪心策略，只有上一组全放满了，才会新开组。</p></li></ol><p>本题和<a href="https://www.acwing.com/problem/content/1120/">AcWing 1118. 分成互质组</a>区别在于，本题使用的是动态数组的思路，为每个数字找组。分成互质组这题使用的是静态数组的思路，为每个组找数字</p><p>注意为了整体代码的一致性，刚开始以开0辆车为起点，依次尝试已开的车时即为0，然后再在dfs中开一辆新车。而不是直接以一辆车为起点。</p><p>分析时可以画搜索树辅助思考。</p><h3 id="分析剪枝策略">分析剪枝策略</h3><ol><li class="lvl-3"><p>优化搜索顺序从重量大的猫开始搜索；将所有猫按重量从大到小排序。重量大的占用更多空间，后续需要讨论的分支情况更少。</p></li><li class="lvl-3"><p>可行性剪枝如果当前车中的重量加上新猫的重量大于最大载重，就剪枝</p></li><li class="lvl-3"><p>最优性剪枝如果车的数量已经大于等于当前最优解就剪枝</p></li></ol><h4 id="C">C++</h4><p>分组问题——动态数组的思路，为每个数字找组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS之剪枝——AcWing 165. 小猫爬山</span></span><br><span class="line"><span class="comment">// 分组问题——动态数组的思路，为每个数字找组</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> sum[N]; <span class="comment">// 每辆车当前载重量，最多n辆车</span></span><br><span class="line"><span class="type">int</span> ans = N; <span class="comment">// 注意初始赋值，求最小值，所以初始为最糟情况或无穷大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// u表示猫的下标，k表示将新开的车的下标，也是已开的车的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最优性剪枝</span></span><br><span class="line">    <span class="comment">// 如果车的数量已经大于等于当前最优解就剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (k &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 所有猫都放好了就返回</span></span><br><span class="line">    <span class="keyword">if</span> (u == n)&#123;</span><br><span class="line">        ans = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (sum[i] + w[u] &lt;= m)&#123; <span class="comment">// 可行性剪枝</span></span><br><span class="line">        <span class="comment">// 如果当前车中的重量加上新猫的重量大于最大载重，就剪枝(不执行搜索也可以认为是剪枝)</span></span><br><span class="line">            sum[i] += w[u];</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, k);</span><br><span class="line">            sum[i] -= w[u]; </span><br><span class="line">            <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新开一辆车</span></span><br><span class="line">    <span class="comment">// 注意每只猫都会将新开一辆车作为一种情况</span></span><br><span class="line">    <span class="comment">// 而不管前面的车是否放满（不能使用贪心策略）</span></span><br><span class="line">    sum[k] = w[u];</span><br><span class="line">    <span class="built_in">dfs</span>(u + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">    sum[k] = <span class="number">0</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剪枝优化——优化搜索顺序</span></span><br><span class="line">    <span class="comment">// 从重量大的猫开始搜索；将所有猫按重量排序</span></span><br><span class="line">    <span class="built_in">sort</span>(w, w + n , <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="comment">// sort(w, w + n);</span></span><br><span class="line">    <span class="comment">// reverse(w, w + n);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注意这里车数从0开始而不是1</span></span><br><span class="line">    <span class="comment">// 注意为了整体代码的一致性，刚开始以开0辆车为起点，依次尝试已开的车时即为0，然后再在dfs中开一辆新车。而不是直接以一辆车为起点。</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之剪枝——AcWing 165. 小猫爬山</span></span><br><span class="line"><span class="comment"># 分组问题——动态数组的思路，为每个数字找组</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> setrecursionlimit</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    setrecursionlimit(<span class="number">5000</span>)</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># 优化搜索顺序，先安排肥猫，后续的选择更少</span></span><br><span class="line">    w = <span class="built_in">sorted</span>([<span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># sorted() 函数对所有可迭代的对象进行排序操作</span></span><br><span class="line">    <span class="comment"># w = w.sort(reverse=True) </span></span><br><span class="line">    s = [<span class="number">0</span>] * n</span><br><span class="line">    res = n</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 回溯法，为每只猫猫找到合适的组</span></span><br><span class="line">    <span class="comment"># idx为当前的猫， s 为预设的空缆车，size 为当前开了几辆缆车</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">idx, size</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> res</span><br><span class="line">        <span class="comment"># 剪枝 and 刷新答案</span></span><br><span class="line">        <span class="keyword">if</span> size &gt;= res <span class="keyword">or</span> idx == n:</span><br><span class="line">            res = <span class="built_in">min</span>(res, size)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 尝试将当前猫猫放入前 size 个缆车中</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="comment"># 当前猫可以放到第 i 个缆车中</span></span><br><span class="line">            <span class="keyword">if</span> s[i] + w[idx] &lt;= m:</span><br><span class="line">                s[i] += w[idx]</span><br><span class="line">                backtrace(idx + <span class="number">1</span>, size)</span><br><span class="line">                s[i] -= w[idx]</span><br><span class="line">        <span class="comment"># 新开缆车，放入猫猫</span></span><br><span class="line">        s[size] += w[idx]</span><br><span class="line">        backtrace(idx + <span class="number">1</span>, size + <span class="number">1</span>)</span><br><span class="line">        s[size] -= w[idx]</span><br><span class="line">        </span><br><span class="line">    backtrace(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="2-AcWing-166-数独">2. <a href="https://www.acwing.com/problem/content/168/">AcWing 166. 数独</a></h2><p>数独问题的要求（限制）：</p><ul class="lvl-0"><li class="lvl-2"><p>每行都要有1~9</p></li><li class="lvl-2"><p>每列都要有1~9</p></li><li class="lvl-2"><p>每个九宫格都要有1~9</p></li></ul><h3 id="一-搜索顺序">一. 搜索顺序</h3><ol><li class="lvl-3"><p>每次随机选取一个空格子进行填写，直到填满。或按照输入的前后顺序开始逐一填写。</p></li><li class="lvl-3"><p>每个格子填写时要枚举选哪个数</p></li><li class="lvl-3"><p>dfs回溯搜索</p></li></ol><h3 id="决策方式">决策方式</h3><ol><li class="lvl-3"><p>尝试填写所有能填的数</p></li></ol><h3 id="剪枝优化">剪枝优化</h3><ol><li class="lvl-3"><p>优化搜索顺序选择备选方案最少的格子开始枚举，如果方案数相同则选择排在前面的格子</p></li></ol><p>提前打表求出每个二进制数对应的1的个数，即备选方案数<br>2. 排除等效冗余本题可能会存在先填A为n再填B为m和先填B为m再填A为n的等效冗余。但当我们按1中特定顺序枚举时则不存在。<br>3. 可行性剪枝不能与行、列、九宫格有重复</p><h3 id="细节部分处理——使用状态压缩-位运算优化">细节部分处理——使用状态压缩+位运算优化</h3><ol><li class="lvl-3"><p>如何表示当某一行、列、九宫格前的填写状态由于不能重复的填写相当于组合问题，所以可用01向量表示状态故可采用九位二进制数表示当前行、列、九宫格已使用了哪些数。使用0表示不能再使用(已被用过)，1表示可以使用。之所以这样是为了后面方便使用lowbit()运算</p></li><li class="lvl-3"><p>如何判断是否与行、列、九宫格有重复可以对行、列、九宫格使用与运算&amp;&amp;来确定可选择的数字。</p></li></ol><p>需注意，为了满足要求，每行、每列、每个九宫格的数字选取情况都用二进制表示了。但为了确定三个条件都满足的，就用&amp;&amp;取出同时为1的数。<br>3. 同时可以使用lowbit()运算依次取出所有1对应的要填的数。</p><h3 id="位运算">位运算</h3><ol><li class="lvl-3"><p>求n的二进制表示中第k位是几：<code>n &gt;&gt; k &amp;&amp; 1</code><br>先把第k位移到个位(<code>n &gt;&gt; k</code>)，然后取出( <code>n &gt;&gt; k &amp;&amp; 1</code>)</p></li><li class="lvl-3"><p>lowbit(x)操作，返回x最右端一位的1所代表的大小<code>x &amp; -x</code><br>负数的补码是原码取反加1<code>x &amp; -x == x &amp; (~x + 1)</code>。已知其补码相对于原码，最右端的1和其右面的0是不变的，其余全部取反，因而<code>x &amp; -x</code>后只剩下最右端的1了，其余全变成0。这是树状数组的一个基本操作。用途之一是用来求一个数x二进制表示中1的个数</p></li></ol><p>打表预处理优化-&gt;两个数组</p><ul class="lvl-0"><li class="lvl-2"><p>求出所有二进制数中有多少1，用于优化搜索顺序——分枝少的格子先填写</p></li><li class="lvl-2"><p>lowbit返回时最右端的1所代表的大小，第k位的代表$2^k$，需要快速求出k，因此建立一个对应的映射函数直接查询</p></li></ul><h4 id="C-2">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS之剪枝——AcWing 166. 数独</span></span><br><span class="line"><span class="comment">// 剪枝优化+位运算+打表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">9</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ones[M], map[M];</span><br><span class="line"><span class="comment">// ones用于求出每个二进制数有多少个1，用于优化搜索顺序——选取备选方案最少的格子先填写</span></span><br><span class="line"><span class="comment">// map用于存储2^k取对数为多少(即k)，因为lowbit求出的是2^k，而我们想要的是k</span></span><br><span class="line"><span class="type">int</span> row[N], col[N], cell[<span class="number">3</span>][<span class="number">3</span>]; <span class="comment">// 存储行、列、九宫格的状态</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>]; <span class="comment">// 使用字符串存储整个表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理表示行、列、九宫格状态的数组，都初始化为0~8位全1，即为(1 &lt;&lt; N) - 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">        row[i] = col[i] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// (1 &lt;&lt; N) - 1括号不可少，一定不要忘了位运算的运算级较低</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">            cell[i][j] = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新整个图、每行、每列、每个九宫格的当前填写状况，包括填写和恢复两方面</span></span><br><span class="line"><span class="comment">// 在(x,y)位置填写数字t，is_set表示两种选择——填写或恢复原状（删掉已填写的数）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> t, <span class="type">bool</span> is_set)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 注意变成字母</span></span><br><span class="line">    <span class="keyword">if</span> (is_set) str[x * N + y] = <span class="string">&#x27;1&#x27;</span> + t;</span><br><span class="line">    <span class="comment">// 注意这里必须这样写，因为maps中返回的t表示的位数，而在二进制中第0位表示的是1，第i位表示的是i+1，所以要填写的数字时t + &#x27;1&#x27;</span></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">else</span> str[x * N + y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// t的二进制位数所对应的值的大小(2^t)</span></span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span> &lt;&lt; t;</span><br><span class="line">    <span class="comment">// 如果删除操作就减去v，填写操作就加上v</span></span><br><span class="line">    <span class="keyword">if</span> (!is_set) v = -v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意填写后就不能再用了，为0，所以是减去</span></span><br><span class="line">    row[x] -= v;</span><br><span class="line">    col[y] -= v;</span><br><span class="line">    cell[x / <span class="number">3</span>][y / <span class="number">3</span>] -= v; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用lowbit位运算获取最右端一位的1所代表的大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用与运算求(x, y)位置能填哪些数，获取填写情况对应的二进制数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x / <span class="number">3</span>][y / <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 使用与运算找到行、列、九宫格来取可选择的数字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cnt) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minv = <span class="number">10</span>; <span class="comment">// 存储分支最小的空格的分支数，初值大于最遭情况</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="comment">// 求分支最小的空格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (str[i * N + j] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 获取填写情况对应的二进制数</span></span><br><span class="line">                <span class="type">int</span> state = <span class="built_in">get</span>(i, j); </span><br><span class="line">                <span class="keyword">if</span> (ones[state] &lt; minv)&#123;</span><br><span class="line">                    minv = ones[state];</span><br><span class="line">                    x = i, y = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> state = <span class="built_in">get</span>(x, y);</span><br><span class="line">    <span class="comment">// 枚举取出所有1，尝试所有能填的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = state; i; i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        <span class="type">int</span> t = map[<span class="built_in">lowbit</span>(i)]; <span class="comment">// 转换为对应的填写数字（取对数），注意查找使用的是lowbit(i)</span></span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">true</span>); <span class="comment">// 更新填写</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(cnt - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 本题只有唯一解， 为真直接返回，否则回溯时会删除获得的结果</span></span><br><span class="line">        <span class="built_in">draw</span>(x, y, t, <span class="literal">false</span>); <span class="comment">// 恢复原状</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++ i) map[<span class="number">1</span> &lt;&lt; i] = i;</span><br><span class="line">    <span class="comment">// 1 &lt;&lt; i为2^i的值</span></span><br><span class="line">    <span class="comment">// map用于存储2^k取对数为多少(即k)，因为lowbit求出的是2^k，而我们想要的是k</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打表法，预处理出每个数的二进制中有多少个1</span></span><br><span class="line">    <span class="comment">// 由于一共9个数，所以用0~8位表示即可，故枚举到(1 &lt;&lt; 9) - 1，即M</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++ j)</span><br><span class="line">            <span class="comment">// 位运算</span></span><br><span class="line">            <span class="comment">// 求n的二进制表示中第k位是0还是1，n &gt;&gt; k &amp;&amp; 1</span></span><br><span class="line">            ones[i] += i &gt;&gt; j &amp; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; str, str[<span class="number">0</span>] != <span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">// 预处理表示行、列、九宫格状态的数组，初始化为全1</span></span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cnt表示还有多少个空位</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 填入输入的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; N; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++ j, ++ k)</span><br><span class="line">                <span class="keyword">if</span> (str[k] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// 数字的大小</span></span><br><span class="line">                    <span class="comment">// 这里写成-&#x27;1&#x27;而不是-&#x27;0&#x27;是为了便于后面求二进制时使用</span></span><br><span class="line">                    <span class="comment">// 因为二进制时t表示位数，而填写的数字为t + &#x27;1&#x27;，所以这里统一格式</span></span><br><span class="line">                    <span class="type">int</span> t = str[k] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    <span class="comment">// 填入对应状态</span></span><br><span class="line">                    <span class="built_in">draw</span>(i, j, t, <span class="literal">true</span>);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ++ cnt;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(cnt);</span><br><span class="line">        <span class="comment">// 形参为还剩多少空格待填</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-2">python</h4><p>TLE超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之剪枝——AcWing 166. 数独</span></span><br><span class="line"><span class="comment"># 剪枝优化+位运算+打表</span></span><br><span class="line"><span class="comment"># python会超时</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">9</span></span><br><span class="line">    M = <span class="number">1</span> &lt;&lt; N</span><br><span class="line">    ones = [<span class="number">0</span>] * M</span><br><span class="line">    maps = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            ones[i] += i &gt;&gt; j &amp; <span class="number">1</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        maps[<span class="number">1</span> &lt;&lt; i] = i </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">x, y, t, is_set</span>):</span><br><span class="line">        <span class="keyword">if</span> is_set:</span><br><span class="line">            s[x * N + y] = <span class="built_in">str</span>(t)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s[x * N + y] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        </span><br><span class="line">        v = <span class="number">1</span> &lt;&lt; (t - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_set:</span><br><span class="line">            v = -v</span><br><span class="line">        row[x] -= v</span><br><span class="line">        col[y] -= v</span><br><span class="line">        cell[x // <span class="number">3</span>][y // <span class="number">3</span>] -= v</span><br><span class="line">        <span class="comment"># row[x] ^= v</span></span><br><span class="line">        <span class="comment"># col[y] ^= v</span></span><br><span class="line">        <span class="comment"># cell[x//3][y//3] ^= v</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowbit</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> row[x] &amp; col[y] &amp; cell[x // <span class="number">3</span>][y // <span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">cnt</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        minv = <span class="number">10</span></span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> s[i * N + j] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    state = get(i, j)</span><br><span class="line">                    <span class="keyword">if</span> ones[state] &lt; minv:</span><br><span class="line">                        minv = ones[state]</span><br><span class="line">                        x, y = i, j</span><br><span class="line">        state = get(x, y)</span><br><span class="line">        <span class="keyword">while</span> state:</span><br><span class="line">            t = maps[lowbit(state)] + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 这里的加1一定不要少</span></span><br><span class="line">            <span class="comment"># 因为maps中返回的t表示的位数，而在二进制中第0位表示的是1，第i位表示的是i+1，</span></span><br><span class="line">            <span class="comment"># 所以要填写的数字时t + 1</span></span><br><span class="line">            draw(x, y, t, <span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">if</span> backtrace(cnt - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            draw(x, y, t, <span class="literal">False</span>)</span><br><span class="line">            state -= lowbit(state)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        g = <span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> g == <span class="string">&quot;end&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        s = <span class="built_in">list</span>(g)</span><br><span class="line">        <span class="comment"># python中字符串是一个不可变类型，不能直接改变字符串中某个字符的值，</span></span><br><span class="line">        <span class="comment"># 需要另建一个存字符的列表处理字符</span></span><br><span class="line"></span><br><span class="line">        col = [(<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>] * N;</span><br><span class="line">        row = [(<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>] * N</span><br><span class="line">        cell = [[(<span class="number">1</span> &lt;&lt; N ) - <span class="number">1</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># cnt统计棋盘中空位个数</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                <span class="keyword">if</span> s[i * N + j] != <span class="string">&#x27;.&#x27;</span>: </span><br><span class="line">                    t = <span class="built_in">int</span>(s[i * N + j])</span><br><span class="line">                    draw(i, j, t, <span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">        backtrace(cnt)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(s))</span><br><span class="line">        <span class="comment"># 将列表中字符重新合并成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="3-AcWing-167-木棒">3. <a href="https://www.acwing.com/problem/content/169/">AcWing 167. 木棒</a></h2><h3 id="问题转化：">问题转化：</h3><p>本题相当于将若干个数分成多组，使每组总和相等，求解最多能分成多少组</p><p>这里一个值得注意的点是，将“每组总和最小为多少”转化为”最多能分成多少组“</p><h3 id="搜索顺序：">搜索顺序：</h3><ol><li class="lvl-3"><p>枚举木棒长度：从最小长度开始，枚举所有可能构成的木棒长度，第一个可行解即最优解</p></li><li class="lvl-3"><p>枚举选择小木棍拼接木棒：对于固定长度，依次枚举每根木棒有哪些小木棍构成（相当于一个组一个组的划分好）。小木棍的遍历寻找为组合型枚举</p><p>组内小木棍和木棒的顺序都可取任意特定顺序</p></li></ol><h3 id="剪枝优化：">剪枝优化：</h3><ol><li class="lvl-3"><p>可行性剪枝：</p><ul class="lvl-2"><li class="lvl-5">组成的木棒长度要是总长度的约数</li><li class="lvl-5">放入的小木棍长度加上木棒当前长度要小于固定长度</li></ul></li><li class="lvl-3"><p>优化搜索顺序：为了更少的备选方案，对小木棍按长度从大到小枚举枚举</p></li><li class="lvl-3"><p>排除等效冗余：</p><p>这里的冗余要考虑两个方面，首先是每个木棒内部的小木棍不存在顺序；其次木棍间也不存在顺序。前者使用组合数方式枚举即可，后者相对更复杂，因为其还涉及到方案的可行性问题。一般而言，一个小木棍无法用于当前木棒的构成并不能说明方案不可行，还需要继续枚举其他小木棍。但可以考虑一些特殊的情况，用当前小木棍的失败直接排除剩余的一部分小木棍乃至所有小木棍，减少枚举的小木棍数和木棒数。</p><ul class="lvl-2"><li class="lvl-5"><p>按照组合数方式枚举：规定特定顺序，每次从上次枚举的下一个开始处理——设置形参start</p></li><li class="lvl-5"><p>如果当前小木棍加到当前木棒中不可行，则直接略过后面所有长度相等的小木棍（小木棍间的冗余）</p></li><li class="lvl-5"><p>如果当前木棒放第一根小木棍u导致这根木棒凑不成length，则不用继续枚举，整个方案一定失败（前提逻辑是我们放入第一根小木棍后会尝试搜寻所有以其为第一部分的所有可能的方案。虽然到了最后我们把第一根小木棍u替换掉了可能会构成当前木棒，但后面其同样还会导致构不成木棒，继续枚举是木棒间的冗余）</p></li><li class="lvl-5"><p>如果当前木棒的最后一根小木棍u放在这里能构成了当前木棒，但搜寻后续方案失败了，则这不是因为这根小木棍导致的，且整个方案一定失败。换掉当前小木棍用于后续木棒也一样无法构成，不要再去尝试构建当前木棒的其他方案。（换句话说，已用于构成木棒的小木棍的在木棒间的使用顺序变化不会影响方案的可行性，不用做无意义的替换尝试，构成了的就不要变动了。同时如果当前小木棍构成了当前木棒，但递归搜索后续方案时失败了，就一定失败了，不要再去重新尝试构建当前木棒的其他方案，该层递归直接返回false）</p></li></ul><p>注意放在中间的小木棍是不一样的，其所在木棒无法构成可能是该小木棍和前面组成该木棒的某个小木棍不合适，可以重新组合，不一定就无法构成。</p></li></ol><h4 id="C-3">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS之剪枝——AcWing 167. 木棒</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> sum, length;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// u表示当前构建木棒序号（从0开始，已完全构成木棒数量=u），s表示当前木棒已构建的长度， start用于组合类枚举记录枚举位置</span></span><br><span class="line"><span class="comment">// 当u=sum/length时，实际已经构建好了所有木棒，直接返回</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> s, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u * length == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果当前木棒已被构建好，则直接返回对下一根木棒的构建</span></span><br><span class="line">    <span class="comment">// 注意这里start也要置为0</span></span><br><span class="line">    <span class="keyword">if</span> (s == length) <span class="keyword">return</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剪枝优化——排除等效冗余，按照组合数方式枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="comment">// 可行性剪枝——放入的小木棍长度加上木棒当前长度要小于固定长度</span></span><br><span class="line">        <span class="keyword">if</span> (st[i] || s + w[i] &gt; length) <span class="keyword">continue</span>;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 判断当前方案是否合法，进行递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(u, s + w[i], i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        st[i] = <span class="literal">false</span>; <span class="comment">// 回溯</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 当前小木棍失败后的剪枝优化</span></span><br><span class="line">        <span class="comment">// 剪枝优化——排除等效冗余，第一根小木棍不可行则一定不可行</span></span><br><span class="line">        <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 剪枝优化——排除等效冗余，第一根小木棍不可行则一定不可行</span></span><br><span class="line">        <span class="keyword">if</span> (s + w[i] == length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 剪枝优化——排除等效冗余，略过后面长度相等的小木棍</span></span><br><span class="line">        <span class="comment">// 能这样写也是因为先进行了排序</span></span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; w[j] == w[i]) j ++ ;</span><br><span class="line">        <span class="comment">// 注意因为for循环也会执行i++，所以这里随后要写i=j-1</span></span><br><span class="line">        i = j - <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n, n)&#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">            sum += w[i]; <span class="comment">// 总长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 剪枝——优化搜索顺序，长度从大到小枚举小木棍</span></span><br><span class="line">        <span class="built_in">sort</span>(w, w + n);</span><br><span class="line">        <span class="built_in">reverse</span>(w, w + n);</span><br><span class="line">        <span class="comment">// sort(w, w + n, greater&lt;int&gt;())</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 枚举木棒长度</span></span><br><span class="line">        length = w[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 不会死循环——最遭情况是所有小木棍共同构成一根木棒</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 可行性剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (sum % length == <span class="number">0</span> &amp;&amp; <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))&#123;</span><br><span class="line">                cout &lt;&lt; length &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            length ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-3">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之剪枝——AcWing 167. 木棒</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># cnt 表示当前在组合第几根棍子，从0开始，已完全构成木棒数量=cnt</span></span><br><span class="line">    <span class="comment"># cur 表示当前棍子的长度</span></span><br><span class="line">    <span class="comment"># st  表示当前从第几根小棍子开始枚举</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">cnt, cur, start</span>):</span><br><span class="line">        <span class="keyword">if</span> cnt * length == tot:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果当前木棒已被构建好，则直接返回对下一根木棒的构建</span></span><br><span class="line">        <span class="keyword">if</span> cur == length:</span><br><span class="line">            <span class="keyword">return</span> backtrace(cnt + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        fail = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">            <span class="comment"># 可行性剪枝，不能是用过的、组合后长度超过length的</span></span><br><span class="line">            <span class="comment"># 剪枝优化——排除等效冗余，失败后略过后面长度相等的小木棍</span></span><br><span class="line">            <span class="keyword">if</span> vis[i] <span class="keyword">or</span> w[i] == fail <span class="keyword">or</span> cur + w[i] &gt; length:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            vis[i] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> backtrace(cnt, cur + w[i], i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            vis[i] = <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 到这里说明当前方案失败，记录失败的棍子长度</span></span><br><span class="line">            fail = w[i]</span><br><span class="line">            <span class="comment"># 注意这里和C++写法的不同--&gt;无法通过直接修改i的值跳过循环，所以采用标记法</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 剪枝优化——排除等效冗余</span></span><br><span class="line">            <span class="comment"># 失败了，且当前小棍子是第一根或者最后一根，说明后续也找不到合法方案来安放它</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> cur + w[i] == length:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>(), )</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 优化搜索顺序，大的先搜</span></span><br><span class="line">        w = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())), reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># length恰从最长小木棒开始搜</span></span><br><span class="line">        tot, length = <span class="built_in">sum</span>(w), w[<span class="number">0</span>]</span><br><span class="line">        vis = [<span class="literal">False</span>] * n</span><br><span class="line">        <span class="keyword">while</span> length &lt;= tot:</span><br><span class="line">            <span class="comment"># 可行性剪枝</span></span><br><span class="line">            <span class="comment"># 枚举 [m, tot] 之间能被 tot 整除的单根原棍长度</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tot % length <span class="keyword">and</span> backtrace(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">                <span class="built_in">print</span>(length)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="4-AcWing-168-生日蛋糕">4. <a href="https://www.acwing.com/problem/content/170/">AcWing 168. 生日蛋糕</a></h2><h3 id="整体思路">整体思路</h3><p>问题为给定总体积$N\pi$和总层数$M$，且从上到下内层半径$R$和高$H$严格单调递增，求扣除底面的最小表面积</p><p>题目限制条件较复杂，由$1\leq M\leq20$推断可以使用暴搜</p><p>记最底层为 m, 很容易观察得出，表面积的公式为<br>$$<br>\begin{align}<br>S_{总} &amp; = S_{侧面} + S_{上表面} \\<br>&amp; = S_{所有层侧面积之和} + S_{第m层上表面积} \\<br>&amp; = \sum_{i=1}^{m}2\pi R_iH_i +\pi R_m^2 \\<br>\end{align}<br>$$<br>而体积为<br>$$<br>V_总 = \sum_{i=1}^{m}\pi R_i^2H_i<br>$$</p><p>由题意，$\pi$可以被忽略掉。</p><p>此外可以发现，利用单调递增的性质，每层高度和半径的最小值恰是该层的编号u（从最高层开始且初始编号为1）。</p><p>有了两个公式，还有题目给出的每层最小高度和最小半径，就知道可以用剪枝 + 暴搜来做这个题</p><p><img src="https://mdpic.dreamgo.fun/img/20210127003014554-1677381630809-2.png" alt="20210127003014554"></p><h3 id="搜索顺序">搜索顺序</h3><p>一层一层搜索半径和高</p><h3 id="剪枝优化-2">剪枝优化</h3><p><img src="https://mdpic.dreamgo.fun/img/image-20230226111159177.png" alt="image-20230226111159177"></p><h4 id="1-优化搜索顺序">1. 优化搜索顺序</h4><ol><li class="lvl-3"><p>层间：从下到上搜索，先搜体积和表面积大的，减少分支（由于蛋糕从下往上半径、高度依次递减，故体积也随之递减，由于总体积是确定不变的，所以我们从下往上枚举，最底层的蛋糕对应的分支数量最少。）</p></li><li class="lvl-3"><p>层内：先枚举半径再枚举高（半径相对于高来说对体积和表面积的影响较大，半径$R$在公式中是平方级别$R^2$，而高是线性级别$H$），且两者都从大到小枚举</p></li></ol><p>为此，在枚举每一层蛋糕时，需要记录当前层数$u$，当前蛋糕体积$v$和表面积$s$</p><h4 id="2-可行性剪枝">2. 可行性剪枝</h4><blockquote><p>结合单调性放缩，利用高度$h$和半径$r$的范围及体积的约束进行剪枝</p></blockquote><p>记总体积为$N$，当前层编号为$u$，高度为 $H_u$，半径为 $R_u$， 体积为 $V_u$，第 $m$ 层到第$u+1$层体积的累计值为 $V$</p><ol><li class="lvl-3"><p>对于$R_u$，当前为第$u$层， 第$u$层的体积为 $V_u$。$R_u$的下界应该是当前的层号$u$，R 的上界应该由两部分决定</p><ul class="lvl-2"><li class="lvl-5">$u+1$层半径$R_{u+1}$的约束：由于半径随层数单调递增，所以 $R_u \leq R_{u+1}-1$</li><li class="lvl-5">第$u$层体积 $V_u$的约束：由于第$u$层体积一定小于$N-min\sum_{i=1}^{u-1}V_i-V$，即 $V_u = R_u^2H_u \leq N-min\sum_{i=1}^{u-1}V_i-V$，又由于$H_u$同样有下界$u$，所以$R_u \leq \sqrt{\frac{n-min\sum_{i=1}^{u-1}V_i - V}{u}}$</li></ul></li></ol><p>取这两者的最小值, 故有以下等式成立</p><p>$$<br>u \leq R_u \leq min \lbrace R_{u+1}-1, \sqrt{\frac{n-min\sum_{i=1}^{u-1}V_i - V}{u}} \rbrace<br>$$</p><ol start="2"><li class="lvl-3"><p>对于第$u$层高度$H_u$的推导同理，$H_u$的下界为层号$u$，$H_u$的上界由也两部分决定</p><ul class="lvl-2"><li class="lvl-5">$u+1$层高度$H_{u+1}$的约束：$H_u \leq H_{u+1}-1$</li><li class="lvl-5">第$u$层体积 $V_u$的约束：由于第$u$层体积一定小于$N - min \sum_{i=1}^{u-1} V_i - V$，即 $V_u = R_u^2 H_u \leq N - min \sum_{i=1}^{u-1} V_i - V$，又由于$R_u$此时已被枚举确定，所以$H_u \leq \frac{n - min \sum_{i=1}^{u-1} V_i - V}{R^2_u}$</li></ul></li></ol><p>故同理可得出下列等式<br>$$<br>u \leq H_u \leq \min \lbrace H_{u+1} - 1, \frac{n-min\sum_{i=1}^{u-1}V_i - V}{R_u^2} \rbrace<br>$$</p><ol start="3"><li class="lvl-3"><p>体积的可行性剪枝：</p><p>记第 1 到第 $u$ 层体积的累计值为$V_{1-u}$，利用不等式$V + V_{1-u} = N$进行剪枝</p><p>首先需预处理前 $u$ 层体积$V_{1-u}$的最小值 $min\sum_{i=1}^{u}V_i$，此时有$R_i=H_i=u(i=1,\cdots,u)$，则<br>$$<br>V + min\sum_{i=1}^{u}V_i \leq n<br>$$</p></li></ol><h4 id="3-最优性剪枝">3. 最优性剪枝</h4><blockquote><p>放缩挖掘不等式关系，研究表面积的最优性剪枝</p></blockquote><p>记第 $m$ 层到第 $u+1$ 层表面积的累计值为 $S$, 第 1 到第 $u$ 层表面积的累计值为$S_{1-u}$</p><p>利用不等式$S + S_{1-u} &lt; ans$则有以下两种剪枝</p><ol><li class="lvl-3"><p>预处理出$S_{1-u}$的最小值为 $min\sum_{i=1}^{u-1}S_i$，此时有$R_i=H_i=u(i=1,\cdots,u)$，则<br>$$<br>S + \min\sum_{i=1}^{u} S_i &lt; ans<br>$$</p></li><li class="lvl-3"><p>利用放缩法推表面积公式和体积公式的关系，进一步剪枝</p><ul class="lvl-2"><li class="lvl-5">第一层到第$u$层的表面积有（不考虑 $\pi$）</li></ul></li></ol><p>$$<br>S_{1-u} = 2 \sum_{i=1}^{u} R_i H_i = \frac{2}{ R_{u+1} } \sum_{i=1}^{u} R_{u+1} R_i H_i &gt; \frac{2}{ R_{u+1} } \sum_{i=1}^{u} R_i^2 H_i<br>$$</p><ul class="lvl-0"><li class="lvl-2"><p>第一层到第 u 层的体积有</p></li></ul><p>$$<br>n - V = \sum_{i=1}^{u} R_i^2 H_i<br>$$</p><p>所以惊奇地发现<br>$$<br>S_{1-u} &gt;\frac{2(n-V)}{R_{u+1}}<br>$$<br>因此 $S_总 = S + S_{1-u}&gt;=S_{ans}$，即</p><p>$$<br>S + \frac{2(n-V)}{R_{u+1}} \geq S_{ans}, \ \ \  u=0时取等<br>$$</p><p>时就可以剪枝掉（最优性剪枝)</p><h4 id="C-4">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS之剪枝——AcWing 168. 生日蛋糕</span></span><br><span class="line"><span class="comment">// 数学推导放缩剪枝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">23</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="comment">// R，H存每一层半径和高度</span></span><br><span class="line"><span class="type">int</span> R[N], H[N];</span><br><span class="line"><span class="comment">// 前u层总体积，总侧面积的最小值，相当于前缀和</span></span><br><span class="line"><span class="type">int</span> minv[N], mins[N];</span><br><span class="line"><span class="type">int</span> ans = INF; <span class="comment">// 表面积答案</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// u表示当前这一层编号，v表示从m到u+1层的总体积（不含本层），s表示从m到u+1层的总共的面积（不含本层）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可行性剪枝——体积约束，已构建层的总体积+待构件层的最小总体积&lt;=总体积</span></span><br><span class="line">    <span class="keyword">if</span> (v + minv[u] &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 最优性剪枝——最优表面积，已构建层的表面积+待构件层的最小表面积&lt;当前最优表面积</span></span><br><span class="line">    <span class="keyword">if</span> (s + mins[u] &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 最优性剪枝——放缩不等式，已构建层的表面积+待构件层的最小表面积&lt;当前最优表面积</span></span><br><span class="line">    <span class="keyword">if</span> (s + <span class="number">2</span>*(n-v)/R[u+<span class="number">1</span>] &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// u = 0时表明已经枚举完毕，判断当前体积是否等于n，若是，更新表面积</span></span><br><span class="line">    <span class="keyword">if</span> (!u)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == v) ans = s;</span><br><span class="line">        <span class="comment">// 注意当前总体积不等于n是不要更新面积，但也要return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 剪枝之优化搜索顺序——先从大到小枚举半径，再从大到小枚举高度</span></span><br><span class="line">    <span class="comment">// 可行性剪枝——只在已确定的可行范围内枚举，范围由单调性放缩得到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="built_in">min</span>(R[u + <span class="number">1</span>] - <span class="number">1</span>, (<span class="type">int</span>)<span class="built_in">sqrt</span>((n - minv[u - <span class="number">1</span>] - v)/u)); r &gt;= u; -- r)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> h = <span class="built_in">min</span>(H[u + <span class="number">1</span>] - <span class="number">1</span>, (<span class="type">int</span>)(n - minv[u - <span class="number">1</span>] - v)/ (r * r)); h &gt;= u; -- h)&#123;</span><br><span class="line">            <span class="type">int</span> t = (u == m) ? r * r : <span class="number">0</span>; <span class="comment">// 若是最底层，则要把顶部面积加上</span></span><br><span class="line">            R[u] = r, H[u] = h;</span><br><span class="line">            <span class="built_in">dfs</span>(u - <span class="number">1</span>, v + r * r * h, s + <span class="number">2</span> * r * h + t);</span><br><span class="line">            <span class="comment">// 这里需注意，回溯时，R[u], H[u]可直接被覆盖，而并没有改变其他的属性，所以无需恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理求出前u层总体积，总侧面积的最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)&#123;</span><br><span class="line">        <span class="comment">// 最小时，R和H都等于对应层的编号</span></span><br><span class="line">        minv[i] = minv[i - <span class="number">1</span>] + i * i * i;</span><br><span class="line">        mins[i] = mins[i - <span class="number">1</span>] + <span class="number">2</span> * i * i;</span><br><span class="line">        <span class="comment">// 这里是一个小trick，minv[]和mins[]是按蛋糕从上到下计算的每一层的极限体积和侧面积</span></span><br><span class="line">        <span class="comment">// 但是最后搜索是从下到上搜索，这样min[]前缀和存的就是还未使用的体积和表面积了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哨兵，由于第m层R和H小于等于第m+1层R和H的值减1，所以这里将m+1层初始化为INF避免影响</span></span><br><span class="line">    R[m + <span class="number">1</span>] = H[m + <span class="number">1</span>] = INF;</span><br><span class="line">    <span class="built_in">dfs</span>(m, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans == INF) </span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-4">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之剪枝——AcWing 168. 生日蛋糕</span></span><br><span class="line"><span class="comment"># 数学推导放缩剪枝</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> inf</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    MAX_M = <span class="number">24</span></span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="comment"># 记录前 u 层的最小体积和侧面积</span></span><br><span class="line">    minv, mins = [<span class="number">0</span>] * MAX_M, [<span class="number">0</span>] * MAX_M</span><br><span class="line">    <span class="comment"># 记录搜索时每一层的半径和高度</span></span><br><span class="line">    R, H = [<span class="number">0</span>] * MAX_M, [<span class="number">0</span>] * MAX_M</span><br><span class="line">    res = inf</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 预处理边界以及剪枝用的数据</span></span><br><span class="line">    R[m + <span class="number">1</span>] = H[m + <span class="number">1</span>] = inf</span><br><span class="line">    <span class="comment"># 注意u从1到m</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        minv[i] = minv[i - <span class="number">1</span>] + i ** <span class="number">3</span></span><br><span class="line">        mins[i] = mins[i - <span class="number">1</span>] + <span class="number">2</span> * i ** <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 爆搜，剪了很多枝的爆搜</span></span><br><span class="line">    <span class="comment"># n 是体积，m 是层数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">u, v, s</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> res</span><br><span class="line">        <span class="keyword">if</span> v + minv[u] &gt; n: </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 推出的公式剪枝，筛掉一定不是答案的分支</span></span><br><span class="line">        <span class="keyword">if</span> s + <span class="built_in">max</span>(mins[u], <span class="number">2</span> * (n - v) // R[u + <span class="number">1</span>]) &gt;= res:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> u:</span><br><span class="line">            <span class="comment"># 蛋糕做好了且是当前最优解</span></span><br><span class="line">            <span class="keyword">if</span> v == n:</span><br><span class="line">                res = s</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        sr = <span class="built_in">min</span>(R[u + <span class="number">1</span>] - <span class="number">1</span>, <span class="built_in">int</span>(((n - minv[u - <span class="number">1</span>] - v) / u)**<span class="number">0.5</span>))</span><br><span class="line">        <span class="comment"># 优化搜索顺序，从最大的半径开始枚举</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(sr, u - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 当前是最底层时，不要忘了加上顶部的表面积</span></span><br><span class="line">            t = r * r <span class="keyword">if</span> u == m <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            sh = <span class="built_in">min</span>(H[u + <span class="number">1</span>] - <span class="number">1</span>, <span class="built_in">int</span>((n - minv[u - <span class="number">1</span>] - v) / (r * r)))</span><br><span class="line">            <span class="comment"># 优化搜索顺序，从最大的高度开始枚举</span></span><br><span class="line">            <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(sh, u - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                R[u], H[u] = r, h</span><br><span class="line">                <span class="comment"># 递归上一层</span></span><br><span class="line">                backtrace(u - <span class="number">1</span>, v + r * r * h, s + <span class="number">2</span> * r * h + t)</span><br><span class="line">    <span class="comment"># 从最底层开始向上枚举</span></span><br><span class="line">    backtrace(m, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 无解输出 0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">if</span> res == inf <span class="keyword">else</span> res)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2.1 DFS中的连通性和搜索顺序</title>
      <link href="/2023/02/23/2-2-1-DFS%E4%B8%AD%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E5%92%8C%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F/"/>
      <url>/2023/02/23/2-2-1-DFS%E4%B8%AD%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E5%92%8C%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="2-2-1-DFS中的连通性和搜索顺序">2.2.1 DFS中的连通性和搜索顺序</h1><h2 id="DFS">DFS</h2><p>优先往深度扩展，到叶节点再回溯。由于需要回溯，所以通过栈来实现。一般可以使用系统栈，直接递归搜索。</p><p>DFS代码简单，但存在爆栈风险。递归的层数越深，需要的栈空间越大。因而有深度限制，过深会有爆栈问题。栈空间默认为1M，要自己估计是否爆栈。如果爆栈的话需要用迭代的方式来写，将递归改成非递归。</p><p>两大类</p><ol><li class="lvl-3"><p>内部搜索-空间路径搜索：图的内部从一个点到另一个点的搜索过程，每个点是图的一个具体元素。即棋盘内部从一个棋子到另一个棋子。题目本身就提供具有多个节点的图，搜索的节点间的路径。</p></li><li class="lvl-3"><p>外部搜索-状态图搜索：把整体的当前状态看成一个点，搜索的过程是整体状态变化的过程，由一个状态变换成另一个状态。即棋盘整体布局的变化，从一种棋盘到另一种棋盘。将状态视为节点，初始时只有一个节点，图是在搜索时逐渐构成的，为状态图。</p></li></ol><p>判断回溯时是否需要恢复现场：先DFS再改变当前状态不需要恢复现场，先改变当前状态再DFS则需要恢复现场。</p><p>通常内部搜索时，当一个状态向另外一个状态拓展，这个状态是不会变化的。每个状态只搜索一次，所以不需要回溯。</p><p>每个节点只搜索一次，所以不能恢复现场，否则会重复搜索。</p><p>而外部搜索时通常需要回溯并恢复现场，因为当前状态在递归后会发生改变——因为我们搜索的就是状态转换图。状态本身是节点，要回溯到原节点就要恢复原状态。</p><p>不改变节点状态就不需要恢复现场，回溯时需要用到原节点的状态就要恢复现场。</p><p>不恢复现场意味着系统帮我们来维护结点状态, 恢复现场意味着自己来维护结点的状态自己维护结点状态指的是搜索一个结点 u 的所有邻接点 v 的时候, 点 u 是固定的, 不能变化的, 这是显而易见的</p><h2 id="一-DFS之连通性模型">一. DFS之连通性模型</h2><ol><li class="lvl-3"><p>Flood Fill 模型</p></li><li class="lvl-3"><p>图和树的遍历</p></li></ol><p>连通性模型判断能否连通可以用DFS，也可以用BFS。DFS代码更简单（使用系统栈），但不好处理最短路问题，BFS代码复杂些，但可以求出最短路问题。因此当只用判断连通性时，可以用DFS。</p><h3 id="1-AcWing-1112-迷宫">1. <a href="https://www.acwing.com/problem/content/1114/">AcWing 1112. 迷宫</a></h3><p>注意起点和终点是障碍物的话也无法到达</p><h3 id="C">C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS之连通性模型——AcWing 1112. 迷宫 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k, n;</span><br><span class="line"><span class="type">int</span> xa, ya, xb, yb;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归中，首先写出边界条件的判断</span></span><br><span class="line">    <span class="keyword">if</span> (g[x][y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 即使是终点和起点，如果为&#x27;#&#x27;，也是不连通</span></span><br><span class="line">    <span class="comment">// 注意判断可以放在递归后最开始时，也可以放在递归前。要结合题目初始和最终条件进行选择</span></span><br><span class="line">    <span class="comment">// 但不要两处都进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (x == xb &amp;&amp; y == yb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 不同于bfs，不要在递归后再写一遍，会重复</span></span><br><span class="line">    <span class="comment">// g[x][y] = &#x27;#&#x27;; // 直接通过改变状态进行标记</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有可移动方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="comment">// 判断不能递归的条件，注意不要和递归后最开始的判断重复</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="comment">// 进行递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(a, b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 递归时如何合理编写返回值、传递要求解的值是一个小难点</span></span><br><span class="line">        <span class="comment">// 这里不能直接return dfs(a, b)</span></span><br><span class="line">        <span class="comment">// 因为当dfs(a, b)为false时，还要继续枚举其他方向</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归后一定要判断是否需要回溯和恢复现场</span></span><br><span class="line">        <span class="comment">// 这里不需要恢复现场，属于内部搜索，拓展时不会改变当前状态</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (k --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;xa, &amp;ya, &amp;xb, &amp;yb);</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="comment">// 不同于bfs，dfs一定要定义形参，而不是使用全局变量，方便递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dfs</span>(xa, ya)) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="python">python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之连通性模型——AcWing 1112. 迷宫 </span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> setrecursionlimit</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    setrecursionlimit(<span class="number">5000</span>)</span><br><span class="line">    <span class="comment"># Python中系统栈默认的递归深度限制为1000，</span></span><br><span class="line">    <span class="comment"># 一般最大可修改到10^5，再大的话可能就需要手写栈等策略</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= n <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> arr[x][y] == <span class="string">&#x27;#&#x27;</span> <span class="keyword">or</span> vis[x][y]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> (x, y) == (ex, ey):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        vis[x][y] = <span class="literal">True</span> <span class="comment"># 更新判重</span></span><br><span class="line">        <span class="keyword">return</span> dfs(x - <span class="number">1</span>, y) <span class="keyword">or</span> dfs(x + <span class="number">1</span>, y) <span class="keyword">or</span> dfs(x, y - <span class="number">1</span>) <span class="keyword">or</span> dfs(x, y + <span class="number">1</span>) <span class="comment"># 遍历子节点，这里不需要回溯恢复现场所以可以直接这么xie</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        arr = [<span class="built_in">input</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        vis = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        sx, sy, ex, ey = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;YES&quot;</span> <span class="keyword">if</span> dfs(sx, sy) <span class="keyword">else</span> <span class="string">&quot;NO&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-1113-红与黑">2. <a href="https://www.acwing.com/problem/content/1115/">AcWing 1113. 红与黑</a></h3><h4 id="C-2">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS之连通性模型——AcWing 1113. 红与黑</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 只算当前点的话个数为1，不是0</span></span><br><span class="line">    </span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 这里递归进入后再进行标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="comment">// 判断能否进入递归</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (g[a][b] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意dfs中一个注意点是如何在递归中统计要求的量</span></span><br><span class="line">        <span class="comment">// 这里的思路是只统计以当前点为起点的数量，并进行前传，而不用把前面的个数传到后面</span></span><br><span class="line">        <span class="comment">// 这是由于这里求的是所有方案数，前面的点有多种选择，不方便后传（递归时还没统计完），需要递归后才能确定方案数</span></span><br><span class="line">        <span class="comment">// 所以采用递归后前传的方式，分解成子问题，每次递归后统计当前点为起点的方案数</span></span><br><span class="line">        cnt += <span class="built_in">dfs</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// n || m：读入两个零时结束</span></span><br><span class="line">    <span class="comment">// 注意这里先输入列数，再输入行数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n), n || m)&#123;</span><br><span class="line">        <span class="type">int</span> sx, sy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">                    sx = i, sy = j;</span><br><span class="line">                    <span class="comment">// 找到起始点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span> ,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dfs</span>(sx, sy));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-2">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之连通性模型——AcWing 1113. 红与黑</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> setrecursionlimit</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    setrecursionlimit(<span class="number">5000</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= n <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> y &gt;= m <span class="keyword">or</span> vis[x][y]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> g[x][y] == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        vis[x][y] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dfs(x - <span class="number">1</span>, y) + dfs(x + <span class="number">1</span>, y) + dfs(x, y - <span class="number">1</span>) + dfs(x, y + <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意不要忘了加1</span></span><br><span class="line">        <span class="comment"># 注意不需要回溯时才能用这种尾递归</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 注意读取输入的方法</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        <span class="comment"># 注意审题，行在先还是列在先</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (n + m):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        g = [<span class="built_in">list</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        vis = [[<span class="literal">False</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 使用next获得起点位置</span></span><br><span class="line">        <span class="comment"># next()方法从迭代器中检索下一个项目</span></span><br><span class="line">        sx, sy = <span class="built_in">next</span>((x, y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">if</span> g[x][y] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(dfs(sx, sy))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="二-DFS之搜索顺序">二. DFS之搜索顺序</h2><p>外部搜索即通常所说的暴搜问题，需要想一个搜索顺序，使所有方案全部枚举到。</p><p>问题可以询问方案数、最优解等。</p><p>要想到用怎样的顺序才能不重复、不遗漏地枚举到所有方案/状态。搜索的核心即搜索顺序。</p><p>思考时可以结合深度搜索树辅助分析</p><h3 id="1-AcWing-1116-马走日">1. <a href="https://www.acwing.com/problem/content/1118/">AcWing 1116. 马走日</a></h3><p>这里枚举表示马移动的八个方向即可</p><p>日字形移动：</p><p>dx = {-2, -1, 1, 2, -2, -1, 1, 2}<br>dy = {-1, -2, -2 ,-1, 1, 2, 2, 1}</p><p>注意使用相对变化量，枚举八个位置</p><p>因为马的位置状态发生了改变，所以回溯时需要恢复现场。</p><p>每一种走法都对应于从根节点到叶子节点的遍历过程，不同的分支代表不同的方案。搜索树上的遍历过程和方案一一对应。</p><p>外部搜索是状态图的搜索，每个状态都对应于一个节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS之搜索顺序——AcWing 1116. 马走日</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="comment">// 注意由于这里我们需要恢复现场，所以递归完后st也会恢复最初状态，不用每次memset重新初始化</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="comment">// 统计方案数的方法多种</span></span><br><span class="line"><span class="comment">// 一种是使用全局变量</span></span><br><span class="line"><span class="comment">// 一种是作为返回值，dfs内使用cnt，并在return时返回</span></span><br><span class="line"><span class="comment">// 一种是作为形参记录当前节点信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举表示左右所有方向</span></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span> ,<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否满足边界条件</span></span><br><span class="line">    <span class="comment">// 注意这里为了便于判断，引入的辅助变量cnt，用于记录已遍历的节点个数</span></span><br><span class="line">    <span class="comment">// 之所以要记录是因为每个搜索方案都对应于一个从根节点到叶子节点的走法，必须判断何时到达叶子节点</span></span><br><span class="line">    <span class="comment">// 参数是进行前传(作为返回值)，还是后传(作为形参)，还是使用全局变量：</span></span><br><span class="line">    <span class="comment">// 这里cnt在前面就已经确定，与前面的递归有关，且用于当前状态，所以后传</span></span><br><span class="line">    <span class="comment">// 前传一般用于可分解为无后效的子问题时，且必须要递归返回后，当前状态的量才能确定</span></span><br><span class="line">    <span class="comment">// 全局变量用于记录路径总数等</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>  (cnt == n * m)&#123;</span><br><span class="line">        ans ++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    st[x][y] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 枚举所有可移动方向</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(a, b, cnt + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 注意形参是要变化的</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     st[x][y] = <span class="literal">false</span>;</span><br><span class="line">     <span class="comment">// 注意回溯后恢复现场</span></span><br><span class="line">     <span class="comment">// 注意题目没有确定的终点，而是求遍历所有点的路径</span></span><br><span class="line">     <span class="comment">// 因此每个方格中的点并不对应于搜索状态图中的节点，每个状态节点对应于一个从根节点到叶节点的走法/方案</span></span><br><span class="line">     <span class="comment">// 因此不同方案时方格是可以被重复走的，且需要恢复状态。而标记数组的作用在于每个方案内部时方格只能走一次</span></span><br><span class="line">     <span class="comment">// 也因为没有设定终点，所以需要自己判断是否到了叶子节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x, &amp;y);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="comment">// 可以不写，因为回溯时会恢复现场</span></span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 遍历的方格数初始时是1</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-3">python</h4><p>注意python过不了本题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> setrecursionlimit</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    setrecursionlimit(<span class="number">5000</span>)</span><br><span class="line">    dir_x = [-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    dir_y = [-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用形参后向传播遍历节点数信息，方便判断是否达到叶子节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y, cnt</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 这里使用前向传参（传返回值）来记录路径总数结果</span></span><br><span class="line">        way = <span class="number">0</span></span><br><span class="line">        vis[x][y] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> <span class="built_in">zip</span>(dir_x, dir_y):</span><br><span class="line">            nx, ny = x + dx, y + dy</span><br><span class="line">            <span class="comment"># 注意这里python关系不等式写法</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m <span class="keyword">and</span> <span class="keyword">not</span> vis[nx][ny]:</span><br><span class="line">                way += dfs(nx, ny, cnt - <span class="number">1</span>)</span><br><span class="line">        vis[x][y] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> way</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">        n, m, sx, sy = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        vis = [[<span class="literal">False</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="built_in">print</span>(dfs(sx, sy, n * m - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-1117-单词接龙">2. <a href="https://www.acwing.com/problem/content/1119/">AcWing 1117. 单词接龙</a></h3><p>搜索顺序：把开头字母作为根节点，首先枚举以其开头的单词，然后针对每个单词枚举可以接在其后面的单词，直到找不到为止。</p><p>由此，第一层和后续层的搜索操作是不同的，为了方便，我们先直接枚举第一层，并当作森林分别进行DFS</p><p>这里难点在于：</p><ul class="lvl-0"><li class="lvl-2"><p>如何判断两个单词能否接在一起，并记录其重合长度</p></li></ul><p>显然也需要进行枚举。这里为了方便截取子串，可以使用string的substr函数。</p><p>注意这里的贪心思想！为了使长度最长，重合的要最小即可。</p><p>为了记录每两个单词的最小重合长度，可以建立一个二维数组事先记录。而判断能否相接的过程要在DFS前预处理好</p><h4 id="C-3">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS之搜索顺序——AcWing 1117. 单词接龙 </span></span><br><span class="line"><span class="comment">// 多入口DFS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string word[N]; <span class="comment">// 存储所有单词</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 图不是直接存在的，而需要构建和存储</span></span><br><span class="line"><span class="comment">//为了使长度最长，重合的要最小即可。因此邻接矩阵g[N][N]除了存储两个单词是否有边，还要具体表示前一单词前缀和后一单词后缀的最小重合长度</span></span><br><span class="line"><span class="type">int</span> used[N]; <span class="comment">// 记录每个单词使用次数</span></span><br><span class="line"><span class="type">int</span> ans; <span class="comment">// 全局变量记录结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入接龙字符串和拼接的最后一个单词的索引</span></span><br><span class="line"><span class="comment">// 传入拼接的最后一个单词的索引是为了方便进行下一个单词的遍历搜寻</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string dragon, <span class="type">int</span> last)</span></span>&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>((<span class="type">int</span>)dragon.<span class="built_in">size</span>(), ans);</span><br><span class="line">    <span class="comment">// 注意size()要强制转换为int，否则类型不对</span></span><br><span class="line">    <span class="comment">// 更新字符串长度</span></span><br><span class="line"></span><br><span class="line">    used[last] ++; <span class="comment">// 标记：使用次数加1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有单词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (g[last][i] &amp;&amp; used[i] &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(dragon + word[i].<span class="built_in">substr</span>(g[last][i]), i);</span><br><span class="line">            <span class="comment">// 对于重复的问题，不用进行预先分割当复杂的操作</span></span><br><span class="line">            <span class="comment">// 记录长度后直接用substr对应截取即可</span></span><br><span class="line">    used[last] --;</span><br><span class="line">    <span class="comment">// 回溯时恢复现场</span></span><br><span class="line">    <span class="comment">// 同样不要放在for循环内，循环内仍是在对下一层进行枚举，不需要恢复当前状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; word[i];</span><br><span class="line">    <span class="type">char</span> start;</span><br><span class="line">    cin &gt;&gt; start;</span><br><span class="line">    <span class="comment">// scanf(&quot;\n%c&quot;, &amp;start);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有单词，判断两两之间是否相接，并记录最小重合长度</span></span><br><span class="line">    <span class="comment">// 这里注意由于每个单词可以使用两次，所以可以自己和自己相接</span></span><br><span class="line">    <span class="comment">// 如果限制了不能自己和自己相接，遍历时要把自己挖出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)&#123;</span><br><span class="line">            string a = word[i], b = word[j];</span><br><span class="line">            <span class="comment">// 分别从前一个单词的结尾和后一个单词的开头进行枚举</span></span><br><span class="line">            <span class="comment">// 注意使用string的substr函数直接截取字串，简化操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; <span class="built_in">min</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()); ++ k) </span><br><span class="line">            <span class="comment">// 注意题意限制：重合长度必须大于等于1，且严格小于两个串的长度</span></span><br><span class="line">                <span class="comment">// k &lt; min(a.size(), b.size())即可限制严格小于两个串的长度</span></span><br><span class="line">                <span class="keyword">if</span> (a.<span class="built_in">substr</span>(a.<span class="built_in">size</span>() - k, k) == b.<span class="built_in">substr</span>(<span class="number">0</span>, k))&#123;</span><br><span class="line">                    g[i][j] = k;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (word[i][<span class="number">0</span>] == start)</span><br><span class="line">            <span class="built_in">dfs</span>(word[i], i); <span class="comment">// 传入单词和其索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索顺序：把开头字母作为根节点，首先枚举以其开头的单词，然后针对每个单词枚举可以接在其后面的单词，直到找不到为止。</span></span><br><span class="line">    <span class="comment">// 由于第一层和后续层的搜索操作是不同的，为了方便，我们先直接枚举第一层，并当作森林分别进行dfs</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-4">python</h4><h5 id="多入口DFS">多入口DFS</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之搜索顺序——AcWing 1117. 单词接龙 </span></span><br><span class="line"><span class="comment"># 多入口DFS</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> setrecursionlimit</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    setrecursionlimit(<span class="number">5000</span>)</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    g = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    word = [<span class="built_in">input</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    start = <span class="built_in">input</span>()</span><br><span class="line">    used = [<span class="number">0</span>] * n</span><br><span class="line">    ans = <span class="number">0</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">l, last</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> ans </span><br><span class="line">        <span class="comment"># nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, l)</span><br><span class="line">        </span><br><span class="line">        used[last] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> g[last][i] <span class="keyword">and</span> (used[i] &lt; <span class="number">2</span>):</span><br><span class="line">                dfs(l + <span class="built_in">len</span>(word[i]) - g[last][i], i)</span><br><span class="line">        used[last] -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            w1, w2 = word[i], word[j]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">min</span>(<span class="built_in">len</span>(w1), <span class="built_in">len</span>(w2))):</span><br><span class="line">                <span class="comment"># if word[i][len(w1) - k:] == word[j][0:k]:</span></span><br><span class="line">                <span class="keyword">if</span> word[i].endswith(word[j][:k]):</span><br><span class="line">                    g[i][j] = k</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 多入口，根节点确定，但需要遍历其所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> word[i][<span class="number">0</span>] == start:</span><br><span class="line">            dfs(<span class="built_in">len</span>(word[i]), i)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h5 id="单入口DFS">单入口DFS</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> setrecursionlimit</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    setrecursionlimit(<span class="number">10000</span>)</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    used = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    word = [<span class="built_in">input</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># 加个哨兵为让 head 直接搜</span></span><br><span class="line">    <span class="comment"># 构造出了符合子节点条件的根节点，使其能当作普通节点处理</span></span><br><span class="line">    head = <span class="string">&#x27;#&#x27;</span> + <span class="built_in">input</span>()</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dragon 为当前接龙得到的字符串，idx 是上一层 DFS 用到了哪个编号的字符串</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">dragon, last</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> ans</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">len</span>(dragon))</span><br><span class="line">        </span><br><span class="line">        used[last] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(word):</span><br><span class="line">            <span class="comment"># 取 dragon 和 p 中的长度最小值做上界</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">min</span>(<span class="built_in">len</span>(dragon), <span class="built_in">len</span>(p))):</span><br><span class="line">                <span class="comment"># p 的前缀必须是 dragon 的后缀，且之前的使用次数少于两次</span></span><br><span class="line">                <span class="comment"># 直接使用endswith判断字符串是否以指定字符或子字符串结尾。</span></span><br><span class="line">                <span class="keyword">if</span> used[i] &lt; <span class="number">2</span> <span class="keyword">and</span> dragon.endswith(p[:j]):</span><br><span class="line">                    dfs(dragon + p[j:], i)</span><br><span class="line">        used[last] -= <span class="number">1</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># head 的 idx 取 n，不影响其他元素</span></span><br><span class="line">    dfs(head, n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 减去 &#x27;#&#x27; 贡献的长度</span></span><br><span class="line">    <span class="built_in">print</span>(ans - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="3-AcWing-1118-分成互质组">3. <a href="https://www.acwing.com/problem/content/1120/">AcWing 1118. 分成互质组</a></h3><p>DFS的一大难点是建图的过程，把问题转化为图论搜索问题。本题的问题是给定n个正整数，将它们分组，使得每组中任意两个数互质。</p><p>最初做题时你可能想不到要建图进行搜索，这说明你建图的思想还不足。我们可以如下建图：如果两个数不互质，两者间就有边。要将相互间没有边的分到一组。</p><p>互质的判断——最大公约数为1。</p><p>这有些类似于求最大团的问题。<em>最大团问题</em>（Maximum Clique Problem, MCP）是图论中一个经典的组合优化问题，也是一类NP完全问题。最大团问题又称为最大<a href="https://baike.baidu.com/item/%E7%8B%AC%E7%AB%8B%E9%9B%86?fromModule=lemma_inlink">独立集</a>问题（Maximum Independent Set Problem）。</p><p>暴搜题很多是NP完全问题，否则会考贪心或dp</p><p>核心问题是搜索顺序问题，如何把所有情况全部枚举到，求到最优方案。本质是最优化问题。</p><p>采用暴搜——决策树模型的策略，进行DFS。由于数和组都是变的，需要以其中一个为主顺序进行枚举决策。</p><p>一个组一个组的枚举，看每个组应该选谁。而对于每个组，分别枚举其每个可能放入的数。注意由于所有数都是事先知道的，所以每个组处理完后后面就不会再进行增加和改变。</p><p>每种方案都对应一个分支，每次决策后向下递归一层，直到将所有数分完后结束，并更新最小值</p><p>注意搜寻顺序：这里可以由两种搜寻顺序：</p><ol><li class="lvl-3"><p>对每个数搜寻能在哪个组中</p></li><li class="lvl-3"><p>对每个现有组搜寻所有能放入的数，一个组一个组的枚举</p></li></ol><p>这里如果对每个数进行搜索会比较麻烦，数是变的，组数也是变的，最好能确定一个相对变化不大的（一个数只对应一个组，一个组则对应多个数，枚举组的话总层数少）。这里枚举组，每次把所有能放入的数都放入当前组，然后就不再往当前组的状态进行改变了，而是新开其他组，直至所有数都入组。即每次只对最后一个组进行放入操作。这恰是一种贪心策略，最后能保证组数最少。</p><p>所有决策方式：</p><ol><li class="lvl-3"><p>把某个数加到最后一组中（规定顺序是一个组一个组枚举，加入组时不是任意的，而是要加到最后一组，使决策更少）</p></li><li class="lvl-3"><p>新开一个组</p></li></ol><p>考虑搜索顺序/决策方式的一个原则是保证让搜索空间尽量小一些，即分支数量少一些。</p><p>第一个剪枝优化：</p><p>当可以进行第一个操作时就不用进行第二个操作，新开一个组，可以用扰动证明。这可视为了贪心的策略或剪枝优化的策略。</p><p>第二个剪枝优化：</p><p>进行第一个操作时也可以进行优化。将数放入组中是一个组合问题，不用考虑顺序。这样能够避免组内冗余（排列变组合）</p><p>如何实现组合类型递归搜索呢——为了保证不重复搜索，人为规定一个特定搜索顺序即可，如按下标从小到大——需要传入一个形参，记录当前的搜索位置。</p><p>第三个剪枝优化</p><p>同时由于本题求的是最小值，可以使用最优性剪枝优化，但结果已经大于当前最优解则剪枝。</p><p>dfs分组问题有两种做法，第一种就是：枚举每个数要分到哪一组，这种的话没有等效冗余，第二种：枚举哪一组应该放进那些数，这种需要优化等效冗余，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS之搜索顺序——AcWing 1118. 分成互质组</span></span><br><span class="line"><span class="comment">// 静态数组的思路，为每个组找数字</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> group[N][N]; <span class="comment">// 每组分别记录下来，最坏情况下每个节点一组</span></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> ans = N; <span class="comment">// 最坏情况下每个节点一组</span></span><br><span class="line"><span class="comment">// 注意由于ans要取最小值，所以初始时要赋无穷大或大于理论上的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧几里得算法求最大公约数</span></span><br><span class="line"><span class="comment">// 最大公约数等于1说明互质</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数是否能放入当前的组中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> group[], <span class="type">int</span> gc, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 枚举所有已放入组中的数，判断是否互质</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; gc; ++ j)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(p[group[j]], p[i]) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意形参的设置</span></span><br><span class="line"><span class="comment">// g记录当前的总组数，也恰好是当前最后一个组的编号</span></span><br><span class="line"><span class="comment">// gc记录当前最后一个组已放入的数的个数</span></span><br><span class="line"><span class="comment">// tc表示当前已分配好的数的个数，用于判断是否结束</span></span><br><span class="line"><span class="comment">// start表示还未分配的数中第一个数的下标</span></span><br><span class="line"><span class="comment">// 这里需要注意要按照组合类型的搜索方式，即认为规定一个特定搜索顺序，这里按照下标顺序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> g, <span class="type">int</span> gc, <span class="type">int</span> tc, <span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 最优性剪枝，当结果大于等于目前的最优解时，一定不是最优解，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tc == n)&#123;</span><br><span class="line">        ans = g;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 由于前面的判断，所以现在一定小于目前的解，进行更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个标记，用于判断是否需要新开一个组</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 新开一个组的条件：枚举剩余所有数后都不存在新的点可以放入当前组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从未分配的数中第一个数开始枚举，分别尝试放入剩余的数，进行递归搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!st[i] &amp;&amp; <span class="built_in">check</span>(group[g], gc, i))&#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>; <span class="comment">// 标记已分配好</span></span><br><span class="line">            group[g][gc] = i; <span class="comment">// 存入数的索引编号</span></span><br><span class="line">            <span class="comment">// 进行递归</span></span><br><span class="line">            <span class="built_in">dfs</span>(g, gc + <span class="number">1</span>, tc + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 注意形参的对应变化</span></span><br><span class="line"></span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 回溯时恢复现场，注意这里改变的是被枚举的数的状态，所以在循环内部恢复</span></span><br><span class="line">            <span class="comment">// group[g][gc]由于会直接被覆盖，不用恢复</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 剪枝——组合问题规定特定顺序</span></span><br><span class="line">            <span class="keyword">if</span> (gc == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 因为开一个新组的前提条件是每个数都不能放到旧组中了，</span></span><br><span class="line">            <span class="comment">// 所以剩下的第一个数一定会放到某个新组中，而组与组之间是没有顺序的区别的</span></span><br><span class="line">            <span class="comment">// 比如对于数据3，7，6，14来说，第一次搜索结束后&#123;3, 14&#125;, &#123;7，6&#125;被找到，</span></span><br><span class="line">            <span class="comment">// 后续是不需要找&#123;7, 6&#125;, &#123;14, 3&#125;的，所以可以直接规定一种顺序——未分配的数直接放入新的组中</span></span><br><span class="line">            <span class="comment">// 那我们可以将它固定到第一个新组中，这样可以减掉很多等效冗余的方案。</span></span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果枚举了所有剩余的数都不能放入当前组，就新开一个组</span></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">dfs</span>(g + <span class="number">1</span>, <span class="number">0</span>, tc, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 新开一个组，注意此时需要将gc和start设为0, g加1，而tc不变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注意初始形参的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-5">python</h4><p>静态数组的思路，为每个组找数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之搜索顺序——AcWing 1118. 分成互质组</span></span><br><span class="line"><span class="comment"># 静态数组的思路，为每个组找数字</span></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> setrecursionlimit</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    p = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    group = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    vis = [<span class="literal">False</span>] * n</span><br><span class="line">    ans = n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b) <span class="keyword">if</span> b <span class="keyword">else</span> a</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">group, gc, i</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(gc):</span><br><span class="line">            <span class="keyword">if</span> gcd(p[group[j]], p[i]) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">g, gc, tc, start</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> ans </span><br><span class="line">        <span class="keyword">if</span> g &gt;= ans:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> tc == n:</span><br><span class="line">            ans = g</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> vis[i] <span class="keyword">and</span> check(group[g], gc, i):</span><br><span class="line">                vis[i] = <span class="literal">True</span></span><br><span class="line">                group[g][gc] = i</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                dfs(g, gc + <span class="number">1</span>, tc + <span class="number">1</span>, i + <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">                vis[i] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> gc:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            dfs(g + <span class="number">1</span>, <span class="number">0</span>, tc, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>动态数组思路，为每个数字找组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之搜索顺序——AcWing 1118. 分成互质组</span></span><br><span class="line"><span class="comment"># 动态数组思路，为每个数字找组</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"><span class="comment"># 返回最大公约数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    p = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="comment"># 求出所有互质的一对数</span></span><br><span class="line">    coprime = &#123;(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> p <span class="keyword">for</span> y <span class="keyword">in</span> p <span class="keyword">if</span> gcd(x, y) == <span class="number">1</span>&#125;</span><br><span class="line">    group = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    res = n</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 回溯法，为每个 p[idx] 找到合适的组</span></span><br><span class="line">    <span class="comment"># idx为当前要分配的数的索引</span></span><br><span class="line">    <span class="comment"># group 为预设的空组，size 为存在元素的组个数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">idx, size</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> res</span><br><span class="line">        <span class="comment"># 剪枝 and 刷新答案</span></span><br><span class="line">        <span class="keyword">if</span> size &gt;= res <span class="keyword">or</span> idx == n:</span><br><span class="line">            res = <span class="built_in">min</span>(res, size)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = p[idx]</span><br><span class="line">        <span class="comment"># 尝试将 p[idx] 插入当前存在元素的组（group 中前 size 个组）</span></span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> group[:size]:</span><br><span class="line">             <span class="comment"># 查询当前 p[idx] 与组 g 中元素组成的二元组是否都在 coprime 中</span></span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">all</span>((cur, val) <span class="keyword">in</span> coprime <span class="keyword">for</span> val <span class="keyword">in</span> g):</span><br><span class="line">                 g.append(cur)</span><br><span class="line">                 backtrace(idx + <span class="number">1</span>, size)</span><br><span class="line">                 g.pop() <span class="comment"># 回溯恢复现场</span></span><br><span class="line">        <span class="comment"># 新开一组，插入 p[idx]</span></span><br><span class="line">        group[size] = [cur]</span><br><span class="line">        backtrace(idx + <span class="number">1</span>, size + <span class="number">1</span>)</span><br><span class="line">        group[size] = [] <span class="comment"># 回溯恢复现场</span></span><br><span class="line">    </span><br><span class="line">    backtrace(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="状压-DP">状压 DP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFS之搜索顺序——AcWing 1118. 分成互质组</span></span><br><span class="line"><span class="comment"># 状压 DP</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    p = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    <span class="comment"># 求出所有互质的一对数</span></span><br><span class="line">    coprime = &#123;(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> p <span class="keyword">for</span> y <span class="keyword">in</span> p <span class="keyword">if</span> gcd(x, y) == <span class="number">1</span>&#125;</span><br><span class="line">    dp = [n] * (<span class="number">1</span> &lt;&lt; n) <span class="comment"># 2^n</span></span><br><span class="line">    <span class="comment"># 使用二进制状态表示出所有可能的分组的情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查当前状态的所有元素是否满足组内互质</span></span><br><span class="line">    <span class="comment"># all 中 iterator 为空时也返回 True，满足单个元素的答案情况</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">mask</span>):</span><br><span class="line">        <span class="comment"># 使用二进制保存当前组中包含的数，1为包含，0为不包含</span></span><br><span class="line">        <span class="comment"># x &gt;&gt; i &amp; 1用来判断第i位是0还是1</span></span><br><span class="line">        g = [p[idx] <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">if</span> mask &gt;&gt; idx &amp; <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>((g[i], g[j]) <span class="keyword">in</span> coprime <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(g)) </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(g)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从小到大转移，枚举子集的状压 DP</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1</span> &lt;&lt; n):</span><br><span class="line">        <span class="comment"># 满足组内互质的二进制对应分组</span></span><br><span class="line">        <span class="keyword">if</span> helper(i):</span><br><span class="line">            dp[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 枚举一半子集即可，剪枝</span></span><br><span class="line">        j, split = (i - <span class="number">1</span>) &amp; i, i &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 状压 DP</span></span><br><span class="line">        <span class="keyword">while</span> j &gt; split:</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + dp[i^j])</span><br><span class="line">            j = (j - <span class="number">1</span>) &amp; i</span><br><span class="line">    <span class="built_in">print</span>(dp[-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幻梦的结束，新的道路</title>
      <link href="/2023/02/16/%E5%B9%BB%E5%BF%B5%E7%9A%84%E7%BB%93%E6%9D%9F%EF%BC%8C%E6%96%B0%E7%9A%84%E9%81%93%E8%B7%AF/"/>
      <url>/2023/02/16/%E5%B9%BB%E5%BF%B5%E7%9A%84%E7%BB%93%E6%9D%9F%EF%BC%8C%E6%96%B0%E7%9A%84%E9%81%93%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="04eb0193dd8207636e0e3dc1058956e944600e0cc6f86a1cf06343e0ebdffd35">0a9f54710ab1d21f49485fe815ff4acb1d374b810bdd06cec714d0739c904c1dffb5e5ecb8b419a90893818e23a946797b268cb61c686cd48be8359b9899722a44f31b791efb8d7cca4cc9479f249c69ce08c13b7dd6b93d1e40cfaba5dad29da7504392684905d69bfc835d7bbfb9a3307ce8d8509d30d18dfd9cd274255f4297c4528ae339e039983982d74a23e259183d2c2136420d69b74d34926e81915d60dc6e5f5e6d2c21e3afafa6ac066b7d9567dc63baedec7cc0857991c2699fe2b4409fcca4d0a097a48758450e8b61c3a253fcc8bd54a4b46c83f2d34768f9083b047fa9644dd05a203961cdafbfba5faae06c7aff0185ef089710d60556439b3300464e29c395aab36a96248a5bb9b36e551281c27d2ff011b176f3025372d97773e628cb450670d1be7597bff1fbfc34eacb417ade30e6ee9350849f48dbfea433f9043e87e55d6fbbcc4458e892126e99245174858297a9df83aca146497d1e49b83c42b5fe78eecaa0491bdf2d000f9368945207f52b24903e4a47cbf0491c76623fe98cc5387c7cef910786cf87fc1a9c312fc8eb5702f603cf347bff0a2880e9699203cf1f72128b84dfbd15fdaea33dd14fa0806074e8ba88cc0682bf83f36442503fb247a6acbf69609ceb14ee948d84dff2b503c3595d7fa43990f94cfc47de7d55b433e9c13216377869eb1a855faf161b9d451a9e9be3fd9e987c464b0a54c5c5facde795d16e01bac80103e28d8fce62a52a0a01741ed92db3c07e51fb6329d1807dd2fa9ef7493c4cfdf52f154f411069feb6b4a63bf1baa3e5ee5eab95b28142f13d1e9802b88081eef57754193aade4acc306cefa47c2467b4055fab77b078ba13fabf2cda64f8e7c3c81d77d368a266ff17596e41b0c8e727771b660dc8bb0b01a31742f3a9f6d7df4467d3ec1365f212329376d7d5c052b10f75cf033d984852f8633ebdc7ce405bd5717de2ca653ca15982fc390ffbd1646ef3d9f5610b3844251c3120751cb8d4dd6fb7efb015dfb57588fc83a7d8ef2e4dc884db91291d9aee519ac3156ada8ced742dec1d0898995523068381c70f6eb54013b0c16420d5e3c5496d52e200c7a125877819c8063afba292bbaa056d23474d11d898a68363d60220c9c3b358b4b4c588441c959915aada7b36b1c1ab8967ead5b4909cb1dcf7cc8a238dba0521fe4161dd14afea3d6908babc03b3103776753f25fb2bc77f6bbf41667d6b721384f9b87b8676150880a38e9e9720dccf7e0ce05caabf342f89487f5359d71fe51b326f1fd2165fa3539bcb71119f7a4e55a527761268ee9626131121018affe9b0dbd534e37f69b1dadac910a3955a41722de6cd3275caa1aabaf23f31c5e6d74b038574a1b9eab233fdbb74f5b3dc7ad8f6d0072640460c22dc34b11c50eb8cac05d0b245d2d416ea0bd9151571c8e81f57b382edf791886d88ecd1003cf3cc80341f582a13de1a2dd50b8d870cf7e7fc61f625a4701f4760a6ad0de3b26f68565188cd0f92787454502ca4679c169ae786deed0973cc4ee709aa02c0795f0b809e20e1f6bfd33b66c16b2af5237d69cc21fce76c57a54d8817f412950a42f29e4e20b1d4304f5dc84fd821d87501e849c37ebd51aea4639db20f89afdbefed40cb7bbca83f607a91046dc5d56fa52a75d1b8fba9b92c1a736df5576ebfc68dee41bb42a337f8c50d3b965a263c4a726f08449e4119f3b1eed300bd271045f86af73e6c69a7abeaaf904c5c55f1c9baf4a1e0a74cfa8a4f514d19fd45f8975f82e59ae1a959f7c089cb492f4c07599f7a649f014b0c937e2827567f163cf98a3fbf7c9800532a57a3c32ca49a34aafc381d4f692d6e40b8351662cc552f260b7cb6e6c37afc747142cf632ca6672cbfc4783ac7640bbf6f5eabfcbf58769ccd05efe679230ca9d44c43eb074c129785e0d1d95967abad897522926d856c57955fe7b531f6a255727a7d440844fe562dba6ab16fcb44485afed1ae5d9fa54062dfdc469dbb06c60b4cf8b6d63a117b33a0ccd89d4289e74d996509ba9f49ed49b2af96ca541b0a86ac2e81a6b53172f895b8bb3558e0994110185a9e20d0761c1d188c9ab40cacf5fe7dd04fc1b8b30ca06fd948e8580d39868021fea71026b9c59d22d88dad3c78e6d182c2db9212c07a6298424412263b201c6d8a52ff7628d5afb389a5540aa3d15ee4d61d6d252a6efc29888fa61e6295ef416156ced18e64e282f1accee339c917b6204210b1208e34c4504551150982bc016d9aa5d5856eb9ab5b42b50fd69676a6dd0206c725ca0623e458a1b7b2d1969d074c6ed945c82668cfe656cbc51b238afd20c5ca48c892c0ae4f131b3ac066980d47cb11f803c5f083e0ffe3c7451c36f55c2a0aab60528c30f4251525ddff1bb3be825105036ae3346b5e889ce9096252918b148818598f6f2154de58df8d975057b3d4b706a2811c44d1bf3c51c9d5ffa822ccb37776b95c88a5b0f0465f67af5a8e38f6392d50074befd93b180d21383627f13c446ccb125a2510799dc221d10ee57371c9ba520f32749dd1f25967ef19f0b63b0a08fe86d5dcf9283ff3f8ea2db86c9abaa2643d857b2460a6f0d778b8b57702f5d76c4e12e6389adadbe7a2d3ad0b9d9487108e0797b9b2cbdbbd537c4e03c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">🐶嘿嘿, 你没有权限进入呢！🐕.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.2 BFS中的多源BFS-双端队列BFS-最小步数模型</title>
      <link href="/2023/01/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-20230131-2-1-2-BFS%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%BA%90BFS-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97BFS-%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/01/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-20230131-2-1-2-BFS%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%BA%90BFS-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97BFS-%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-2-BFS中的多源BFS-双端队列BFS-最小步数模型">2.1.2 BFS中的多源BFS-双端队列BFS-最小步数模型</h1><h2 id="一-多源BFS——求解到最近的一个起点的距离">一. 多源BFS——求解到最近的一个起点的距离</h2><p>起点不唯一，求到多个源点中距离最短的路径。</p><p>注意这和多源最短路是不同的，多源最短路是求到所有源点分别的最短距离，这里求解的是到最近的源点的距离，只取一个值。</p><p>这种问题可以转化为单源最短路问题。假想一个“虚拟“源点，从”虚拟“源点到各个起点的距离都是0，然后从”虚拟“源点开始BFS遍历。实际求解释不需要构造这个虚拟源点，只需要刚开始时将所有起点都入队列即可。</p><h3 id="1-AcWing-173-矩阵距离">1. <a href="https://www.acwing.com/problem/content/175/">AcWing 173. 矩阵距离</a></h3><h4 id="C">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多源BFS——AcWing 173. 矩阵距离</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span> , tt = <span class="number">-1</span>;<span class="comment">// 注意这里tt从-1开始</span></span><br><span class="line">    <span class="comment">// 分别标记队列要取出结点的位置，存取结点的前一个位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="comment">// 虚源点的思想，假设所有源点都和虚源点连通，并且距离为0</span></span><br><span class="line">    <span class="comment">// 将所有源点入队列即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                q[++ tt] = &#123;i, j&#125;;</span><br><span class="line">                dist[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        PII t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[a][b]  != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            q[++ tt] = &#123;a, b&#125;;</span><br><span class="line">            dist[a][b] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);<span class="comment">// 注意这里输入间没有空格，要采用字符串读取   </span></span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; ++ j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dist[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[i][m<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多源BFS——AcWing 173. 矩阵距离</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dist = [[-<span class="number">1</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dx = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    dy = [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>():</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> g[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    q.append((i, j))</span><br><span class="line">                    dist[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>): </span><br><span class="line">                a, b = x + dx[i], y + dy[i]</span><br><span class="line">                <span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">or</span> a &gt;= n <span class="keyword">or</span> b &lt; <span class="number">0</span> <span class="keyword">or</span> b &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> dist[a][b] != -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                q.append((a, b))</span><br><span class="line">                dist[a][b] = dist[x][y] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    bfs()</span><br><span class="line">    <span class="comment"># for i in range(n):</span></span><br><span class="line">    <span class="comment">#     for j in range(m):</span></span><br><span class="line">    <span class="comment">#         print(dist[i][j], end=&quot; &quot;)</span></span><br><span class="line">    <span class="comment">#     print()</span></span><br><span class="line">    [<span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> r])) <span class="keyword">for</span> r <span class="keyword">in</span> dist] <span class="comment"># 速度快很多</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="二-双端队列BFS——01BFS">二. 双端队列BFS——01BFS</h2><p>边权不唯一，既有0又有1(0 and not 0)</p><p>注意建图思想，节点间有两种连通方式，一种不需要操作，一种需要操作且操作花费相同，此时就可以转为01边权。</p><p>这种问题可以使用双端队列处理。边权为0的插入队头，边权为1的插入队尾。这样维持了两段性和单调性。</p><p>注意这种题目中，一个节点可能会入队多次从而更新多次。当作特殊的dijkstra算法来写。</p><h3 id="1-AcWing-175-电路维修">1.<a href="https://www.acwing.com/problem/content/177/">AcWing 175. 电路维修</a></h3><p>注意本题的性质——有一半的点不可达。与起点行列和的奇偶性不同的节点，就不可达。原因在于斜着走奇偶坐标一定是同时加减变化。这种性质保证了不会同时走一个方格中的两个对角线方向，从而电路一定是连通的，从而才能使用BFS解决这道题。否则使用BFS可能不符题意。</p><p>需要将 「电线所在方格的四个点」 与 「方格坐标」 对应起来，因此在这里引入了 两对对应的下标偏移~</p><h4 id="C-2">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双端队列BFS——AcWing 175. 电路维修 </span></span><br><span class="line"><span class="comment">// 边权不唯一，既有0又有1(0 and not 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"><span class="comment">// 这里要注意g[N][N]存的是边的状态图，而dist[N][N]存的是节点间的距离</span></span><br><span class="line"><span class="comment">// 因此两者的坐标是不同的，前者是边的坐标，后者是节点的坐标，不能混淆，需要分别进行定义表示</span></span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="comment">// 类似dijkstra算法，一个节点会多次入队，需要判重数组，防止多次更新</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// 初始距离为无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    deque&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cs[] = <span class="string">&quot;\\/\\/&quot;</span>; <span class="comment">// 四个方向通路时的状态，以左上角方格为起点顺时针记录，呈 X 型</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;; <span class="comment">// 节点的对应坐标</span></span><br><span class="line">    <span class="comment">// 指经过此方向的电线后可到达的点，以左上角方格顺时针编号</span></span><br><span class="line">    <span class="type">int</span> ix[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, iy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 边的对应坐标，注意这里的相对坐标也是相对节点而言的，因为入队的是节点</span></span><br><span class="line">    <span class="comment">// 指此方向的电线将经过的田子格（边状态），以左上角方格顺时针编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[t.x][t.y]) <span class="keyword">continue</span>; <span class="comment">// 不重复更新，类堆优化 Dijkstra 的判重方式</span></span><br><span class="line">        st[t.x][t.y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对电线的走向、走过的方格进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )&#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i]; <span class="comment">// 节点的坐标-&gt;记录节点距离</span></span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt; n || b &lt; <span class="number">0</span> || b &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 注意这里上界是n和m，而不是n-1和m-1</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> ca = t.x + ix[i], cb = t.y + iy[i]; <span class="comment">// 边的坐标-&gt;读边的当前状态</span></span><br><span class="line">            <span class="type">int</span> d = dist[t.x][t.y] + (g[ca][cb] != cs[i]);</span><br><span class="line">            <span class="comment">// 根据边的状态是否是连通状态来判断边权</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d &lt; dist[a][b])&#123; <span class="comment">// 只有距离更短才进行更新</span></span><br><span class="line">                dist[a][b] = d;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g[ca][cb] != cs[i]) q.<span class="built_in">push_back</span>(&#123;a, b&#125;);</span><br><span class="line">                <span class="keyword">else</span> q.<span class="built_in">push_front</span>(&#123;a, b&#125;);</span><br><span class="line">                <span class="comment">// 边权为0的插入队头，边权为1的插入队尾。这样维持了两段性和单调性。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T -- )&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO SOLUTION&quot;</span>);</span><br><span class="line">        <span class="comment">// if (n + m &amp; 1) puts(&quot;NO SOLUTION&quot;); </span></span><br><span class="line">        <span class="comment">// 与起点行列和的奇偶性不同的节点，就不可达</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-2">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双端队列BFS——AcWing 175. 电路维修 </span></span><br><span class="line"><span class="comment"># 边权不唯一，既有0又有1(0 and not 0)</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    es = <span class="string">&quot;\\/\\/&quot;</span></span><br><span class="line">    <span class="comment"># 四个方向通路时的状态，以左上角方格为起点顺时针记录，呈 X 型</span></span><br><span class="line">    d_x, d_y = [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 节点的对应坐标，指经过此方向的电线后可到达的点，以左上角方格顺时针编号</span></span><br><span class="line">    d_ex, d_ey = [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 边的对应坐标，注意这里的相对坐标也是相对节点而言的，因为入队的是节点</span></span><br><span class="line">    <span class="comment"># 指此方向的电线将经过的田子格（边状态），以左上角方格顺时针编号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>():</span><br><span class="line">        dist = [[<span class="number">1e9</span>] * (m + <span class="number">1</span>)  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 一定注意这里上界是n和m，而不是n-1和m-1</span></span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dq = deque([(<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">        vis = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 不重复更新，类堆优化 Dijkstra 的判重方式</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> dq:</span><br><span class="line">            x, y = dq.popleft()</span><br><span class="line">            <span class="keyword">if</span> (x, y) <span class="keyword">in</span> vis:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            vis.add((x, y))</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> ch, dx, dy, dex, dey <span class="keyword">in</span> <span class="built_in">zip</span>(es, d_x, d_y, d_ex, d_ey):</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt; n <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> ny &gt; m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                ex, ey = x + dex, y + dey</span><br><span class="line">                d = dist[x][y] + <span class="built_in">int</span>(g[ex][ey] != ch)</span><br><span class="line">                <span class="comment"># 根据边的状态是否是连通状态来判断边权</span></span><br><span class="line">                <span class="keyword">if</span> d &lt; dist[nx][ny]:</span><br><span class="line">                    dist[nx][ny] = d</span><br><span class="line">                    <span class="keyword">if</span> g[ex][ey] == ch:</span><br><span class="line">                        dq.appendleft((nx, ny))</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dq.append((nx, ny))</span><br><span class="line">                    <span class="comment"># 边权为0的插入队头，边权为1的插入队尾</span></span><br><span class="line">                    <span class="comment"># 这样维持了两段性和单调性</span></span><br><span class="line">        <span class="keyword">return</span> dist[n][m]    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(T):</span><br><span class="line">        n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        g = [<span class="built_in">input</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 这里要注意g存的是边的状态图，而dist存的是节点间的距离</span></span><br><span class="line">        res = bfs()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;NO SOLUTION&quot;</span> <span class="keyword">if</span> res == <span class="number">1e9</span> <span class="keyword">else</span> res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="三-最小步数模型——状态图中的搜索">三. 最小步数模型——状态图中的搜索</h2><p>最小步数-&gt;整体视为一个状态，状态的变换的最小步数(状态本身作为一个点，每次变换视为一步，问题是状态之间的逻辑关系)</p><p>以棋盘为例进行说明，最短路模型指求解棋盘中某一点到另一点的最短距离，而最小步数模型将棋盘整体的布局视为一个状态，通过对棋盘进行最少的操作变换得到新的棋局状态</p><p>搜索的不是一个具体的图，每个节点不是一个具体的点。每个节点都是一个状态的抽象，边是状态间的变换操作，图是状态转移的有向图。</p><p>其本质就是在所有状态构成的状态转换有向图中进行最短距离搜索，只不过状态的具体表示是可千变万化的，需要将具体问题转化为状态转移问题，因为需要重点思考状态的存储表示和变换操作的实现。</p><p>这种题目思路相对简单，但代码比较难写</p><p>状态图的存储一般使用哈希法（手写哈希函数，康托展开，map）。</p><p>由于数组不方便进行存储、逻辑判断等操作，将状态以字符串形式进行存储，但进行变换操作时为了具体形象，需要转换为数组进行操作</p><p>eg.八数码</p><h3 id="1-AcWing-1107-魔板">1.<a href="https://www.acwing.com/problem/content/1109/">AcWing 1107. 魔板</a></h3><p>本题是一个重点要掌握的外部搜索的的题。外部表示往往涉及状态表示和状态转移。</p><p>本题的两大难点：</p><ol><li class="lvl-3"><p>状态表示</p></li></ol><ul class="lvl-0"><li class="lvl-3"><p>如何把状态放到队列里</p></li><li class="lvl-3"><p>如何记录每个状态的距离</p></li></ul><ol start="2"><li class="lvl-3"><p>状态转移</p></li></ol><p>本题状态表示比较复杂，每个状态都是一个3 X 3的小矩阵。</p><p>一种比较简单的方式是使用字符串来表示状态，将二维矩阵转化为一维字符串（展成一行）。入队时使用queue<string> queue，记录距离时使用哈希表unordered_map&lt;string, int&gt; dist。</p><p>在进行状态转移时，首先将字符串变回矩阵（可以是想象的），然后进行转移——枚举上下左右，最后将矩阵再变回字符串。</p><p>这里要用到一个常用技巧：二维坐标与一维坐标的转换。设矩阵大小为n X m，元素二维坐标为(x, y)(x为行号，y为列号)，一维坐标是k，则：$$x = k / n, y = k % n$$<br>$$ k = x * n + y$$</p><p>注意这里要求一维序列和二维矩阵都要从0开始计数。</p><p>按序输出往往意味着在处理时就按照要求的顺序的进行处理，而不是在求解完后再进行排序。本题要求按字典序输出，则我们只需在处理时按&quot;A&quot;、“B”、&quot;C&quot;的顺序进行处理即可。</p><h4 id="C-3">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS之最小步数模型——外部搜索——AcWing 1107. 魔板  </span></span><br><span class="line"><span class="comment">// 写代码时先搭框架再扣细节</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[<span class="number">2</span>][<span class="number">4</span>]; </span><br><span class="line"><span class="comment">// 具体表示当前状态，方便进行转换</span></span><br><span class="line">unordered_map&lt;string, pair&lt;<span class="type">char</span>, string&gt;&gt; pre;</span><br><span class="line"><span class="comment">// 记录操作序列和前一个状态，注意要将操作的类型一并存储</span></span><br><span class="line"><span class="comment">// 需要注意状态图和相关属性的存储使用哈希表，其中每个状态用字符串表示-&gt;状态无法直接用坐标刻画，而是有其整体内容刻画</span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; dist;</span><br><span class="line"><span class="comment">// 存取每个状态的变换次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前状态对应的二维矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) g[<span class="number">0</span>][i] = state[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">7</span>, j = <span class="number">0</span>; j &lt; <span class="number">4</span>; i --, j ++) g[<span class="number">1</span>][j] = state[i];</span><br><span class="line">    <span class="comment">// 注意第二行是反序（正反指数字大小顺序4</span></span><br><span class="line">    <span class="comment">// 我们在字符串表示时，为方便，第二行也使用了正序，但转为矩阵时要变回反序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前状态对应的一维序列</span></span><br><span class="line"><span class="function">string <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) res += g[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i -- ) res += g[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别实现所有操作函数</span></span><br><span class="line"><span class="comment">// 交换上下两行</span></span><br><span class="line"><span class="function">string <span class="title">move0</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>(state);</span><br><span class="line">    <span class="comment">// 转换成二维矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) <span class="built_in">swap</span>(g[<span class="number">0</span>][i], g[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 返回对应的一维序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将最右边的一列插入到最左边</span></span><br><span class="line"><span class="function">string <span class="title">move1</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>(state);</span><br><span class="line">    <span class="comment">// 转换成二维矩阵</span></span><br><span class="line">    <span class="type">char</span> v0 = g[<span class="number">0</span>][<span class="number">3</span>], v1 = g[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 先把最右边一列抽出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        g[<span class="number">0</span>][i] = g[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        g[<span class="number">1</span>][i] = g[<span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余列右移</span></span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = v0, g[<span class="number">1</span>][<span class="number">0</span>] = v1;</span><br><span class="line">    <span class="comment">// 将最右边的一列插入到最左边</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 返回对应的一维序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 魔板中央对的4个数作顺时针旋转</span></span><br><span class="line"><span class="function">string <span class="title">move2</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>(state);</span><br><span class="line">    <span class="comment">// 转换成二维矩阵</span></span><br><span class="line">    <span class="type">char</span> v = g[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 由于旋转的大小是固定的，直接枚举即可</span></span><br><span class="line">    g[<span class="number">0</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">2</span>] = g[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">2</span>] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 返回对应的一维序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string start, string end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">queue&lt;string&gt; q;</span><br><span class="line">    <span class="comment">// string队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始状态入队并标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) <span class="comment">// 队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 取出队头元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有可能的变换状态</span></span><br><span class="line">        string m[<span class="number">3</span>];</span><br><span class="line">        m[<span class="number">0</span>] = <span class="built_in">move0</span>(t);</span><br><span class="line">        m[<span class="number">1</span>] = <span class="built_in">move1</span>(t);</span><br><span class="line">        m[<span class="number">2</span>] = <span class="built_in">move2</span>(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (!dist.<span class="built_in">count</span>(m[i])) <span class="comment">// 使用count函数查询是否已被搜寻过</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre[m[i]] = &#123;<span class="string">&#x27;A&#x27;</span> + i, t&#125;;</span><br><span class="line">                <span class="comment">// 记录操作序列和前一个状态</span></span><br><span class="line">                dist[m[i]] = dist[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (m[i] == end) <span class="keyword">return</span> dist[m[i]];</span><br><span class="line">                <span class="comment">// 变换后的状态为目标状态时返回</span></span><br><span class="line">                q.<span class="built_in">push</span>(m[i]);</span><br><span class="line">                <span class="comment">// 入队  </span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start = <span class="string">&quot;12345678&quot;</span>, end;</span><br><span class="line">    <span class="comment">// 我们在字符串表示时，为方便，第二行也使用了正序，但转为矩阵时要变回反序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        end += *s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int x;</span></span><br><span class="line">    <span class="comment">// string start, end;</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; 8; i ++ )</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cin &gt;&gt; x;</span></span><br><span class="line">    <span class="comment">//     end += char(x + &#x27;0&#x27;);</span></span><br><span class="line">    <span class="comment">//     // 为了方便状态表示，转化为字符</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= 8; i ++ ) start += char(&#x27;0&#x27; + i);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="built_in">bfs</span>(start, end);</span><br><span class="line">    <span class="comment">// 传入初始状态和目标状态</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (step &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="comment">// 反向得到搜寻序列</span></span><br><span class="line">        <span class="keyword">while</span> (end != start)</span><br><span class="line">        &#123;</span><br><span class="line">            res += pre[end].first;</span><br><span class="line">            end = pre[end].second;</span><br><span class="line">            <span class="comment">// 这里注意要使用pair&lt;char, string&gt;才方便倒退</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 注意反转</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不使用dist">不使用dist</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS之最小步数模型——外部搜索——AcWing 1107. 魔板  </span></span><br><span class="line"><span class="comment">// 写代码时先搭框架再扣细节</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g[<span class="number">2</span>][<span class="number">4</span>]; </span><br><span class="line"><span class="comment">// 具体表示当前状态，方便进行转换</span></span><br><span class="line">unordered_map&lt;string, pair&lt;string, string&gt;&gt; pre;</span><br><span class="line"><span class="comment">// 记录操作序列和前一个状态，注意要将操作的类型一并存储</span></span><br><span class="line"><span class="comment">// 需要注意状态图和相关属性的存储使用哈希表，其中每个状态用字符串表示-&gt;状态无法直接用坐标刻画，而是有其整体内容刻画</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前状态对应的二维矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) g[<span class="number">0</span>][i] = state[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">7</span>, j = <span class="number">0</span>; j &lt; <span class="number">4</span>; i --, j ++) g[<span class="number">1</span>][j] = state[i];</span><br><span class="line">    <span class="comment">// 注意第二行是反序（正反指数字大小顺序4</span></span><br><span class="line">    <span class="comment">// 我们在字符串表示时，为方便，第二行也使用了正序，但转为矩阵时要变回反序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前状态对应的一维序列</span></span><br><span class="line"><span class="function">string <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) res += g[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i -- ) res += g[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别实现所有操作函数</span></span><br><span class="line"><span class="comment">// 交换上下两行</span></span><br><span class="line"><span class="function">string <span class="title">move0</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>(state);</span><br><span class="line">    <span class="comment">// 转换成二维矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) <span class="built_in">swap</span>(g[<span class="number">0</span>][i], g[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 返回对应的一维序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将最右边的一列插入到最左边</span></span><br><span class="line"><span class="function">string <span class="title">move1</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>(state);</span><br><span class="line">    <span class="comment">// 转换成二维矩阵</span></span><br><span class="line">    <span class="type">char</span> v0 = g[<span class="number">0</span>][<span class="number">3</span>], v1 = g[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 先把最右边一列抽出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        g[<span class="number">0</span>][i] = g[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        g[<span class="number">1</span>][i] = g[<span class="number">1</span>][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其余列右移</span></span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = v0, g[<span class="number">1</span>][<span class="number">0</span>] = v1;</span><br><span class="line">    <span class="comment">// 将最右边的一列插入到最左边</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 返回对应的一维序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 魔板中央对的4个数作顺时针旋转</span></span><br><span class="line"><span class="function">string <span class="title">move2</span><span class="params">(string state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>(state);</span><br><span class="line">    <span class="comment">// 转换成二维矩阵</span></span><br><span class="line">    <span class="type">char</span> v = g[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 由于旋转的大小是固定的，直接枚举即可</span></span><br><span class="line">    g[<span class="number">0</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    g[<span class="number">1</span>][<span class="number">2</span>] = g[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    g[<span class="number">0</span>][<span class="number">2</span>] = v;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 返回对应的一维序列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(string start, string end)</span></span>&#123;</span><br><span class="line">queue&lt;string&gt; q;</span><br><span class="line">    <span class="comment">// string队列</span></span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    pre[start] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 初始状态入队</span></span><br><span class="line">    string op[<span class="number">3</span>] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) <span class="comment">// 队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 取出队头元素</span></span><br><span class="line">        <span class="keyword">if</span> (t == end) <span class="comment">// 变换后的状态为目标状态时返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举所有可能的变换状态</span></span><br><span class="line">        string m[<span class="number">3</span>];</span><br><span class="line">        m[<span class="number">0</span>] = <span class="built_in">move0</span>(t);</span><br><span class="line">        m[<span class="number">1</span>] = <span class="built_in">move1</span>(t);</span><br><span class="line">        m[<span class="number">2</span>] = <span class="built_in">move2</span>(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (!pre.<span class="built_in">count</span>(m[i])) <span class="comment">// 使用count函数查询是否已被搜寻过</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre[m[i]] = &#123;pre[t].first + op[i], t&#125;;</span><br><span class="line">                <span class="comment">// 记录操作序列和前一个状态</span></span><br><span class="line">                q.<span class="built_in">push</span>(m[i]);</span><br><span class="line">                <span class="comment">// 入队  </span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start = <span class="string">&quot;12345678&quot;</span>, end;</span><br><span class="line">    <span class="comment">// 我们在字符串表示时，为方便，第二行也使用了正序，但转为矩阵时要变回反序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        end += *s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bfs</span>(start, end);</span><br><span class="line">    <span class="comment">// 传入初始状态和目标状态</span></span><br><span class="line">    <span class="type">int</span> step = pre[end].first.<span class="built_in">length</span>();</span><br><span class="line">    cout &lt;&lt; step &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (step)</span><br><span class="line">        cout &lt;&lt; pre[end].first &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 注意最后输出时需要先判断，避免第二个换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-3">python</h4><p>python对一维序列进行操作比较方便，因此不必转化为二维矩阵。</p><h5 id="复杂版">复杂版</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS之最小步数模型——外部搜索——AcWing 1107. 魔板  </span></span><br><span class="line"><span class="comment">#  复杂版</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    start = <span class="string">&quot;12345678&quot;</span></span><br><span class="line">    end = <span class="string">&quot;&quot;</span>.join(<span class="built_in">input</span>().split())</span><br><span class="line">    g = [[<span class="string">&quot;&quot;</span>] * <span class="number">4</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">    pre, dist = &#123;&#125;, &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>): </span><br><span class="line">            g[<span class="number">0</span>][i] = state[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            g[<span class="number">1</span>][i]= state[<span class="number">7</span> - i]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            res = res + g[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            res = res + g[<span class="number">1</span>][<span class="number">3</span> - i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">A</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="built_in">set</span>(state)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            g[<span class="number">0</span>][i], g[<span class="number">1</span>][i] = g[<span class="number">1</span>][i], g[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">return</span> get()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">B</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="built_in">set</span>(state)</span><br><span class="line">        v0, v1 = g[<span class="number">0</span>][<span class="number">3</span>], g[<span class="number">1</span>][<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            g[<span class="number">0</span>][i] = g[<span class="number">0</span>][i - <span class="number">1</span>]</span><br><span class="line">            g[<span class="number">1</span>][i] = g[<span class="number">1</span>][i - <span class="number">1</span>]</span><br><span class="line">        g[<span class="number">0</span>][<span class="number">0</span>], g[<span class="number">1</span>][<span class="number">0</span>] = v0, v1</span><br><span class="line">        <span class="keyword">return</span> get()</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">C</span>(<span class="params">state</span>):</span><br><span class="line">        <span class="built_in">set</span>(state)</span><br><span class="line">        g[<span class="number">0</span>][<span class="number">1</span>], g[<span class="number">0</span>][<span class="number">2</span>], g[<span class="number">1</span>][<span class="number">2</span>], g[<span class="number">1</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">1</span>], g[<span class="number">0</span>][<span class="number">1</span>], g[<span class="number">0</span>][<span class="number">2</span>], g[<span class="number">1</span>][<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> get()</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>():</span><br><span class="line">        q = deque([start])</span><br><span class="line">        pre[start] = (<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        dist[start] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            t = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> t == end:</span><br><span class="line">                <span class="keyword">return</span> dist[t]</span><br><span class="line">            <span class="keyword">for</span> op, <span class="built_in">next</span> <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="string">&quot;ABC&quot;</span>, (A(t), B(t), C(t))):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> dist:</span><br><span class="line">                    dist[<span class="built_in">next</span>] = dist[t] + <span class="number">1</span></span><br><span class="line">                    pre[<span class="built_in">next</span>] = (op, t)</span><br><span class="line">                    q.append(<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    step = bfs()</span><br><span class="line">    <span class="built_in">print</span>(step)</span><br><span class="line">    <span class="keyword">if</span> step &gt; <span class="number">0</span>:</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> end == start:</span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">            res += pre[end][<span class="number">0</span>]</span><br><span class="line">            end = pre[end][<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(res[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h5 id="简化版">简化版</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS之最小步数模型——外部搜索——AcWing 1107. 魔板  </span></span><br><span class="line"><span class="comment"># 简化包含dist版</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    start, end = <span class="string">&quot;12345678&quot;</span>, <span class="string">&quot;&quot;</span>.join(<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># A 操作等价于是翻转原字符串，B、C 操作可以在草稿纸上同理推出</span></span><br><span class="line">    <span class="comment"># 无需转数组，可减少代码量</span></span><br><span class="line">    A = <span class="keyword">lambda</span> s: s[::-<span class="number">1</span>]</span><br><span class="line">    B = <span class="keyword">lambda</span> s: s[<span class="number">3</span>] + s[:<span class="number">3</span>] + s[<span class="number">5</span>:] + s[<span class="number">4</span>]</span><br><span class="line">    C = <span class="keyword">lambda</span> s: s[<span class="number">0</span>] + s[<span class="number">6</span>] + s[<span class="number">1</span>] + s[<span class="number">3</span>:<span class="number">5</span>] + s[<span class="number">2</span>] + s[<span class="number">5</span>] + s[<span class="number">7</span>]</span><br><span class="line">    pre, dist = &#123;&#125;, &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>():</span><br><span class="line">        q = deque([start])</span><br><span class="line">        pre[start] = (<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        dist[start] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            t = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> t == end:</span><br><span class="line">                <span class="keyword">return</span> dist[t]</span><br><span class="line">            <span class="keyword">for</span> op, <span class="built_in">next</span> <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="string">&quot;ABC&quot;</span>, (A(t), B(t), C(t))):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> dist:</span><br><span class="line">                    dist[<span class="built_in">next</span>] = dist[t] + <span class="number">1</span></span><br><span class="line">                    pre[<span class="built_in">next</span>] = (op, t)</span><br><span class="line">                    q.append(<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    step = bfs()</span><br><span class="line">    <span class="built_in">print</span>(step)</span><br><span class="line">    <span class="keyword">if</span> step &gt; <span class="number">0</span>:</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> end == start:</span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">            res += pre[end][<span class="number">0</span>]</span><br><span class="line">            end = pre[end][<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(res[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h5 id="不含dist的简化版">不含dist的简化版</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS之最小步数模型——外部搜索——AcWing 1107. 魔板  </span></span><br><span class="line"><span class="comment"># 不含dist的简化版</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    start, end = <span class="string">&quot;12345678&quot;</span>, <span class="string">&quot;&quot;</span>.join(<span class="built_in">input</span>().split())</span><br><span class="line">    <span class="comment"># A 操作等价于是翻转原字符串，B、C 操作可以在草稿纸上同理推出</span></span><br><span class="line">    <span class="comment"># 无需转数组，可减少代码量</span></span><br><span class="line">    A = <span class="keyword">lambda</span> s: s[::-<span class="number">1</span>]</span><br><span class="line">    B = <span class="keyword">lambda</span> s: s[<span class="number">3</span>] + s[:<span class="number">3</span>] + s[<span class="number">5</span>:] + s[<span class="number">4</span>]</span><br><span class="line">    C = <span class="keyword">lambda</span> s: s[<span class="number">0</span>] + s[<span class="number">6</span>] + s[<span class="number">1</span>] + s[<span class="number">3</span>:<span class="number">5</span>] + s[<span class="number">2</span>] + s[<span class="number">5</span>] + s[<span class="number">7</span>]</span><br><span class="line">    pre = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>():</span><br><span class="line">        q = deque([start])</span><br><span class="line">        pre[start] = (<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            t = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> t == end:</span><br><span class="line">                s = pre[t][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">len</span>(s)), s</span><br><span class="line">            <span class="keyword">for</span> op, <span class="built_in">next</span> <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="string">&quot;ABC&quot;</span>, (A(t), B(t), C(t))):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> pre:</span><br><span class="line">                    pre[<span class="built_in">next</span>] = (pre[t][<span class="number">0</span>] + op, t)</span><br><span class="line">                    q.append(<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>.join(bfs()).strip())</span><br><span class="line">    <span class="comment"># 这里最后输出不需要判断操作序列为空的情况是因为strip()去掉了空，避免了第二个换行符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感知机（Perceptron)与自适性线性单元（Adaline)学习笔记</title>
      <link href="/2023/01/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA-%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
      <url>/2023/01/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA-%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f268ad9fb67353ca40d14a43a1fcf8a81e5dabfed866ccece4bb0cb925174e5e">0a9f54710ab1d21f49485fe815ff4acbd008780628f3e1bbd17e596a77d61bc47505fcf0d6016c3f262549abe7c32e8c7e08b5ffda487ef328b36d93b2f9f8c8966d763b5977d6ff6f2634ae424520aeeedc5a1722b72c8eb77c55d57b813b7799700d60f31550a57a15f2c47226e383cc25a44dc1b3e1184b4d1c1e018d2e8275f8f86026e4cbb5fe124be7cb952cbc7c061d6a01f0f81c3ab4a5e7f4ff826270867f81314ab411bdf16f20611518a54d3395e95b773bc409303572fbcc476b5055482dbdbe113a3adb29ee7dce0e5a64b10bcfda322c7dbf370f4c2ac56ed7e2004ebfe3079740b1de485b6bb9a06e008faf5f112feba09d9a4698cfb8ad9b8b8903213b17f25ce5d2fe5f5128f35c29f2095d072825b2dbe3004bf5a495231eaa787da457c558e9d90a4c2cd0b1268ce3a4b0c6b8a04419b93177e87a2f7f50b5a70515906552cffa646b2c426af61b13d77f2b5f3269c4badace8143e6795fb357cb4bfb1f911df1457ba834869195ae5278f022ab3463080c05b8c25bf92418e97c0075a7216625d8368ee00a50e8aa89f90f3b72059f74dc7c3b65615bf715524aa75c854319feb94369897caa92436b6239a99ec6f63480a12f2689b2857cac4cf51a4b58887644ca8fcd5063e432440ea312fc840249a82a7d74f1dfb2147c6bdccc6ba1cd3196372506038d7ae3d345b3b17fa16e7bb44c5ba7aef4f9312f616b79ba6859a6e094b51693cac3335840e8ff7eaed66028def9e27bacab66d5cce97a7166513ba880c64096e3565e87f02ec905ed31e9e0673e0833cf96a7cb2dc5ae25fe49fc8472152b084b70bd6af1a7dea91f65761987285734772c86289fc9bbedad6636800b9eacf23dc8d20874ebadc3c9a800303794f41539b22dc0befc8a86cbd8c45e508f2ecd19e2f6166c58ad0e3531f93e8bce80f0f704ef46f1e0e5938942aed73e65e8d2c9038491b8b952961830dc451e21a97c20003ccab3d596b71981ac02c376d478f7d74aa69ba5fd435165959d82f577945080b59c979dc501872aabc544275e265a1db83444f38c95827acaaae363ce71ba8babad85aced1f3686de10cf1917657bcaed923d553aed9588bac69c7a8bb112c3a5f14b9a104e37400c4db399930853417ae8618a571825d9d12a4a66952cef19c5a09eba3e3e76409cdbf2d29f4a889f4983f80a4a70ffede9dfbd815488a9d95b3e10110c37aa4915736427affa4f7689088fc30266210ab6381a6301aa9dfee56c4ce98100d2c9c55cf3011be934bad48cb7ad4fca9549ef0aed6af1703ab40ac415693b28b26b24a78676ff3bf2cc1c399d00b487117a6e235709bfbe5a1a73cf4a5d2a6a40b701ea0adc983f64a6e7d6935748af88527cba2b4735ac38976122a57ba167b1c2e948de0d532bd47e7c9f1c2f459e2ec5751705a7064e61316babb46baac31afebc3c19609332718224ae585cf86a3531d7f551d6d7c7004881752c46a0b243906520e1a1c351d6faf71e363c53c45f2e5384c950f941205482e088ca2dc5979085b86786acb25c888c398006bdbe95fe45be29772d3fa965bc649691cd46c903cb4ce7c916c479826523f41ed1783efb6e389c4be8f1443337387253bee4c543294648e9162378fe19943b7bd398f9804244d09412925d67549d379d27b8645056f1cf83c58211f2c850c3e99acf026a40eaaf55d2db12d3f705489221383142ce1061f69fabfd2ea2197511075aed57050ccdd4430e8af0afdcea71391cea0a83d409fc7093395e8f6ae018aa5199df8e3ebe8f2baec32131b4b53aac796c121209ed634b8f63342f4b9de2b0b50cbcb1a9cfa96696d8ec7d7d991f3efeb73605b162e1c4810e633cf72fd1a148eb1300a35a607b02a72aac052875d839ab7ec18c7ad582ca5a814121a5034c0c6822ab3a29268b8665e43f558b407d82ea4ad29c19397b5d000907b5dc9f39e40ed221af26eee89257ea4efa653cf7a1efb439f78057550eef46500bb30bf3621704fc771326380e264cf0d23f8d980b0a47e5c68740c5c8a720983dbe159d2a20775959fede6a63ddc352959f5f04358518339980f6480f99bd3e0769e8e2f88534aea3e93861d121a6bb4f2f248b43065693aa1b2f2a2e77d70ef0f13c9797b29b67036d07965870552ad3a97d89ba663c0c8752b94f9c61e861a02df67067ee78980e90228d8158228fd5c432c8a1fb49450d952be10bca87d72238459c85a28341dc128cd9c39d7f39b18aa5341935fca889179f55815176ca63731178c036a17236209020194919ac8e2515716984d5782425f7d23af303c891d15958f7b37419caa810501aeddb4be84ba43829585f936ad8687a4d5598a0a4808ffeeae9ca89132aff12f427e27d72d15e9ef0be896247fa1261aa2d7cb67e5f6c7758839571ff5a769ff4441723b67ade4d61d4531b0ce9f6025e7b385a57397ae8e36162d59652f1a6136201cd52a134ea03cd0c7910fa14023f082a8b123cd86b4ab479dc7d850bad18de562cdc8980004f8366544425d3b6d6725f320411a277f78ec078cd900fcc94d8f9fee1a16bae0c742a7458686a3195ddec9df8b109fcd3e0e82e7c2c25507c4faf20398c83d30eef7eadaf38588a1a1042d5930506c86e4fda0b150dde8632aea75b7327ad6a2f94e16660ee093dcaec93312753de30a4b37525ebae7c991d58b0b2ede4e7163ec656d4cbf6311b946e0a599cbd7aab93478c6b5ead1134b2702dd02a5b44b4e4eef247c4c708758568ecb4520c2b735d3a3ca19986f93ed6037e491f7ba453e5499622e06bd771e9cf5b40466b4417e88bf678b41885d8d39af0043de1168d082b2a25748efb2ffe54a46d644e2dee732b47f59d549356cb48e7c71f53451d007b79d7154528106c6d233143b47a100725d11aada00ad70db12a8efcb00a750a547853e9c98045594f20ac85e332acf3e99dc89004f84804919b79801d0db8af03343011cb867ba4eb01011e242ea385fadba36e6e37a8af601ccd64efa0aaec5d8d8055137687a0a6f9b24070e351f32f8c1ac805a433ef8a9cc7726328d6137875fa747db46eb7796d89642c41824244669c5641eaf5664620888b138d6e1b5d3eb162b49453271bb7a1c9b54d13a9749d4758c6765a6320ac3b80f4d4c8b4ac262ccdfa9f50b31535e5944c8fe12691115a6e4f3c12a52bede1bf1e0001c1316797c22b86882c245174d43391592e2a682cca8f8df2983e2dc4532fa6fbf45132bdcb47dd7963662dc009317615d517828c92f99ed10bd253a9d8f767f6005dda7b53dbfe2f0e49b53918b25fb8b82f1c4b6085e2e77d11b582259305dc98b7130d81408d35375f0c5c119b539318decaa0063ac8b8ee055ac1255c9256a846836ab6de8cef2f965c533df9bf498d07493c82af9b0a80a22159c6ac5ad25d2ca60d9866c97a7e09a8c6dc6d75c9e4396140359920db26c14a3778749349c2f6ca0cfb7d29ab99b5baa28f9a418dd3022afda6c96836f73ea4a3667a2c1dc53c458705a9ab3698c18c751eefe5151fbf257a6de8790b7887bf92baccf3a7a481cba3e5f186c46fd93b83ee3bfba081b2f6fa39b8b29ab88393ae0c76fec2a7d3d0e0370b9b4f2e620ba0866c3078b5c0952a8fdb36f951a2e21971427f37399616dcaf4db91c13507ed796a81479c343e1cadfca189e17d0ee00852005c579e0bfa85129d1319412c139579516b8d0db45c406520de15cda0e31afa86d56d9945cf04917ef16da950f454ae0181af7dc2ee7b0755e861949283ec294f9e720f4fcdeca0e5671f97969d050b19c112106b6cc06c1684c53158fbedafa847a0c96fa7cdd8655b0402bdb2576138c8b925537c07c4f6b62f2c728353fe984f4db8ee401c5c5640cdb4c53fd64abe5659ac776aff6cf1131bf09ba2ef5985fe4e7abcb856bc5e89db2fc0aa44aea502858829edc7d320f26d7a12853e0891d154c8965fb61e9baa96ba2bd43485f640efa49d9f585cb56c0ff07e0255d98b0356b5adbf18039bff3f23e454e8b0a1257f599cea1f843975fcaf6264e87104372ff759d2559cdc8578aabc539e32b0f1ae691ee97b78a74ea5fe6c1d958c55e121afc3a13a738c55d76297482d3c4ffdcf771b9b9c0912616238dbc88398d1ef5bcfb3e1c992a1b35f71058d46b15d71c64c95c65b27779507a05098d31fcebf2596d411c30a2f5157a0e422611d8f4b8d09fe599087e07aa99761ecb0e7497f196faffc46064b932890bad410af805380b96d7261386a9f8f48d2498b7a2221cf99f94cc97b666fac3f69fa9b2f63742264c4697c0274a1b7e8daa2cc3a2d60c5cb12b3e4b33f6fe996538407b379fa3738f7bee37f725ea2210692352849d77278e0fe34832759766515f1c5f70c78936595a5117b108b723125c1a553a8efc5022df097637f46c042b26cb5e9175f33f4223c40eba018ac17464a1520c5c34d38152c0c9b539d9ed0b6fec5ad3a45d0018220393ad4654efa792a56897b98c759086e96b6c533fd5412521bd4b30d7bd5dfae1a284290fdebf61cbe560d1b1de0d780c4e50c7e0683774ed9050ef58253c61b17dfc07c7d58ed975821b1da80055dcb1277d0f86f61de1a5181691c2b45fc707fd072e2e5c159a9864dc7d5e7d37e44454c794dc7e0ac8c2b60ead8736a2281eab50757103d6fe3bbce89a5ecc47b0ec427cecb181395886464619ea03bee0d43aba0dc0848fadf65128831f58f80390a55363d97fe97aebfa6536b54ef51200d64eb34101af04a3a2511b9c5bf53ace9d899c720931c792c96db04fb80bd0a9bbc62155e1ff33d2087e259498e3588af85999b389576d7ba16a4ee930a61bca619d048fea399a30aca0b34e1c03a045b3409acad1ba4cf6a1fc74f5fad7abd3f52409425c87f55243e43555f586d640a9137172eac54cefaec9661f64e6c1b2014b4d63849d6f5e4bc6f3c3c773fdbbed231f816d66ecbcb785a8262f19b60af6f154a4ffbd9f6389de89853a8b05517782a373d898667afc7e0b846ae1f3f58dbe0066b9792555140e8edcfc540437f9887578bad1979fa024581e36f1fdf0713b608527336ec8da494f55ddc29071afaa4ee756c8e3453158d36d1820b2c518262c62d3a2aefcbe8e77dc7c7ddd3732bd763edff82ec5c9f9fca1608dbeceeeec31149a9c9414fda67adbe7eb6b0ad31c82fcd55d7d237df80a6b89eb7be8bbca78082bacbe645b42b631603f8c1e46f3dc963b2d71cf4ec3107c25297dd73e67eaa172329c6d7dae77e103bcd36c1a0bf301c8353d679995202c86c6df489947d2bbf8c1be8914920beecfa9d82bde4f0325f38743c55f1c1f1229269ea0c2f58461581c6a446c7c894a92e563e4301862cc7d73868f2ba24b00589620279466b2c02ed5efa9e97d8fc49bf1bfd0ccda9aa01d85620bd05db7841f55d42955ef1917ee9245d0cef76230e8095be7abcbac21f6a305efe30cac3c578285ca0ffe9dfc7ff100ee4ccc195fe64aaedc3ebd4ee364a8b2c99bf96b47b9fe809df8ca108b6edfa0985172cc9c30071beaf62c5b94191369a4a17b4155d75edc9e60af565c5f79d48aaccf9923fefd394d29bb4280081a1e32aae0b52c997b2a4eb151925dc54fdbf201698fb313f2b1de25fa8436b27f96f4d3a8bf8a6c3e6e193e44ea2b2b39f03f39b0fb140cdcd720167ed7ae8b73fe352f3a241e91976d38bb554ee0e4d6459027e28e707f443367673a384ff293db2308c6330aeae7628b400cecceb3ef6faf714cc83c313f9df50d58844f0feb36c067e0f1bdae8a0a82012573278928ef88af579d9a372daa1f182dabf2e0d39c2a86da3ce23474e55afd89ecedb5348c0a9587129b9248090ec877b88ef169941e91a12326d7ffbcd5f68eb25dca0a297d9cdbf874db3fe3008ea13dd0f5118fe581c5275792428377afc9b157b34c4212169de1ac3ff386139d35ce566ccbe72147d67760ccb501b8b55f16e2a1d23135fd428456599466bae71723549c6d0e6a8ebed7c29d07f2738f2e0aa4179d6743b4bc40be631d647dda506d1d5946e47c77c7dca99681ca12cd5d7796b56cad75531778c4f15072cc840a717c6cb5b720f936439a1fc5cf6bb02cd8638d8d339648bdb15d48262a20388472c4ef89a61b65cf1a7e3951dfed8becc5c1343df44870fe4b992cbfc6ef534878b7d222ed4159944f0e9b7475a537c6d4ea8d5215e84958308d5b2b2d16b1bdae8ec0f683926da30723ec9dea0f50feab560514fe8725826cef56e720abe78f52b6336aa071fa4771395887bc6ae1d377e042c5de7a34f8ed7b7957dbe84446dab17a2a9bd757cf8033ab57d8a3400a75a8744d2c24acfade113ab8cfc178b3d5e0349c080e3852415b14b047cf5e40255941f712952bf26b9d1b70d6e4a29417f47fadde08760299dc50d0a201384c12d80e55acad84f7c965b3ee21dbfbc11d5f432488c3ed172f00f1652a4bc6725524425f19d1ac0045480719a0f748c6d7faeedd8bf87b77a831ca3902578512b13e1a3225712bf03786dcf2889359fae9f8519a792141445ec7d9dabadce6ebd058c85a2a09850520ee112ce844d98c33dd0830f99bc6699a9c2a9a779f3bac1b1f27473616d76a44db3287b3ee3f56ab424e756dbc4af4921d50ca87b5ff050ee1207392e499ae536349cb5762d6e04e8daed8924f095374a3cb9099a545459759f4e3f3704f470232696c769bffbac53c484b935841166a7877909736ecffe6b10333a7270a8a5863a632d2b25597b53e1557851d8bb41dbcc0571640a2c867756637a468f2b88db8bd4ba368d53c92c50f4f36d9fa89ca91dc0f63a443bd221450ca86e0f0402e3ee3e24c25edb41a4fd9a6bfc9942147d4143b1d9f89c8112a8aa237e6ae576fe22cd43c39147a09aff2f4c72b0163d23c3b9121f06c89e5e6adb0eed4014cfcc4e939d8caa28c2e5efac2629cd621385b3f27d7579e38f21d409e277c690effa411df7eb3b0e489c04ac084896327a8b2ec80932f8addfb1c5100249685afaa1434be337e07c505473202b591fd6ce92883fa418e4fd62ef21bec037b192227bfd7e560c14c67243b9edb57cd1b1176aae78de635cdd335645d6d3ecd1fdfea4922b2dcb85032f23da8a0a9fbbae446fd04454abc6485d840a226cd77059e43e22a7b4bd512e0475b456f38e6d2fcca6be107ecb20f347f2e5fc1d70ca259164cbece378c33e09669db59635cbf33fb902943890a05e1244c94140beee4c5a6e2402b6b38f975ec184d5f4d98a4db4995ae335987ab8c879a6e89b5ac5c70f872489d398ef62d56c783c56aef0b7441e98161521537942585f319c92fba5a3043a6a56baab595d0d7a20e092d627925b6d77f1f36c053f9c0d394a9f19de564ea4fb976441110de974f45830967bffbe3f7adba8a796d3c9cb366867acb44f0f8fc731d3d067fc6bc1d886c802ebcabdb10ebeb76dd685ae8a33eb728e0ecd9745f6b4a5584caf76ca5b50659062d57f8f2f545f794d226bac1fb0440d30c1e770af1c2011c15aac1a891cb95cfa489141a24336d8f7af2fc8dab4fc0ae96a732ab9c37d9d80fd3e3a88d02a5909ac8b9844f0a52b0652bbe4e2f23cd014772231a35ad40100926369fd5da553dec655e4097bbfe7cc081582dbd412ae26334f1173055f7d69e35a499b27de81d98836cc72aa241767e0337ceb2fc770a8a99acb6518e232482eb1f78f9e0be4632d9f09b6c87dc24f6700138ac4d0b607ae7c113a3c586a6849436602df0feec0a170f4c6cdb8275e1e5eb8e49cda8dfac5eba27b723bd0ec4a341f9b016f35195c437000aaeea73dc7d2b9db9da125b8b0cc4f8362ff52a826e10a86137164064279fcbb261a94645579379b2dc3f90fa3f28fab2aae63e7b7a808e07bd8011bd11877334cbbdb26945226f2e3d5c9c7e793dac314c35792c56a335aff2b6a7638a03b4e5d6366fee73fe0f996132fdce8f8cee18ea936a8c1c39dc7038a21256bac5b0bdf9fd85917aa6f9954e9ccb1191a04be2fafe22a42df3414d834f4dc46ae33fae1557ebf085f94f6e99cd6e50620aaa1b7c2fac63df814b89998a170c4b4fbf37a7d7dcf8b4fa36870f2d25f1f7c27d15d3a7e83015096be94b056f814ea2dfa7de3c5c084e5ad83a596cdc3b2ba1b3966092f7187310a4cbcdd34b2faa0f7ccfa3ec2421104cc5a56a5dedfd1f91171ed743c2777fa5d23d406ba6ef0d7507a74906e22f3cd7a11a626aebad9e29b5279dfbdaaac3efc3ff83e8eb1f4474624917e550dee0332a099b347b86f687845dc58c757294a1fdfc4c1850a889dc3ebc29335b60345faa1f1d88873733340735d033a55d30bb1ce96f31ad581cefcf6d1e2eccd1f879ad83ca5f8c9db815497fc6814c5eef378ca8e04219dbefbcd8a79a71121e6b7f7574decf6d238cbce904a31e9e5f1f024fe1836abd184cbce769f008383d0e2bbf3c4421a91ca1b1c03a441e77be23be49eca56180619b979a09bcd2d13fa5271b1fcfc85a0c3578c938f5e4af5d8ff43fe69ca8adb328bf5de6fa85eb9afe5b41ed8008dcee5085dd5141234c6919a1b22f68e73ca54fe16ffd0bd06d0f1ed96d6a065a1a1fe8205171b92d2b63fb72d43e6fb4ca4e7f796fd3fc5acba81e87db5177ff88336bec4dc81046918a5f42079b72684b3e447a3ebf84a4c198e136479983a4e087a4a250f37b9ed4be81c73e906237924c0780845158120587e16f0ee339f68f6ba41368e5031fc3fb9604c3243719b64dfa2aafe97975dc5664de4d74faacd657bb73109b99686b2bf8cbb23900495139d34d7d0d991c43d04dfda3726a03355d2c77e6da9129de95a9c6d6c16bf3b6cc97b58b4d7217b5294144ccbd8fde11facc1785cb65a708170382f444932c1fd69e2cf58213f8404c1f82f3efd3c8bfe8b67b286791eff5bd2ab97e25777428de6c300172287b3f047dce7c3ed6f4c4529ad045d5d02f36d50913ce2cc6dbd3f40d5a3582364bc6089f21708b0604db08520f4a2bd04ce1872f6204b58cfc7494a7f5b093cff0a5eb6a1562264c1d9747c7e853e81bbdbf2445cb0bf29738bcae7fe24c9d111d5571bb06fa4139872d086e5ea6e95446f448a56627e9a268c7a728fecbce22348eea036ffb2353233d9acd9bfbb1cdbc170f3675c50a22db2d6783d8c0f58000401d6e05330b767c9ffdfddb9990cb8bb7741baeb2756f58a241d24aaf6887277c2e9db6d5589cde1588f1a2988f767e74f91867f2b4e48d58f6590f6034ca9fe8a718efa008b61bca52781cf4fd9f314b906210640c733a5739d2b3ff42725e87fa245259cab69180c110a13a9cb9bd53964d824f7dc4988c6dfcc4c436c0519447bb9616747acfcafb8689194e9d8afcb48a57080e1de323304784ea6d9087404406273bcaf6ef0ba07e2507370c27b826f96824ed9d6191e1d5a2f9a7b9306f499c39b37f5a6f556b5d8f70f52d5131db0e28a132001a40a0cd492409c9d3557d44e8ef1079feadbdc550eb3bdc81fd1eec943ce0c04cd3cccfe733a66a8fd813ab95dc49c975c5489f6680bcd1cda7fc9e1824f9c3370544842c76ec13e9a8d630bce3aedb0e2369f5d2d01c578d91b4c2aa9e405c723fc385a77f749ac4d2c8547c139f52a9ceae1e78a492422997f1e48cbf3477633473210df120db26788d3fcf4d1ebfa5df880e1143116988ff2367035b6b95fecba9adc4cac80e4a96f2a6429798ee77173784590650c1fdcb03638933879710edea60e1f30fed06b5bb266e1f5cc344e93ad9e628d5efc9a6c0482d99bfc3c7d1aa984c7fd243cd55f08908496f12364b1868fec7ee93c1cb909a59c44665b6f3cd1afac045d023c10b6ff8b20378cb34e8fdd8b6b4be9916425ee6b9232024acf68bca25de78e121cfe240746d9e675a98b947a80ec56e6791dd62fbf5ce8adc879171a34c1e085d1726957b240d20eab9627b502656df14f5747e0d525c77e8b999552ea818a508e416d6cf02dbe8f9003372c1112390364cda29ea136ffa2df3535341e587c37d2dc213bb77d91edff6a8d11c6ace839d9041030d69f36e51ead1967a4f1d5ffdf88985c7ca1e37cb9daac984a5c972a2c3af9a2b1229b644b44d8fefbe7830436e6fe085ae2610616d1264ed77aa042e4aa2ce17e60a47a1e9df91dba06df97961fb205e69739fa56e37519567d7f25a251ae315423558dc3e64a4f3b54c3d296b1e362b941e730ecb9b92c94f724cdf53f44096391185075c4d908199ec065272f65ab2b4806b03905e088d462ae55a4be64ebf4cfdbe47709281bc6df7b21331f995f7e30a4de8ba84c355e6b5c0eb8801718b18303c01050dbd6410e898b38529c324e0c95209c879507760121d79f38f68950519680fcc36be10497bd779016b42fd05265d2b0e5d4bd54afc558eccdbac4e9ffa486189d7c531fa6519e0e4773eb4ad3e608c550015bf497a56f051c0bdaaf81f2682b57e56abcbf2e2f52077569b4b1c128c7e0679ae6db3e857e580429581a96a66ef31ea60eb430e61e2741b952024fc53b0b7f3c57850fe62049a69c1dd8bac1f523ac24406259b000464c6c0c6558203dc9f72d3551beaafd13f34a0c63b236dd6de3f1efdc18e2c5b0f471810adab11e7b8e941d7bfa7ad0e0b42823dd92888f4320445db55ed528bb9f7443ca27d5fc8ad7425da79a0c10551dbc9cd822879a002bd6256eeec7381170342d551e36c37300b3329f1f83f72bc666137242e5128d61f4016c50cd9cf880bd84a30efc0a408c40b329989dd3b155553ca3991894f33ce400419b68e3325a3a4b8f10478b10665c7f8f77447203401e948fc396075102c04ddea62b58d44d604e9f4107f3af66051e779d78259aed8d9469111d7a9d7d43e1a1128a5cf4192801149abeef08ad95bbd316315964ea4756674eeab1546cf9b36574e85b237230c09b643586344da1e5967ad3fdb8a3451ddcb4fdcfe1ae0fd3afc0d7b65fcfe11131be83cab9d5fdeb68e1e6f609e33cbba3171356d334bbc2029aed59b1f410c455f974d2dce5f73ec572474f3341109ff174da13feaa35febee3b69101a7b64d22133583856336d582f09531c7349282602378562a03f7432ea6c34a3db7df0744ff7e19e19427d1846860b4267e56e2f78ed63183b8ea16b8232188320223b63853e1035368ee5c1cf7874490f7e107feabce39c4b8d4da27eebccf08bba4c695ee2580e03ffefe96a8b811d304bf224032782a92abc54c19897f1b99e0574bfc944fc589739f9fd58938deb76a9de2679bc6b095deded3f677630a2bdb82d8aacacb8cf5b534f6214ad533fe02bd9478a8147e92985c2575060c322d69b0b887817365c9adcebd82a1dc1f6b27f311311cbbfed95768d519cc7ad4d3a0aa1d6adc010580b4ec25d13dead78f30a6150e71d1878715ce8316b19771f41950bb93da71fdfc945b660277beea77acfa18d7604f7bc46e26107ce2d99a444c1078ea3a4f20638ca9d002c418491d37265480e9ae12395390c573e55b28b6a5d3b35b4cc673afc80e81f42524e51ed6ed580219be01e7c1878c53d333f10fe09b15a51e2df0db3f492137c15637a5e5ac1fb19ee4b17790a50af181f107364981d79904927e9f55ace4ea3386f9dde86f74bd3413f6563d6d9b8867a5c356e17373791c6860260bd6460a39d082a3f00a751927606f06f603d8309477b8421b83f95a7e243d6f3e443299524dd19642417fc1839f53a25e146551df5553f2742627a59745ca39f6fce2ae87b95f1747f613feb5c60c3bcc38065c8b4c74ea785a196b7d285614bb226d68a05146e61e938500b57aa7167dba84d98b7c570b3348ec9116a96ae0d0b0b3ab4f5affa919b093a4d59d26af7bbce5629675bfd20d864535a980ae091a51ab9958ba9388a893fece102d1ad6a0fac1096ba9869b380b2a7b0bf31a7779ce2bdb43b9eecba548b0dfe518d1b48137702a83db61f02b5db5c452736bc22bba00dcdcc8edf3df7d3f3a31a02da25ec5476946a4f32a8fa093e9cabb7c423628f98bb146b88afa15b016c40f5430fda123ef46e787c0e8c4085a9cdd8878b0a86f1a0c00c69cdc3262f571f2392278f35a01c4e57120396e07be49c95bab500da05e7ec0316f66bc3f0afc073018087aede27d17ffcec1b20d1207f99901d48cf6b5193dba7c72722576c7269d8816203b03ef21de6e4daa19f48a48144d487a153a057e7b1eb8174905af09eed8292c3e6b654b0570f5887e211bfa0c59e544c50c112c86fc1f6e829d6e16ddf9ff852c87412f86571e9549176435289e38f6a441edcbd5237cb5e8c3b478dbb7fe2b2dca6f59d7b35521b98a4e5e2052fae9ab2cd50fe864ee92613c23a875fa13aec883ebca8413e55e14e6ae2d50e95641c7098dded6da4bcaf8065b0ac9d907dcca71e82d4f71a669d1cb603396778017b10f118c9d429034ca89574ed415107348406b05a3a88ab8c4968e7af32502a69924478b093b7a0a5ba9d1392df027e4dee20dffc551c280f4dd768f3f914e1627ba74451c6a387046e893beba9f9f8d0f6c8b8e7a7c588f6597864e35601f9b67645590c5ab5979fadc2e3732fc61887dc0f2d74f2d9fb97e0de1c87594d8a1364193713fa0f9a4d156729fa51c51df55664ba68d7c2a51cbe121a1b6612c5589e46bf3bfc7afa5006e89df83276433a334f3dfbf86690ccbe161a602d8c9ca38d994b3f5464c8c369657f65337c77efbf5f0dd0cb6c2eaea0e4344ca10c2e4609bc49a0e45930e93068f1fa694a22739c4633736bdd94992d49c3afe6247f0ffa012629dc7396dc7c6e3a12b559e8851129b1a46ab8708756aa49b33deb0197f840bc91fe42a90fe1d569ed7ac514e3b7c02b997dd41dbd2d96bae50610a7864989b761bed8b05e2646d263fe8464efc7737fb0329f3563342c5cd828e274868f3d1bba87a45696112ec7b05fc6294e8f7d68d3abf0c0b7b65e567d3d89644ed03c25e3bc732bd49aa349ce19160bdaae91422e3bb29eec03f31bc901ae27f062390bd85eab1073565ab5fa0117cf67d18bc3767b21fc3eb962f80bc429c07f1e5208a94b528e2674b530d7390be0ccac2f435e3a27324ad568b53cd0e953cee7789e50595b7f0a81622e322b7bd4221090395a16606fa0a7287783483b49d684f084c69196ee6556de6d73ddc759981ad4d45ab7bc4d30bc757fe2a2593bae788a7fada66e89d370743b2a64e0436106f9eb3974732a03377aa41737e0993e528dd881466d7f74c3c7c1345b7397bcebde6d297b3abe4f157eb9bc47bdbd5b04730fca27bdac0680ae372d0e945963e3f413c70b1b1a12eaf0c62e41e8e55c9f4b295a65a71a26c02d648f8ae84357a38c421dbba83b4850ebc8430cbd40a3f378a71d03fb78305353303112abf348f553f1e576bf3bdc8993163df84d01858110dda081587a5d7ea7f7ffacf326873c1ad5a6efb5e4541c5944772a2070a8852ed5528486aef43c29c53bb8b910714cd8b23dd4f194d9dbbd7017b02628ca285991275edb3dd22033377c1e00ddf3066933f25a3d85896b8c36a8eadcba294ceda34ea489852afa53868bf06471eef94d1e2c3f7d01c14eb998ac2176dae713372b6cec3633cc6c6d669647c72a28f05325390b1d0e50ec0e8a3e2d94d00dfff278bc72c434de114cdadb1c5ec5789b7c2465a08b6f8a06ee068383fad89ab4dce3b7a4b773bb2a9b8e883a48bdf3750b50afb232e5ea1ab1dc98ff0525f9f5949de1265b9c94ef49b28be86ee229df5954cfb09dc0abfcc4e58dd6ecd8a7ba04e51280d6196bc23b1956f9fd5506b8b2f73d2d5b99d6b1b2cf11ea09af40b62837812c9e0449bde4c38684d24276eac491bbb9098b57a5233fcbee650fa0430743069f1ac876f717b4b080bbcabc62d47d8201fa5991b13995869b55ed7c3d3a2820b209e4c2d443ffa23d23c93a2761810eda60485e91ad3be544b6b353ff4926237f6a97334f63936d0f2c982eeb43e0953bfe5543b5b19e4ff8c5d182b5f36c77ed98e4b3eccb8c191a11ee045f3845e9e6c5ce3d6e20afe14a63ab104fe3ea473084085a07f396136b48db958a46b958f8cbc024f5b5f55fbf0a07dcd449b711d007cb920a7c09d6782ae0d3ef1fc59341ee179f3ea604f27d0976d7889e95e9366d03992503e3220cc0765f1a1826b0f112798bd64e7f8ec44ec8a6b21e7cae3030935f2abb43ab00704f7879ee0c51f9547bfe1b7a2837f451fbbb0980848a6928cc419f3edf45d64e9d9b69ff4a6a03f268a5766fa39a7f81a860413b80810a45b079e0918b63974b7f5018768922c25f299e5f2f05a945e61c4ce9588458f8d37d151d094f12640ec73103920a2722e6dad7fd5a531f27f8fc5cef9b01c5ac5014a49bfaf2b8890fb378452e7289eef013a068f7de4344751f429b9277788a51b7d762c37b6c64d5c60944142a1e1089fad0e1a4d8eb63bbac9df3b03f5bc45b0eb95360a2c800d0b1cb646e53f9a9a598182235ead754a388dcb43d4e8a73f336c00ddc7569f450b4f9b65e3a9c91f589d76c7c9da4e6264d1af25b360db62cb22c6e957ac90922140daf8458bbe8c816f64b852ce3ad3bc7be0f1f6340d7506ea9dfbc9d76666ffa5f69611d26a28252df181933e2016480bd7c6740e9f8801dd71a015d31e5258e8a11207bd66692f2605dddd2d1624a26991b8f3b1f4e6f4bbb8e519578991c0d08289939d4f584ff7cce4c072d5845fc1d742d14e89fcb53596a9d03839f7f0323410dae2495e1c222b2701ed85560abc10739c8565162d990cb5f4570c006b447befdf62370f62853fd5ea7b0655c7e6c5786ba287f474dd9d8c9fd11c80d53dc35b66f498303459775f4d5c746a46b6095c1b9f8bc68b0882cc35c00ec005b7d518089266263ea0cfe1aaf5998172c2821dab8e46365bd76d8640273db2dd0c0109fa41bc6b6cd2563e5aedaadd314733d941bf6afe8227aa97e1c52692d1a1fa02202c8fbf2e87d7297740900f50837b0c85ac3e4427d10353fc6dd64a36926283edbaa60316484cd4c3e6a8a6ccbce85fbeca5259aff632bc9f953853c50bf73610ee2473793ec49901696f635d229d5103d9118200ed23044a47abbe84720072776ee57a1a29185c7a5f5081637b80a5860f2b2d3bc4b74061a18e54b26faa0dd7c6c261ddabc0f57790f67e16a7ecbdff2985005012cf61c3bec0336af579b673d1a175b2fc1d383d424b04bebd45cc255df03acfba14b19130109264e690841a6bb11da6ce8ac6f7f2f2344ae7ce69daed3f3b27b4fa64b74e65a96290244a8d4fb469d074ffffb859a85a6948d71bf1cb41f2a7a23b6e30015575f221a1e4023c41d6a129341e852638f39f3e3b615134b7cd9c2bbac5a6ed13cd941cbd98440ee0d3834f822482cbbdc985b1cd81df88c453a91421c8dd10904ee37d767fb5cb2cf4c0961f691defd5647b7de958c2bf46f0913a5ec2134122bbd2e992045ea1e31732b4521223843e9b887620205655d1bd9fc5323b492a3130f47b531a9c3093b2827b16e4c4594e212fa4a8fa7d76f5b8285d1ba0f91333ff203da2bacb2cca8f477648b932bc28966489a5ae3a2381e437e561b37373dcd2102e6bda5eff33cc3ac34f0f994c371fd9abf9bebcb28081a73d40a8a33600cbb21bdac5d901a10559813235c232a69ccad66782530e4af71b1e3082475906f3109012dddbb82710bac03570a157f788a2d528fcd845e0d53cb8ed3bbf2943416f7a4cb464f4e047e5296f3f3e17162a309f7fdf2ca7481bb9a846ea18cdb66948ee62c97c590f142246ecef6994f624083722f673a7aa8ed2712214e528148f4f66c2d8cd6481836e6ee2b69756be678dc3eac3459a52407b382b681cd0689e160ecf82c7ffe971e76afc39ea9fe83ff418335aaf07ca75bf6b7e08eeddac6eba9ec4e5c220f85efc9536ab40aabbe0ee6b0e3e0a7816a83bd44f0293c40122f8f9729a60549fa9d8492e6a984e7534f851a610b0e2eba8d9005d06bf2a8db0048c38190cbd08583de3375d2bdcce7fa5812e3b36600e3bc9d11abe5c9d5ccd565e2a44c3be12853370b262c69990a5d44113551a1f041451fa1ce03f1dd1cec8d3c58df31035c49d16292d82593d65b464bff1ffc1ba2b570dd764721e554fbde61e79ac831331d2e2fda383931ee3edada8f28ba5c7bf6d50388fcadeac45ca366251106e05aaa83e3bb0dbaec97e7755ed86cf14b5c3a4b10a122c375592090d209b89a77f16dec10a73a8ee54d68edf0ecac234aab10e689a144f63cbd5c3d2cab6db0f7017d5cac774d9a87c6228b549e7190537350f42cc7a21ec3ed6c9db1ffa5c3b23375c7c24f084fddcedcc73956d30c2bb9d5d6b4eb143ba8b40288ae504693e806f992dee2e5ffc8372053ec659ba7d0c72b18fa325c2017e3ef765e45f1ed276cdb64a011dd7f37dbce62ce41c39653c79c9df78d565b8af00163693f0f3e5adb4439a979ff50f90a29b181a24f50e68f8ae2f2d29518b47c2491b22d7bc3a1755d8e85b3febcdc3f8e7d304f3a22cae8e5c40d054f1c60b6157fbf640f12e7f87bc738566fae05a4f49f55bea6b3986aedec8e2cd51dc9e5a16f406986acbba29ffcbc8911649b36eb74f8b7663dcb3e9f30c513d70b38750aa3999c557fc9fbd6e67a6184bf76fdbeb7ee24a619c1d380152340fb264db188dbfab8a9d7a90a4264a72da51549d0889a89a8b945628ae0012e6efb2a1131756cd2dff2cfaa17edbbe910668ba178f0c59e4889ae351307a52afb99480b9a2888e7da322b1d832f896ce5fcb794e4cfb829eed1c346ac1c334b5b79c91022f30b22c36da5ec086cc59cf2479298c0fbbb0130e0d70fc5a53574060bf33142b16d7b3f1a96e640f10f3c590c370eb2ae8e77e23e4576dfb88e4f772bd658fc23b3afb47099c6f3a9002d19edd8f473c067b32a2cfb057b43d64a379cf1db7324bc576b69d076f1c3c5b7ad6c6c6f2907fd234cbacb8d614e75f63eedc0afea82aa368c005fc12ffb39876578127cd5aefa5a4447b51495e90d643d1a5d913a2aec3a3b6fe28344b074c116236430ea8e95f014f4274cca5c40345025c3ecce48554c2bdbcb14a4d833aafb8e531100c26a57f1cf0418c39e5944895cc6e0f9d45a32aa596ec765a9cccac712de23f8ad2aaacefc768ab6df9917ce8ff68484f4da9fb2a8eabdcdf2dfca0db48a05d72ce34c2d40cbb8c603d17bf5598638d15f9246b741a5798443f784482737b04f9de27e1fba00a528a2090cd8f0feced14e8b63fb86a042ee9a00f2985a59ecf855eb1ca4e6922b4f1c54a21c85dc68ad60d9c05e45a8a5af852d80d942d0a382ef970df0f9acdcb52776d007123f3de8917ca90042cc70ea8b471b0bc3885d7a4db24af208a3fd966d5fa2f5c691d1ed5742599b9bb185d9b4a0b3a561567239534fdd2e0cd1476347e4bb08faa03abc98c1133ce28fcf1634f824e38525cb1de8e10f61adbcfb7187b1a2fec2f92e0f44fadf9a046feaf47ce9e96d458f2aa6468e0567a70abc5ac1c5e27d3bbd20e667d18912c30dcb6c21dbdb4ee42c83adcd9601ebff66a739fe7883b1ef5a13a9df9bdbcc8a9eb97adf2987f90d13a9b128251948fb1ace20f2732c0f38328ed3f051c9aa974a106f09aec6bdd9e48b58dacec9d70c89c432baad4a71e417ac34bdc1c9eaa76f0eaf7272064a62a41ce2597d6b95ac7c0105c43d71a488f575b28cc23e85b153008562b90b3e40a044767e44561eafcbea1c7eafad87d6a771420489930fd691c2e792a5c41af4c21a72bd07349bc7c263cd8bece9e0ef67a6525e16d62e4db7fcfcb65f33bea97e408c36b747821513a03dc0946ae57947bc93d01529b2b5eff48c0dcb1e7ad3c4c2218f6133b1354ff95641f44cbcda069b9f505033dab888f8a9c94e9181b3f922d6ec0ef11a54bc667ab20091c55df8edbdc5a0da722ac59120134ce8973a350c8749dc93df00cd13aaeca2e8b50450cfc02400f2c78ecb13f96ae7553037348d7c0949d01f91aec5fca06845057f02bf519503082468745d0555e201424b7cf5908feea4e3c0a79903256a08ccfc681f5f4c493ec699e4c213a0c7c6b1682016ac5b35aab618a68d4b6ef68782b96331d03a6550335150d6b2f4cc2a204dd15f51409eb5332c3d7feda1fcf5d8fe4f628df8732de4bfd7679f26870657345956b9046874f4ec214044d3612ea94cf0279507fa3b57c4d25dd3c9e65bacfe0cf6c1f64304ce217a131bcee0b00edb7b25371f36590dcf8d71e9ec34a4832db12cc149176889f3c36aa22ff54e89aada8db87f94bb78e639156d30ac7073c1b7eeea1336ef5586bbf8ae162c0fdb46bc08a5ebaae7a0de38999b65663a49828df073d7ebc5b342d9df42ce3780f6c9c2e04d9bbd493d0a697e959d98fd0f68229497705dd9e569f8c31e7eed5313816df14427303c03d02409aeb902a37cff3684e2684f84fbb4f0e55c4876963e6306acee15c1ecb58825dcb6c5300c3a38b6e065434247733d0ecc96ced19f2414c766d519b9723797c33b1a69dbf69e610a7eb24afc1f1ee41e90221795a011a0d817fdf76a1004cc6e11529afc2d5b0437f6d8416f9f703fe9beb1ded52b6f6ffa0d17489c6749d42508773c75d0c73ed620189e3f2e669d65f8c73fca4572889471da4c17265ed6d9a05d3e0329c7ae19d6ea87fcb481ee0fce52f52338b891108cfd654231c76c04f583322b19fac00281a11ddce4a985c90510562c4cc90a7e59cb5f03a047e1b3ed80ea5f540a92bda22141d56d7893bd2062299275e7aa72970031642e85d5b48b6a5c52c3ddd60c45efc4a45fa46f84f269584e81b1902029952fbb7e7c5d1268edf496c1d8e0065b9b1d3610ad35c833450292442489c45a021e722b0fc92077aca3146389e4e9104915b55a94e24e7131cc7d89643c94b9577f27a097615df66fffeea248fc7fdf95ce031d7c52a6d92003850d496f08578c4b96e7c5a8bf129e99bf4a1ccf028932421dee46f6a40562d15ffb59225695d36d33b3e98b722d284c1f843006129f0629ea8fefc2c5b4a0ffed756e631723f4d59efc3c4c88b69857d8caa8503c8c341343abf94716b0d3b6abc514aad8953a7884abdb1b029c47ccce15f501a9a0fa65b2699ae22d261489dd4fb0c67790ef8cfd070b1c19b88af8ac7dabcbac72ba22c6eeb5d2c13e96418a63c2b7b4893ed2658c3afa382ae31d59b8e687c50b936c67ecfc4c01e4535f187df0fd6c79bef087df37cf4c7268aafa25e872792772d884b1c4915806d42a2f89f185a84e0890cdebe7de0207355e5ccba1ce594978a5a44056e37a4c804255f9e384d186ed6b8aeb9430a7514571494f9fe16c6cf296c6ebcf3f338f6e4e3594a429e37b647830857e679e5bff5cc73f1ebf011b06acaa54bc91a53c4f4392a1dfedecfb7dd771ffb1742d9f9b7e6a5d569cd2c41d5a25eb8c7bb537063514b09dda35fc69917d784e23abb21e0ab01aa14e44cc2b45f30b5c125e0592cae70af1daa83a32ab20ea54f2ef44c9a218a96b3f8edfbfbeb1f36a04514ad5f4e8e6e18a7161ce93510b8e266c8fb497cf11bfb4be548f0df2e0656d12c510809553ef87df6908e2fcdbe9a0d144206da0373d1fdf4c40a8004c0b7d47917630c48a2c2b79fd7ef9d4828e3edf056243350a6a81566f1b84a5b6f7df5dd14ddb873548e796ddc356c1e0546ea7a5461cc10eb8326dd3188abb66f601708e41f9efd690055f588528d60556c5020242a6ce5cbda82d6b2a1ece6dc8ff2c5e80d537df72c9507b7835a29402c2ede5f8993fc34f211e24c999b5104984170281708df3fe0ba351ca1839b7f56638b1c98037690c50d2de12e6f1a660866a30031c78581220194b8279afda28fecc9c639efb24e400164ca0d12bddfcc03d140c46d69615a52c446d4445a6634f617470a93a50e5929e7e6080262571f0fbc3799182ebc3e3c8508c45dbadb3bdbe800a1cf8aabd90952af18d223e41d816f48b2448a344970c906a2b3c3750bd70a5d1d869a1adfc50bef8ab09749f43e67759f99c29b0de3b274bedcfb7b6e681bc43fd18e2983464b90775153a41d2deab3ac72f28e8ceaa9b584cdfe0495cca9f89352dd8d77adff4ed7fa7da252e2964293ee50d71ae14ed6ae391b438a62256abf19a57c8a2bb3ca6aabba25d7235a11c9da6bb9d1960583d2538163b888ff31bdc118edeb0f086c775b4dcbba6b5c39e6418aa62a5212a467389e0f4b20a2b9009e850f2dca13ee73aeb78ee97bc3b163ee40b13f3332214d7ed1e44ad3d024e28c9ffcd76cdb8eff449405d76bb2cf88a982aff11477027f35cdc3f544281b4aa9bdc4fa70a70ca88ca1d7576f52d482027d19f3337af699b8e8dc74177465e98f71dcecbff792f4e96844746fba1319498257cad10fc153fff47c6cda18d772a9bb16db7c4dcbd8979d10135f29d215b07318534f115ee3bb8cd5ae5f5112af52a534f95a2e35e3ef5922b317ec7ccaa004a7f963f6e64e62a584b7cf9a5995751ae0b4ecfaa2924fe1b641c7ab067647d8c74152a4b82967ca09fd69a60c5944ff1468907882fce81b740b9c968a2816a131400339081cb326b65debc2fb43529bd531a54b8a755aa6c63875735fa28ef273cb9c6d9b0e56ef71c7c3d22ac67ce4d499a95669bfab3de19c3ea1cdb245cdd21b7f520ef2446c78cd3d820de8b8a734ea3441de02f592fc4f406b47025e87e3b2278a6fc353e73b4fed745b8562df7a9908592b15cce574b632403ddf87b6d7a620d7fc3d203f9f00833e9f8a3c188a41b653ae093ae47d22a03b84a9281f9319a16d3aaed476e0cc25256060fb923ead99a5723b7ca2695c3ea7cb0184a2b76e283ce712cf77783237b2ea4528a0022399532280bc17939a1c3cfc886040a9cf814285e44a8c08993305400e29ccd09af4da43016c73660306e8ffbd7aee4b04e730cbf7d317f4958ad31e0cce6b40b3dd1e4e0eb4b6902831fb35b23a693d1d076c10c751d650fb0f2a69d243f823b94d938c2cc034f56f0d1dacfe809668cb1200668e6e5206a8a8ba6ab5dd8e4e8d79b5c0cc3c17e88de640ef5a9a06fbe120963949b1d8839e7cc5a98d890bc0c57d2f6f10bcc8368fdfb926606a1d8653b65aaaf6945ef863c9e8bd8300930376c3c9dd2c4846d49b0410c4cea85e433b8edb7aebe4a59be196c57664ca7be6842beb65946448d868b3aec82276f5acee39d3a20bc78a5bd566b1c40740702c4342f44628ea26278f289940ff14badb706b905efdc7dc09fa06420ffe81483997adc71d94491522345afc6a4cf4e0d591eeed7932f6457d0df59f964ee615933dae2d1357fb51e77adf5cfa79c27b670ee73277b2c79dcfa478d8b5de7c553c4345c4dc740662c2e8d536c5b046e097995ede73aab4642d7cdfd642d65cc3acd80612062dd5964ba4940263c78e35b7af67efc701065841b98bff78f8a34d134ec3ac866791c04c88bedfc9f347f5fca8c3bdc276c46a93ad89c13465c81353059c9bb5694a3901d2dc46cd6215d2c666ad51988dcf00b4cf414178969720129ea0cc80c0b7afd672af75215c8d40bbf1f020bd70db6b9c7c18b6b592a527dc6b3e78d169925ee69137a41f2da020617b5c22a2b5773a28ea352101290f5955df08750697edf0f8de096ef685d6687a8c0856a88ee0d9863ad91938c724c2e50999361e70d50dfe203cc276abd5c455a60c713ba1caf7619b4d6b9dc1cfa5485bc6498b62161fa8ffdc960c52441d6cb454644dfe309729d319dd5fdcaab654a28309ea0284e7436843f03d0f82fc407299ecd065f4f37ea2c2ef876397ed9f6b0c44d1263ea76d2d9abf318e934fec59a87f46b62bb120c891811b50a1fc4c50e0d3c89e48c506820784b68cece48d9d094fc6d4d244ab4e2865e0bc9a9a0de01424c3bb557a05ee54c44c78f5988a67f6b819bf46366046452e23e7c061ee0e61ea138ed4baa1c3ce49691f1792a620a77def3a15530fb68e599ba290aa48391347396d3d80fd05bada162915f9b071759db0f2907c603ce32992868d8c481e89321440e74a2962e8a4e22d8f6b71e0ec2952dc4053d3392ae383eee6d18c8f6459c7d0744684cbaf51dad14abbb75d4e4d449e88da470cf00a49c4442b34d309a15e93e89ac7431814df5236d72fae5bc9f6fa4d1f5c0b5298a5bd925cd9c343ba4e344fd7d88946581f101ef302345bd49d29050241f1b6145845fa106ac46ac8a1230bc73b566bb50f155539f4654bd21ce730830db12823bb3e1963fd15540a94696e25990c12d2f5d89568955dc9ad1a53b89c7a1027d3a6d2999ce128c1052748a572239122d1dfad0d587aead931b818a894477d7ed2cc4270638e4265f899596a741b6b5cb79ca6f423b0e87c52f86f00204a028521d25c969b8dc7ad74e6f687f424a9b470ebb2f0d83e8e820c63fe394655bc694e3117a2f42523e08d31aeb67fa577ab411ddae0aa09951d172b7729a13463f9a2d614b1c9750b219d333a3639a5a1ce93fd59409e8f7f670da38ccb52dcf3eceb5bb2a6f0b6c011ff40f9b6cfe5281c1fa4b24459cf31bed257fa210ceb892e0039309dc10e0cae37b7a4f563d964485663b225cec8dac8e069572c4662b892b76df2595bff901d8f22b0573cf417c6b908edfe237472a9e6a7d35d7a16df0016474c3c9643d9396686a70d714b96f758594d65983f0ef3f87378f347ba050aa97a20a1bdfffd8669adeea10413515121e7b101446220298ab1ca0c40120db505bede580d6d212543bd6346354ecb8eb673d729e7e132025462fb6f7f9b9fea96d093cb72a5558589e2031206a733ba3037b2338026707b20f9e310db5ae0dd7d9e2ce026d57788d9091b83a810ee01700c2aab097e0afafa08cc4dc995dee285deec8b542098cb011ca0c2d4ead60d297e5fec613d54c05a6c20b4e9932cc4bb770c03d3290ccb6e86d4d881b1d63013f8706c1606855f406fd5e25cc24d7c195a5a9ced4911e4816c4e5ef36e999dc3de549d87d230fb75ea886ae95b0a02658cbf4011c13fa9c5dcff41ccd02037b8424623dced19c9137fd4201a28e73416862dc8ef37a3a2838fb8c9a83a4ed01fcfae1aac43aff334d9a5f72303a04f9b11548d3bd825a121360970a79162d87aaf298038e192ffb823e9286cdf3a9da7b1eea2a693d5dc1a1566e7d90d1d1d650bd3aa2b5890bf07abdab9aaf376e309312fa8384d1b8561582ba127f31ee93b698c0fcf9878c0ce2fbd2408d40b50226d17a32c58b041924f36c2477e1511a5cbb99a321e1adb5fc0578373e9a5e24c77a437651d7993d5bc3d16706716ad151b9efb910fc18fe0ee325b826f6699903e937b508d2751aac42762551755e1c6b62fb454d86e1ef964c5864683da0c1467cd86572c78bb877d7138be951c2491d7d761feeceb65bd3e0ad3102b5ff79930dd442616bf6ab8fd7c6919aad97ccdc7bbf00d0a3f3625f3bbc23cfcadcd44531075e95b3c303ced8904008df14be05b7e4ba5ed20118205a34cc55aac0aa7d4a910cbb173039a5a41581bdf0d6b7751ec93460373678ab316016dfc6208b9cfacef87dbfac7e2b80281bd7eb8be080a4f2815b03b3b86765694c6d8970329d5d5dac731517efba9e3dd8448c80e07c134c9814b0ee77029c4505a87837d31c059632f13b76f63cc1215b74bb370e7a6770f487a6f0657f3a751697131c90ce8d65c6015b27992d4f5c8aff3c772183fff094f8470f9bac58c871b9286342aeda426ddb7322cedf06a962966b60d933f0d5b30b2f3b74a82de11a64d3710f49fe6e5e2efc0a09ade8b4a1cc72cddec253832eb76932df8905eaf2621b9ac70fcea3ea35f28fbaa188baeacdbfee02d584de08e91be25e0911752d5bcc907030ebdb78f8b15030a9431ffc5ac4012ec75ffa2dbdfdd5e359ea6b6752c8c45d4aa0b7a8ec74761ea68ec9e1b367fdf8dfa79907fb0a44a6b880fb9bffcca151eb76a803366830c981fda9f3ec59be0d9b798b6980d3ad19f6d2b3cc02fd5433c1a1aec560ea5261b60e524850882d65b98ac7c4538b9b5e591ffb963523dcf47431e734d2cbefd5a467a106e72af6284b85c66a107f4203e08ece504de9836c19269ecd4fbd518f88a629492366675e7dbfb2821409abf35e3a534bf503d212eb895f945fd4c8e68a3d37d43cc49308ac8c8ffb955c96ea271b19bb3a7a574d13bf8b35a42a1c991624d129d52c459973b878bb15640fbde939d0bb1baeefd927eaad6b93f1e9671baa6abbfeb62e824dbe7275c6810d5fcc54a0fe8605f4013e4aadd7b07188eb7d7a476055feed0e7af541874ab6b6a82302d350aab8e60d4f289d3be246df00232e98efc091b061411cac1118ae7e836468795c1896196c7cec67903313875a37c848a88e7fca7a6aed0aac1b9f4cce9802d5290c7d53be9dc60a764f24fe7982f8beb22ea5d0a0dc0889d41b1d1cbc7966e5033350f3c352fb50fada1bbc2e97571f4863e70ba23d01a293cd5dc2273a6660c79ea46d6560b5f34dc802653f390c294288f7a8ea7a79727ee7065a278e1a8e2039388ce8955bd6550b723dfd3bb98e04ed6e647fab1c3b824e994edabea84212d4f2fe0e88096193361c1c804fd0dc48bd6305c3671f9700abeb0e1fb72635c2299b40dedf8b3da9b451644fb084fa40bc77349a05e8579a2c56a2cf6ae6d7471b1ab3577221a200ead89e83cacfa0451f42fb7d6e8e306185341fce056e80ee833496f8184dbb537a0c1cbef47f63fb6aa49eb36fa466d91d25c1276a84cf7e9fa918c8fc85ed5df7cdf16a3350ba6df9691c0c2dd8f3a5be87df34c8992bf48d019844e6fa4f32ec87804139a3b6c319b10293373506f54fadfb652b4fd1b203014a180ddabaaddcfb1c3d85a65b0e3937ae4ff6db36fd55572b3e801a3d469294479103ce3c5467761c4acf3a2c6d8898d4dd3265bdc6ecf9bfdb42f4dc227854acf322614e6de6cca6b59aa4b8a673c00653d72c21f910f52479718b4bc33743fc54831ae4db177dd8daf4ad021dd408c83d855b54b1285bf509c610127f0ef441f812ab8134f5e6f88c9b57222519c307c8283575d5c1c9d398815b1cb5226b4cc537203e5bd495101172877f2c1e5d18dc9a754b37c30e7d1e5ca39b419ed298f5aedf10365bc644dd0e548b65b4be9eeba2fad192bd7e9304fbec3e795257f0e0812e0586da7ed9fd649b0292ad025e7ac8a9ac971a182fad7a946451e43183344e6ac45e3cd6203bb93e983f3f0bfca0b6579904b87506a7443933c5ffc464da9ef15e3223ef89b3dd38d74f53326ae62e36c8c5045e98054244b4424532baf6a91376e07d53f9a583508bb1f06becdfbc893d4096986c40e13ba3d9666a8345489b9130224e3fd9ce8ffa58fb0691e002d7fa0aa8e623e22c8fdb383cd186715e5758416b03a9737b405963a1ebce8ab8d0b383bb0a7020467cc8b9d03ce5399b71a95ee60fda1d3e29850185268cc2b71ac72435f1566e2e4a40090a6a42184e4209cffdc6499380178824053e17c07f2b586524c2d036e9ff1952fbda24c5af8e8746387fcd009fd27fb0ea7dd3310f1bcd7f27cfc87d3c490583bece60d63d570997ad91590bfd4f02b919c124aaf5cc9106bac2830ee5307bf552baa055feecabd8728f58ea74caffc320b5f1cadfe60e1c75748c226a85e2085629d48a68f9167967c9c3710522337df45277b6c25ff9cce869f1bdadd4860139d25a8b4006eb1387263147091acae935a30388e0082ca2c4fa7bd45aafb86faa0fc7d1806b7f931dce4dab8bf9ab518eb0112e01c03e4eeee1fc662aea10a12749498b42597a962dd1856d0d2794e7b2d89a87193df250074cf9f43ac1c72b4ff44db2e37f80abb7f758a99fe21c672c80688e045a06db0aca072fe3ab15dec6e65755edd7a43e902b42706ba90c26c766cbd314c6954ea071b1839f0acb85ccb39809092f9532fc1e248da49d93520585996232f63988f8fb37cb6c05878950769967584ae6a581e1dfe29a2834ef224c92ac54011aa774d9cda15723c64465e772c5cace16373cd37c4ac34656aa1be20da225f42bf2fe0e537db9934f0f8748aadbd209566531a98a53969514cee3118462888a33b5422fee7a6192014c4cad8c38b79d38cf7d63fcdf3551ea79feb45dd1fa4e4e067c9b5e48331b4f69b28802b968e8d1decaf49ae6010d4fa73fdaaea102bd3f9a449c746cd7f9495e76ecb8145e98c48831d220ae2d298ade9e88260339b0a51e51b4e6ef57ff6bbae69070e561f25c3329092bd07f249a1a82b7a57ee4cf9d6fad05dd7b47ae77478d573c8a80e0503b781576442bc6d8ec0296f2c54bcd7f1704f7962f74eec417260596d5b38a80d4f57f63733e17060ec3c515bed56f57640465df9451a3ecedef4e2dccf55301ecb864a0e4c075b610acfde2869d20c8c34e39b5e846cf0e80683dfc9ba47d2b6a213d56432c8a5e498fca81d226e8a1a2575b1b0e265793bba4a45412b406f40dcbc451bb133f99eba070f908e6f5436b9c75fcf34721338c6ab26114520de1c6fca6284c62c6dbe8acafc857b308c676ac44b5404335f9c06f063ca3067c3f62c8412f11bcd40a6240295d7c59dc6cb58228159f7a0333c63d1154d39604ec8be9e37970b786bfbf7408a48479693720ebff883d85ee8a14458eb6b8cb2cbe8e1b67864a1bbbb262355673359e262fd801ae2b18d7d147032421d3dedf78be476618c8f3c58d67dbaa71206094878a3f2b1e64def4d3f8c079b3e9c380291aee438dfa5ce81e1c998084b5d9b0559fb4254e57a5b6bdd0c64081ce6d4f29bb5557f6976fed5381a00e150be35d514497361fe9f28394ecf872feedde3f0307a3aac6c0408926274d6ac37e06d23ed5705c7aab1483037521eaecf8d05f9c954958a5c20971753eee886aa0b225fcbc1ed7e5c4ad7545d711d8a14236c7865214e7f2a41bb1039ecc670f9fb865b7742b226cec98eed8cd5a60d8fc003ac3dff2916783b120a019cf9e4bec9bd1c553ecb8b2c9bcc46aafe2a02fb6dc32c36bbc94f958ab7023d8c7ad33460502930df3bf32ddd15422b7832eb44824f2da125f21ab544b7d22a1f7b19f190db1d16050acf25b9521f38b6daf6d670cfb7adbae0deb5babfd19b06ac9d23b61740c165e11ff6414afe99efcf6517fe1ab6be2d64effdb8ad90cf22485d0cfba6ac9fdcb60e20f591d7329a49f891324dea4f7710bb0d51d0e2dbb6bca3ae0c5fa5c59b83ba04f216bfe1827aa6b5a3d90800f7110ad25a436f35903ee38cb4a463b4e4021a85df9ec94caa11e9f53590d9cb406492a9d9c74f0dbc81236d679d6073e419d375a95cf61916353ca2f5eb1ea4e8c9a51060819a2c0df738fc8828a12750b09c0832eacc531d8d098f0856efd71fe2567fd88939d0a345a34572f272ca6231d4b6d47434cdcc526b3fb23afa6ec51f5e9c5195307325606e2434f33c07a57613417a4b85e26c675ea4c4728e362de393a2152cce53cfbdd31f90a1ee01963d1e19af05dcb5a175e2fef3c148babea2cff7d9bad5c9fd43aff2e345ccbf9889c36b0ca4a54c2c4925e1e4c207af40847a46bfd4fb84fb5b4c5ce95e1b66c5158408f56be7ab0c5e125b157fe6c72ab0c1824f0cf9e2c090ef48bb742641168b485686f705a0f6bd85f16a0414a4abdab08e31f335c855e5c72bb875be1ec14ee6a932b2bb5092b253b90e7b5f8a58cc1de3c7dfdbdde17eaafc7fe2b7ec316219aa3d154fe09c7c0f15f43f1623c2ab460a9c910bc1678831b310fac37e9b4419184757400b0e93f7ae4e6f9e1f3f531270425acce8e3eae5859e671e8d07c49bbb12faa9500378002754ae46f319f1126f8a7d672e77c3e43f6bc90d8c6035111096689d8799f8b369a28008ed7bc5435fdfce84500125ffae8e917b96f60ba8c2dafb00d6275d63220405c41278f1045db0c3044d0a19e43ee4d8561d8e26c37058b4f2751d0fd53ff0a57b9ab232a4cfa13ab862acbf489a0ba4c9220d2fe552d38a1b75aaea4cc271ba4a1959f48c950c1c33383de477efa2afcbf112ae341f53899b8c3729d7aca1e7313a79bb6b76fe820c9197148d3a24cad1d6b5268dfff9e0c5c05c44d709f99b36c72accb5a0ac18af638bfe3f5aaf59daaf04cab007e784d254f63f6e337e1d4c2cf314fd315c23a5339066611127cafcf38aa1434365256b44fbc7bd21a204d02554c450581d81ab0566e40496386631a1f58ef813fa4ea6d9e9a7a45b50cc10d538e804674f2f88bc1b4320ab51bfeda717468741332c78bcf1d35ed2620c8598ec6ecd595a8376cfdbbe355d05b5468897ce08a200613b92804dfeb7d283f4dc9479869b66c6d656327d9b6ed54d2ef9c49f5e3b988a465758fcb5cfde6da59a7fb694d9c8516f7c69ba409d0b4f09e838001c748a3ee738505260e1cf1cc1709f06d38592821a9b8f7db7179215af34917941450df4d29b48c3b5564dda894b21f3346bcf3cbc43fb8a33c94276fa6acd90c35edc777965a50a3b6d2f8b5451baf0f81ee85f79524f76563064ffdcadc5596b363bd034240f96420e92de99bf22de8ac510fe72bbb7a0068f72323f9f552825444c755d3a7106a2fd62a99447768d57a02c41ee995e56e35e3a8f63affd86fae2f35f8d0a5dc3ef67b81c165ed71323cdecf7791392ff8b02688075d5521011035e453a06989daafb9b0db3794918d9f04f61209b81c02e454f17b7fb5e90d603c7182cd828eaff4bd9b78ddc306d158bc0c8f664272d2d2efdb377ee55ebefbec5de850e30ca5e3c894fe209417ed1a50d6e2e2c9bfda8426068f609675fd78679ad0573ef4fc53c0fa0585e1f3a487dcc9d9444c2372c0254585971691a1a3e2e991bc279db2be922659012d3e59f0b84e715f74369b07df050c53a1eb800119850a70cf42f0f006b77ce2824b24a1b16de4e808dd3df1c1da18bab1256ecd56dfdb207ead9f0543c955e28f668a222783fbb43a470631d5baa81be039ab28e38c2e253b1d6a384bc57a29b4a156f09fb6a7ca7275e73c6375c1e4b91be479c32d3830a5a7c1584a51414dd5179f8a4fd9ee19220ae1f0490c30e450fc7f92ed5454a07952dd57b2f241b1a1fdaa8e01d1e267189e1f0acb365f7db2fb6e17a6f86e3f9362b677c5df7462597ec25488fed46d61b105da4c3d78e672695e152e2985361ca3b2cc19d956f2670c365f4f00cb57cab12ea12fcbb7303adba91d12311176119a60e6e7a239f0efc884d80d158847e1af06a9d5ea5c111f378eaf4b0e82facaddf312fa85078c70684d462b493594d0bcdba553a4c8be1986f077c914a0fa646740c017731c6b270e63bf67cdef1f4431fd44722b6a27c97e18c7cfe9845753b2ac4c187c57d0c93598fece0f1264340113fb46b9ae04637a443bcfea01b34309bf85809f68618ba4688beda045bf5f502f1420f32b9dc4d996168f4604e5970d9ca7c56185514f71752e8b0bfbaeb029fd2f0e946419aaaee769a289d4d91e254f91b35be0ab675b9f4479d589c8c4b0fa83acef41db1264ac47a8450370a9fd0d616c51dd43a47122508c0b30d500c71a3a1ed9a0dd0b4bd7adfe752715f28a7a3b41bf02c38640b23ce93d4d5533bba6f88cbfcd0290c7b926b018bb1596b7b93cd412d5e7b447719c1c8d59ebe3003c78ba5417d7f46ff25f83567babed67bfbbaa1f27ca25878c0d1efc28c753e3bb7336f6ae34bf8ef201c47ab5b3babcc30734f3213b334b7a056f2b958b46cca8f654bba1442b2d04046a73e604ccf6068e6c39774cfa65830fb7848c9849f56f2e3ce429ec52e5f67a3e63e1cea8504f7ce13db8083f9447b628acdae5c34d23c4d8fba0b38da61b2efcc73d4cff4ebf42c6a077e844072daefab7b2a3242e0f5dbb83bf787c2f6d0392f31b0b9955f4520b6553f26ab85dcef6ed8d9234f77276a2b62f0fe2aa1c9a24d4d698ad0ae05e1e7726b88a36f58b4a8b098c01e7ce816c3f5e517a37cdd0bba4544eb03325fb9c93110101366de465d54d32be67504eed0c32132c4c89e6abc2c43e3bb461ec983daca74ff5e735cc5565b1440c94173fbdb5c37ed9de3c4a05531bdcab26170ae7fa5b793d18a9db14f72cffad72641002b67140a3101786e0fae656e772f5116a65696044741bbaab7054261c735b6600d674984d2ce4d817ecfc98208c7be0bad1c22e0953eb460f59a3195f93fc0b209d1f2fa2c2d89a80ee916419f344c10f0b10a4faef883572ca85a2487657ae7871e023a3615ab8ff0cd1bfa4ccbb633b1376aaca976143ecc234fc556102df36052d48cdf6ea84c829394d77a2abf3660e2ecd5aa713ca1b6f7919b915db8e9f9485ceecda8d2ccea498e3008e6b067d03fb0ae83a24ee1f912bc8c98cbda8efb6c3942d91ccfc824628a97bf862efbf1d9316aa1cc50d45b8584aea8efefba3a21171be4b5e631f8d7bfc79d49443e3fdf328536684738834043b1c6de36e53a28ab59e15847ce304df0d8f0011545d18f55e2fb6d9afe4161bfd37ba629f1b96043d454b0ef7b3ce6165bfbb95f6eeff8758ef01f788586e2aeccdbce915549c57cb54422dcb2a892907900334f8d1cf461a9252a4f50508348316ad781f9634be5ca6de2d743b26379e28be8fad70c012efb96a287cd8a17c875bf9e0a2ba06af428239a5a12eca8696b6d9a7efeca2fd7dc8571c2c1ac413ed05a08ce18f35e644a746f5beed1b99ee2665de591dce0ad9cf963b5d9784079c0187b8adb21f5f48a5592dd29fefe57eda33c75e245380a96c7351b0f957a32ea4d084222552431398af5e40e7c8e78035845b6c4873ba249c138eb3ea39ef14ce507512f89ee98f6a1130b18d2f8e8a0309e08cbb58a7fa101c131467d358ccdd9243556d86e2d1923b5c07fa2f886b03e2b7fd6c1cb6626f460354c2eecd54b43d3773856ffdd97bc9d6a1d9a06e22c8a23237420cd4cd99bdb0d47221b3e480fd9d142e4675d33e7fdb37e72c100cfcbb68014d2f2619ca38cea74951896ee0666b7c121c4f77a07e3115e2e44b1d0621fbf918b48b104c6c625c4f2e408aa4a9df255e53caf8d7e902b26c757b803f9b979801c107e4e67a58947ffb3a735da62a18b9df0210071b87698291a39340bc8768a37b8705cf11332aa42edf14ac7ae61e7b8eef59a42876f6ff16436eaf2bfe77569b113ae5d7bc133c70985c5ae9a5baeafc91c7dc0c9caf5901111fab26bce7f45b8b7fb082a6efe77b7de8f6c957aa4a75eb51508408f0cab821bd4e447f411cc61899d05393d12d65ef4fc274d29e2c1fd16dcadefad2ef99cfdb83fb82f4bf147d9093029c8c0f226484603bd012e5462b3235fe1d22e1a64f324ae7ecf719f15246e7a954eb26d892af3c2d947bdcf7a5bd1acd93fb4dc21da52a9abf27cc642682bf96af707809bfc5998d519d2ca4ad528e683b52cf5eff196601f097a5498906bfd694057cbb57fe1bca8566d07855812603bf4d78c5046b8158c6d2d8e8581f07b4fbad6f94fa12353dc65beb3e7afe451607180210211a1bceb01a383fa85df35480af02a6bf1beea400acc5f6b3119aae4b149a7c26fb209c80001951c4db3533e8f7fb206520bf47eda33e83e3381a52ec83759a980e5472e0bda4ccfcfd2c75b0ab29a2c36d2ff22511a86cd57873ed243126f6b298860a5cf7e30edd150da0ab004e3c34b330dc75f26e97c06196161cb051dd2a82505a0bbdb874245778d59018438c64827929746e1ce4a3cf29ccb5d05c5302e80eb87c7e2a2277d6425556f1f5d1e26bae37df737745861b7147376be37a1379779b1fb624874b673631c31e2e5c2293e276aee3b493f310119e7712fb5efbe3559f9b1119eecc0cd3aa850f4082c411b07ae5868370762fdf755b520a6b6a3f7daff6b1a5b3ccca73a6f9d45f4768e9f9904d4349e7e4d42b90a715a0c0d9805b0d1066c2cbd44b75b95ec5efb0702c0a2c806459ee09d99c2ccb50621b7f8016b6f75e6ed1293fb5ea27a8abd09772e597b8c8f29824eb7d85603606242552461f84a535539e3b4368d18b3aa1c2de8ed0b130d700f326cf65c658c0f6379c56e80267cf5263c8cb235a2c44ba1af090bf52d066fdaf89815e244afe7b3cb1e57172dbd3f2da7682ccbbd075b54e7a594c5233b40fd17a98e87531dda2a6a2062214176eb4d2b3a3b3f1eb7140da337093075f3371bfa95547d3543d4d0479dfab062b39713a38dac0e9ced8823b27d97dbacbcf11e802fdc1ea67c4f07533712d756045b61e0db79e895f04bdba0563411a2cd36dbda922b86a2f8dfcc5beaa5a29c7bb5b6cece925943ec0e6b16ed81be295d1cfaa00ea702a6c28f71c725b3d2a30a709a5cf7b5d068171109bb0311b74b60cebc79335fe42da35c160a9cff06ab475e4352d14be32e30401bceecaaedc37acf1204466ad7d95ecac39087bacd6e3c8f108f8485b1b14ff9ef9bcc3c83884ddd576150fc1d428fe4c9ba1424a9848726179e88741168c4101d3f59f35cb0fffd538dfdc0c47f2ace17aa9304af0c84ec88e646bb3f1d4bd0de31db6ce5263689c204777cbb9eecdecce5bc41b9a10f37b050adfc7248433f2e6eb0a3a13269707c974700ac3f92c449cbce25355d5c4045f65ae2e26e8fd349b046955f6a1a08b90e08d20fe6c2d46b488a5082c0d95834209b0979a651930d631f346aef71a2363adc643d3c7b955dc96443649f15a058147175dd1bdc27462c0d7bb3834de4184dee75fa6335bdfa9a5e30ecdd1dca4027e6a2b69e03bffe63fc9662cbce66c0efc00123bbd11e21070af94b63912530b4c0e0b52d178f6acbb1934e49ec950ede802d9ebfba5813c24b35d596b0d39284de4440c021e9fffb470415ad17d3f65ebf5f4b47804a895b9aca8bc18456a8557999d183a9ae7e4599bb7ecdbc7b988b0bfcd50cd5767f2438a03805b046a1805c2ee08140317183a7b211778898ff001c57812415edc6c56cad386712f878b935fdda022f3b57c528f1458eb498d3e4ef4c31654276ce04495ff57bff9b42d355cc30cc478c9c446723a31d5573270471f74a97d2dbcf6ee37f7cdd63dac4817b7dd2dff07d8c976ee2f6ac021d1600ece357b2fc6b7932e6e4bff014470d5e566f1098fa6f4cca57c4ce9deb762a364b9c8f6e43fbab9d6ac2655fce1775140fb0d07fffd5d2717ffe48cabfcd2d90888c931ba108ded6ffe575ffd58155833e087be108f485c1989aba16f74eed7e52afd2dfff53788fbeedb3e689e1c3e1942f146093b14f090bd6cbdfec5abacb86e667b5e1b9473a60f737176205c02c85dc124036ccd5036fb91757c64b33b2b64e8d21c4e634334596ec76b4584dc628152bb2418ae51fc158bdd5d2b646ba4f0df4e24bc51d594dbb448844683ea6831ffc0e8010a94a55888507940c109fadd644cf6d62c5779f905b6edd82685e28de475551a154371b531801032c651abf9ae460e162e3bcb90187276e4cecd3b29c643726c2c8cc27bfc8e8cdad077d58adfa26d289ab9e1af2a10b958ca43a9d034fa3646cae2c7b69b31360ed2e288a3c0b30484aabd84ef739e5c2d1605a4a05f39fed0d9b9af636bd742ef847b520bf2a7b25096ad57ef08b2fd5a547c6fdb97f2720e6e14c68a3eeaef9cf614eaa9053cbdf123764c8dc262a95467ae2ee3f1ae9fc721f9bbbc96aed43cc8d08fb640782f7c1757c280cc9ea91ecb4f9cf04cc015f11e94c5a907d29a14533449a6e05450a8070c6f02424988837c612e5c44a717ef6fc2235f37fc55c1c329d5c2068d292c9af65994df2b86afe4013a2f95ff35d1aca7c4122cfc4ec6d99da2fea6de9757fcfa97744da91414fa7d38960f10721f936d78740fb91461ea3cdb2ddabad45bf17e507e56868c70ac811225241cb4b65316f950288044cfcac407676886775dcd482df6ea2cb4a4176e89738e100ec1aa607cc69e4e139082ae3ee273ce368a3e8a67a859bba3a16a34cd86e12efdbb0be0859dec0a78fa34a4ab0926539537e35d3f777b8fbe0f9969b233dbcc92b953b4039d4197d0f1e6dab3c288040daa1655da6ae31889556c81a4091c2d3d9874fe15a72e0d10ed50399f7654287a0c3249f9c47e084cef098eb6ac2d1b81cbf2eef28918f77cb5e6edd3bc88142667d52faa8197a3a8cecad46e924856070c8704e2cf7347d75a69c785e4911b25d1a637e34ef35aa95e8a9cc7ddf6072514614c91acb04b6e1e8d9e05ca7ef72b054fd55891fff0ad5352277ea0905725f7c9bb02a211fac9a6d1bbe270b9a172ce2a0c5c02ebb9b0a55ae50c2df2b7ed76c6e42850f6876638528ffe610126420e59106f1c6fe36fb2bcb94d9d8034911b5da42ca5d25ee348493455713b62138fa59a816044b7f69174ec4601e75e23bfd04fa7c87da741d713809e076878f7c49e05feab9748cabb0572447c7b1dd6e555b708a0eccfa8e9457f5019c9e5c26a8d333f959fd3d4da4c60ef73606d6e020be0f1db2452fc2c6e63b6fa1efded884b21367d4aa646b6caf9a66875df9f351f0b866f79ffe9faaf816b74bdfc302ac6b6a5aa76c0d0427cc2b3859394c2ffa4ad4d9ea9c5697df454dbbd673cb234dedc5253cb096e2626a8c2c19fe84474d399cd3407077ec0afa5e0e56d1851461b9551eb93ae6fed5c016d5138c53113b0d906c0fb7bc122f242992bac1cb6cf583caaed41b0c4a13ea67550b0dc4e1a8d7b6025a1234db1261c7a612cc400021b39a23bb95e659cb9fff30d7272c515b66c3cc78d3362cfd8bad6d2c2c9d1fe50ab84a06c45dcc2cfb83704c9aba24654e1df213aa50b5cc6e92cdcb4df6a85900278db6ae2489fb859d540324c20a4bcf8c46997914c62055b2640cca8fe3dd60ec25f7646c8a886ad6ff33adee0c5bfedc9aca6c115b2ed7a39b5a005c1bd29c6bc1593cfee403b5558ad4b2d93d01c16f6ca6a00593e8946fb3b037454ff380c567301507916f317a9b254b3a4d3b2b7f17e42436a396c9b035ede95d5b3f4dde634ea30547666dff0827dd15798c99c0b153cb66fb905f72ec612f03d7659a3ff27497e14d2f1d6b94a7af87e9573e2a2c8cdb9ccab7528e5a8b2d3c7372a1debe57a57c53fb1b22038a650bb7c08a9afec69542ffc1ea3094bb29bcf00313b783ae90ff5ff21997901469a7e9060764d9f6ecf1686a0a2ab956f444dfe171ac41198a81d85d35a9562ed23e1e81c4dc1d1187071dd4352c6057eb5da82c7892dae545564de7527d8e5b8c580bdcde930e09bad8b70e02d38d309918a789620ec05cd173a02a3ab6bc972ceac570483972955d6f4cc30d74c500a1eec668b13a3a611f29f9b26b8d919268e03ae0013955431361cb4b49485087a3d4904dc6186f1b797956223bc25ab914a172475b943fce8cb2fa5d50e8e5eb125bd148a583468d0cb123b36ca233e589208d8403f8439505ff43565d3fe8294ad779972ccd28f2f824358262a183e163498e8fdaf4500221a0768e7ef3edcaa16737d9514e7d26aab78024cd3fcbffbacbc386c8cc45231b769209893e255d7be223a6fb6176593fe1943b29711c748a010b7c03b89f736ad987fcba3d85ec2430a94362f896fab04ed495e90dd2de1fda8c67ca8336ebb9b42c424949077e741d32d92ed8fdb86da5807f172156fb88ea3fe6ef64fda1f2119393d24f32faacbace153a1de06ec19fd2ad5f8e042dd0ee2d4f4d145194db5ce365c0e81d2747ddbf8361de52e130d738226bf4ba6d1741b0ef5870598887e22ee35f637d9ee279ca596014a2d1a9290ba022443db0388a2f241d51f0aefddf0eab98ef9ea842072968c83d253ca996516c3fc7bb6f9af5f51fc9740d1800f22214006d4f84a1dc9a2eddf58285f9fc1afbf37fab696dc5064729831cb14715cb5989df5e5d4479e9fb470e8e4007ebc7ea97a81699165441d9517a1a1ca98421faf7a91dc9c181b8234005a247569799ecda6a9f07f6908c7339e33af83ba38fe3a35d42e8a22384bacd43a711ac4e25be5be8f2f0bc5f41942165421a1237be617d47ed271df51133c17168481473d75827eac4074cfd8d67ea4dab7f3417978748e136614f18c3471c431953f779d5aac92acacd390ac6cc0b139f0bb6a655a1fab7a0b5566c2fab2968c113dee597e344852bd430a3a7e4842a7ae74d977adce22290fbd6eeec31b19bd31fb64a77380ba3a015826e461a04aafa02cfee15b206e7dc3c2e47d12586920ece78baa4756a6eb49596d803f32892256791d78638987d5e5c952a74ce8bb606ef17ac1f5910078015837fe642318f5b2953b24953c164ab33b065a2f76afd19ebc467e8a1cfe188c714a534fdfd149a1a0d857478edc561b02ce8f58455c412ff01aebafcb57120bc1436ff2e1624f0e9be86bc1969b1977d4a3796467fe44ebf77099b700f87e5ff93d681967a6451b01e4473294ad9e2f62b3a84a5e5b659761905c660947a52f385283121d89907f8ddbb5cca0ac190cab2ce2e4485a81cd306aefbb2a228f5b0f1ae3a033806dfd119f912f7726ff032c51df1769f1ddf0625d320d910d99d5a738e99c312ddf3b7d2b81f460922d843b5fe9fd02f30f596b1b3a7fe43dbf4d6337bb79d795c23d5f9b72e50bd1530ca6b9294d72e8af3511efd96b99244d8fa09b46614f68d6de4bf5ce4f66aaf500e095e18f1dc5c0f225c25a61f198ff59d1c3644691525cc116785579324f7dc8dd775d770cadfd0a6c89a66090be1ce11c68fa3ed55b3d71a5b2a2c87f13ea27a7d788ba27a9a40946ba30638de679aac240787b102a5d1c3fd3315aac62fc2ff2806e92a01c789f492400de49f5975c6ac4fc7622148df0955075ff8fdd9f59d545d80b8ddac6a11e820884ace5f89a4c34f0b1ccb514e0b72e204313d0ac7aa9745d59ff7e90cd68fff5262cd0ede99d221bf5f15d2fe5ed3d891423617b5f7d2f5be0c510eb9ef7481b6f545ad61050435fc74b9d2c7138798d7ebcda156616297adc84ceed7da106864a23ef082650f255756c45e484e3db6e6f2ef95c2d20c2d079de6ca77002f6e8ae5e515a98e49a0d3f3a95a594c94110e0f1be6aeb7c9918c6d852551fd7cd707ca2c8fe9602764301fd0fb0d5ca8892f842fb505dd2526bf6f9a290d2a0e1d0f8219d009514c8170d35d7d674ed4cdd0ab47c92e1c49966dbfddef020acabf5c14d99b63485b38381293dfaa6e01a105a670c9777b7207e21267013909111216823b2cca581d1fb318d864fb643fca0bd8559c3ac483fd4664ca29892b8abf9462327fd060684f91d766f642c1fe9567aeb0918e4afe3647441da6d87d8b5c373870ddf33eb96702155744c8e550af80441da4f0a466887aa4232b49d28454d08b09a70c31817c8c9c2732e6fe23f40d88523c6c1aa8637fccc87f10ed96e8ff200499a8d22536c9dc2eff01c5bee327627602a476c030cde78a0c5ed8d7a470b6d8a6983b89ec14a0ef64d8a049cc74905efc3bdda87970759d22ae66dd9ef86e3f66cef0a8c81dc1e8120fb2e75955a976735906925439fc83ed9c29a412f739f60f85ff250a7616ee13c15f9716bd416b1ff2224dd566bf3ff428a1e2c043ce02ace1600bca9eb18ecdf13a90eaaae53fc7ede7835d62c183522275c4af7c9dfc9f53392f8714a2015ad8160198b8744cc50368520115d120fe88c0007a811204ffd3768626d879e9a15aeb68d2edba8da380cfe59e167f8b7510eb8eb49a4ac6f97ee4330e22b7e457ba174f1bb3fbefa79f0fa7e2800983b560653ae37a8ea4dd230de611b481c5ea0de2f6ebd0900f1815fc95bb52a5fbfce032cf4dfce62b561d90e2549d4e34a75a44e6f856ec4acfd492524a40c339ca99648a142450348453ba2c4f25ea8f60d4180ce60182becc63a4e1202623c8a6c0cfceefefc309cd5d8de84aac8053dbe6355f87a9fae02c6caf7dcd3726aee777853ec972ccede8bbc8f83825f0aaecfd54e9c2bf0c9ecfbeb6eda18e9b34bb12b1729f749a66ed9f782d284311769f1b834b6a3216f1e9efa6976ec02dc3cf58c49918eb9691440c9d1d8ddef8a45adbe5b84f965b4f383e5f021e325ceead30b20b8674380d01627abc9d088dc0b28417d091385771b222a0861ed72950f4300f0da3f251f68ec28fdabbde776863ccd08b47f8c4efa604fade607bc4894842e43f0ffbf460d3ad5368a50092239a9bb237c93b486480d8fbbbdd0921d2bfbe1acba3410f5dd066c618278155df77b3c9bf103775486cc4b14244916e2a73d3fa6a72a5447f571da6d057f7e4ee17a58ce6e711e0fc5a267fb6370e75f86c49ef276eeab15d876b072ba0143db019bd1633795d719376b9cff5375405283a2c6f158af71405fa6edd787592221f2913bdf05db0c80e0777001a981d3ff29a13142fde1d992f4094f574ceb2938eba5362f7877baad6777a95fd2ac4b6771c306f844c4901bd6467638ae3fcfcc28cf7b4fdc9214f163411346be006ed4939d7710f34b33080d9d7a99f8b4e85722a0d38e0f1434592407de8b8bf78f7cd41054a8389b8c4a4df7370f2159de94dcbd0fb3b2177f734aaa82ebc8033165f11ccf33e29dd03d7289e7b53903ed90d0b689a621d3334baf6198fc39511cc9a8c66dfc4ff02f09f36917e6ee8291ce6e87b01849279f7a3ac7a7309dd6bc4563a5695dd01b88e18996c5cacd2413832e2f11f9a98eb998e5b8c374dec590f3d01b324ffadaf2ec28fcb7a787b30eea3a83f942ab6c06e96a3b38847397d893f9ccda8e8c095e4312516bd3a20fdaefc8cbbd705a73a0ad3693fe620b3c2c1126d39eb80bc9b63b76c0bdef30b1080ff848ae879ffb927d57c1f4632c91cd50a9ebcddec254605c8b52c09a91b36a36b4e2a280afa62351e7551f467d4038cdf2d11c25058ce796aee7e3321b7a2aa3ad0bd2d266c8aeea78fd940e47fce8912bbd5dcf3b5bfadfb24b9208336dd2b60f3d39f89ce784e4670d77cf722029ca1d1777b86437227948f908f9c5f95f6d17d672b07cd312b1ddde7cba479fa79861ec79621be4f367225772b3cf9c5f56fdbe51f41ef741a6cbaed7732863b4096df4860dd6f79a72974087ec3ce60c23a7b4d3fe23451d8ddaadd3500fc785af44d03f0d8408ea0538bfb00d3514cdc0ad6ed551237d455ba2894891baac895701d18a8a2452783d4e39e8a6ba9f43f3457b9cbb250981e8ad7205c9b7c32fe73c3bfdf27caf9bf73c4e8d7c9dff9287541d86b1610e84ae0af2feed22174b6d8d98d5c6e9b36ade95238accf7a660a7c0d3fc490db8a82a5e2d912ef69ccea5c123adb0ecbfc00b1e6194e20e3e7346f674170de1fe9f75716975b678bb5d71a9d668f7ae7a1c7244745aec27b1a1ec90cdcc201371360640641ff155c86551290105affc824ee8d790591f3b13452e74be735f79465b2a9e61ec0755baf58b2cde6f5b104743616f7e825fc102b566615a6d6223d93b474959d0083b2507020939509d9f601f585971f9880c8079face1caf3b9b9198ee4a444458d818fb4ca2ac6484497469fb562763e9430ebe4752ce4baacd03a19d21dd6bab638666c666bb446aff9114d4c857edd1c38e723e0d826acb1bbe2ad64a36dbd891a743cfb7b2159181bc8c0bfafca07547c2c55ee3b1b699f98aaab2a76abd2f84530b55b75e853ea473f5b245b5682e10a766dc3bc17a6b6c56b18706ba378f51724096187ed8ebabd46b44c554ba52628298276500ef7bd95555857cd2c8f73e18899da202b83fd313ddea8341aa9d7fc3243f224a1e032e714b6b3a2ecc20db45ed8f59e89f89a8563c2b6b4fe0738895a711bb3aa19b357764b5129c22e2d44c3da942cfc60552cc9d159ec2b48014ea48e9ae00dd541ac5653adf5105a46be58d46ee179372df26e7a781c02242463536672b64b1978636f0afcf3a464a6d1b49f1dba4523268d7b091ef6c1111f921df7b235354b9d72ac591ad4240c1a5c3e6aedc0b2ab89865ffa0f8c57cd350211ebea080599ed7d7f3ebcbf3d234ab88c8ff5a7fbdc6af6defe5f9b7365c81b9a73d512454d19a209db4f7359c7f1f9c12c89ee8c0846b177298314cb65d18b2783859d302e03143ca637e1d934cc824e66b3fb48b96fffeb23290b92b8575cb79ed52836f92af66176458a7527f05f95005fd7bd702c6309a93633fcfa1ac67dab5560c95eeab58e83a830d695cfc35058bdb486ae633e6259806bdec71f8fdcb52208a0b453248d6e90294db47af5fe8a167edc349f71a96681eb9c51440ccb27e02025538188c93af35b6e303070f046fddbd2ebcc6171eebdc8b6d25ddda50a431a9fd45a24b18a48831b356d402e43443cedc02739250bef2c0eb99811916e5327ff31b6c01365e25d29ee2001ec5811d1a22697371a4fe85e8fda5b34a92a4f97d87d2866864d943a401ea15ffda05a1aec1237dd815c1702f35c1c82a255a64c095ef1c7f184ab2e014f4a60a7c72ff36e52a98d6fb73fd5e9037c1356c84bd2c52078af3357480a162dc85f7c79cc0b48323d9fa941de5f171a0fa187b851e6f3730ed9cdb6f0003b35404ffe84b0e8ea7b53a618d5cb7b5e5f4a911ad6c7eb0410711050630d4e620162b019cc8e980ee7c18d62ef99a5a2f0c4a45b10ea7f68ed86c0e0ab777ea6d921007401d121a7efeddade42672190c62dcb244b9523ece1d34a4fbdf5815959bca324b4ab74bc7f14f695ae404f9665712f0d458fb7cdc2cc468fd02a94d9aaaeff39c283a5993444752f826bc235d745177173bfa6d9a4cd69c3f5fb808a8ff4066c4b16c7d5d78131fa411f797b657c31a991c93bfb22168784ad6ad8e457346ef05c65ffbb5ea44106a2d3ba0007ff6c3b4401b33dc98fc81718062559ad551edc74675ff9b8d6dd3e432d84dad648510827cddfc9e31e31d083a30a4b11b1f53dce7284e867c48f069e4a400c775a514b239800a93da4920c76ba422ca576fe55b736fcd91827e2266265f2de3b28935018c3fff85000f2be4e7ae80f777d553ae8566ac2795df88af93001f6bbe3897bf166b98acf8b33b1cc05f4869d909f70ce60f6d8d76283bdf3d7ca488fce410a7fafc479200ffa594622bfd55e0535f8253a392fb4d351898752379bcfcd6fa86707883e23f18db1ba52c008c026a0627d3243a9d57d3869157182861898eee7a40c210610c1044cbca8a67472e14eaa09075e6f3ac73c7163bd3b82a19f4d33e7dcd2175332883508a771dbfa9f76018914c84aff5513797ae193c5476f3cda297248058ee073f094f14289969523d77bf78021fcaf900528fc508dece8ab5ec1534142d02d73894a85bc4ed12b51338b431e4e3b51d2c3a0cea77a5843c4c6356f07dc97b89fdf88b1b756733256732731ed563708ee6ac85892cf13da3ec0c0a81e02814de9332cfad33cf9fe0934d564bc28243806a0b11e43791b322963fb070850418d67b0c8efb8e339b983a8758d0dc85f2ddddca22a6529494ab04547a46dd4fd6574161634134f36bc8f7c7742db968ee25187183db04752874ec63ccea581217f58387a97999ef2c511d0b8796da8c343a2f3c76206cf6b254539339300a7c33141055702000362f9bbadbfb3950b7f1e0d827a0d3f9a2497ed7defd98bf069d9ecfa266a684feeda1dbfa70592033e8d85630964017abcd8a51059b09027f269d98dfccec61f54f8f8476ba3fda2991c4788861eeb6030360738e239a9221dfee5ba08f73255a6160a36fd028e2a1716a4f834b9a33d1167c937fd01d69c77bed307867033813e062b77f03c0e30e2f1a7e0503cd0a0d70655362470e579ba38adea1a83f1b95f55081c69da7a8864ec038cce98e2af9f37df010366f95c26267849dc51cd18860a216b63bf60c5feddd3136fde80f606e9a8867e6da6902744263b89d420bcb9848f031bedc840a6b91c3614caf752b295d7244c85ddbb52aa3c002c6990dc2accaaa8ea9d0183a30cb6c2a9fae48c96c436a43dbf5e810298caba57ad0e5750e54d0ef1430b7a4219560abb62490e1b530c7f669d7580f6cd907b7e76f46773ccdf8ebfb4da865df755cbda7bbc0b1171fc24af49b6751018b42b5cecaf86223a7ecd9aac040c151b81a0965d7868e8b4073d801ba5b5132bd731ba09997e26ca2fb7ff1ecbff333b1a74f5619e2958dc3853fdba96ad84eb221984bf501968570c2f57430b4e0ab49d8f0de68a297d7d7c3505ea51bb41c2d0b4d7620cc7273ee481344deb194401c95f54b516d3d414bb4f86c8c34dd1cb089bea09fdda70baccef35cfb80fa58a64711a9fbbf87b5bdd8f74057d36305cc3993982cd1c85f5665e66eebd4290da3b5d55ed1caca83d72407c403eea7adc8ee92ae2707e9e1ee82f4f01ee910f38c0f960af5448dcc9afcfd818c9edc5150abe17cb29aa5c9a13f828908b31db6a47499396254aa3e72c229df11a22f78945595c7e7664afc41812c3868f8ca4d5661856c53c9c99a41b11d99036267d9362a05fdfff48facf769572de29084c63767200a8319ce750a264f2b302936a424742753ba86b5c35c9bfcb75e514234d9e46b8bf072a7cf1b48d4267f935c1b7560168fe96f49bd8eb19652e8c18b962e5ed6a1d91d7312d855b6b958fe9db102c856037a995aea4c24d5f3b8c7b12e429630ef721194395b104ae9ae8e64b5ed626c8ffa7db0656f5d812565238d9004a0fa1d8f83fd2c213c179381711abb543a1d84e4686f7564830d4edc0f7f1e92b11c95d9270161681d3da3fb71652718bc4eea696a426c55e413588139f31e4f66b5f91d3078fcbe6c9c7638f4f8f5af39cd5ebc100736a10f942b0777ca1c56eda4112b9ce3372ac7475b598cab5b8d30b82a2644d2ab1c55cd231f5966eaf25aedfd82d382567a270cb1ce72ed9ac292a1677544bd80bed244d1ed0c7a7c7079b8d0bdf1f0e8e3b9226a181c1acef5ac0d7901797eae9edf45482ee94530f418b7b71fb1f023c256822ada1f21efa2623c42a2f1f24a68ad582825a147e6613bbe643189a2d4c3c83d04c89859a836945637e0647d0eb6c202c30a70b3f43cb26c99bcc522cdbd975a5087779adc7af48c6807249bf0679c128474e60e08198c4079b23f8b9500416770b0c54c5ed6e7a45b428ef3225419c97d77b8ac68ae0c96c9402bc4ed11108ccd0a874775e30e26f65039a0e1243c82b301ae8ee6a90c798eee8b1169b5ae676dc25002531c5847ee762158aa7340d400bcec588add6a40dfe0cde59d6de791b5ae505ade098a7ef1e167f2dd0aca421a71c940b93883a39022fae0811214d935085fb10df4d556474251d25e0891342e0e96c718397e34b9f385a8544b8768a752f71f0950a4a3bf85b4a4418a6d6ff6126e7f48ac43e7850b521ec2b573216d93b5ff91c6ac0a71e4e989922ee159a8670b7491e44b9e93c2b5a0fb73baaa742714a113c48b02da2d7d347d2f52db5d74a578c6fd9cb39a36987d9baa9bb8cc6c267f120665166139a92f231db8baeb4626551b4c3beee989a6ef1f098ea3be9bbe29ea0bb591828ce9ba86b9bad6df914fca6c9aa700eb9c5a1583ac1c55289468ce1b1daa7eec9733817cb36172568abef92543feac7554f18b534b1fd63b15b09f85bc66124436d40fdc02865135626e159cb56b609221458a7323b1ee68f7e64bf51e599b3d5d88131692f03dd345c030ecf6b511910ff27ea15511cc474372f06e5a76f264deb1294e9269d1d23eb21800c7c16f909f3d6a91bafac2e016d139160adf95afbb85b0ba00bf76e32b7aeec90a5d81da3e3ff1eb7d31c8536aa945b37ddcc0d7f0d0191078e97f688ae4a041a59dddb272a946abf254e458b8428fd6b3aa463210059eaa21cacb42171de2299ae30af8546c68ceb260cee5d96eee8abac2130b35387fbe0348808699c6b7e0161052a72e96b08958750c503d4785ed411e78693920802f0f74d538b75d22316633adace6899089f0cd5f246ec4f71ec54024cc7d1b0d32237d0815080dd5b434bfc5ac3255ae4c5beabd6f23a91e2081b5f9215da4881878b3eb9d3978f8f091b86c314ec4d17f5c592307b8eed1f4bc73d8e2042f1e13a2e4681217619a1e7cbfab376d842f2ac348ea6450c0e553a525ddce5d4a3e132d80fdf3340492d9987a0920cc92ff1138e14aed01247009a13f2f74ed1aa981bcb62ca7081971f280967fbd0ac90f611a3ef67f7a8611e2d32a678e1ab5c2225032649daacd3cc7d21725020d0391081d7a4ae14d5bff78a0d91d8eb6dac4f3c444e4dc3d33fc157816122e13e97d919bc2e2729c304694e1fc8f843ecb6d70061829aab5a38638a484070522d5ceb0b30ab72ac94b7bbb121b921790f0b7186a648d0bc9e1a592c08b5e2011c66359cfc36184d9db1a4fc215f31a40a278cdc64cd51f62c3688b1e8824a4d45c8a6ae3bc4faf284cd254d200d31ec27e3674a2bf28d35c08c6dbafe800710e303c5aedf6e3a8066070d7215e251bad161d81bbda782965a2667c067637b470bd32ce123277e863ba9d64eb6fbed5e5fd1ff13ed27902b3a3953137b10df93f043fea30b9202f422c136716e52d7d1038b169ba30dd8bd87d5fb8538da7b6e1fb08b71daf305984d7ef6735e4b78a1cd469d61a0e7eb5d19df64abe63db79e8ef55d0d25c6e0b29bc90065656e4954a0ab3d2289283bf36d6e80de923cde14c69a8cb6a6106d9d8cd00a75ef259d4290cfd5157932c3add49e4d82948b5cfbb3479724fc80d1f874bf2aaf08a23a1e6c7a0d63601fb6fe54a04860e42a4b935fd78470f987ef3e7fe6f6166dc3106ab9a78e997390a029ce57072667a501ad8fd5b34ecfd40af016e112200957de8a68bd01922977b1fc178c666062b9fe87a4e226cf6426cf6fa0f4c34328926fb3fffc663a6f4807c2f6cb2490a4bf22b61494461ca814a78961e0a3ead58fead96a6ca050511d21d7e2a97cb16db740d86ccb8710f712b853a2cc629d9abb5fe9c21e85483c1f24ec6155a5cf1aadd120f37a3f133086258f8095270d071cf74221d7b70ca7231f4d18bc5c7b34ff8f8fd18191d8b8ec43d741a84657abb5cea0963f94a65ba106dfb02f3b3dc1bc395e95d33d8112b15b5ebfc613c89149ef57e2098b922517182bf98388dc7390d0717ca860302ea389246704cb22af85527455bb6a79708b42ecd551ad5ab0a785093d4d4cfcf4fb49daa7083bb5c291e2d8b14a3fc361a845c14dde28ad7b4dd9e1a55a4b25ac7c2aeaaef17c0399c786c0a384cca9ab1eda76ba30cb0f2e89d0b7025ad5f202ca090c01e31abed7346eff2e3c3457b003eab697bd0c36adb3512f07f92d2cf1a6e3b3194d5814c6856b8d2afe3f67f3cded3bee82c4a5aedd807efe5dfed1d0f5d70077bf9be6672d2e4490f93500a0dcf5fd260c73bd59d60cf1db67e9ab60e6934218cdc9ef33fea10b875fe141415e95aa3a32171699fbabfeee9682e33ae203cfa036f5d74067a17d4920219b01e286ebdb230201855d74028b84c5c092d5d63fc86da0e98d4e29e3abfe551b195cd97f13d3566e23ce6f807f63bfd63bcc53b525437ebb0faa60f5e11c40fa4dbf1faa7c2ed6f3693fbb46feaef1eb7a6e5b501f4cb513b5cc8ef56372c189402b53895501c2a43397442d96120af3be3870f5089ccf30c910a97e851c478be6070b23e55760c0b3ada98638d19be6f4eebe97afd003f538ec4ad5fd7c02f92bf29ec3b4f2859be6277e6de1b94c71812c8e2557b65789b8763d9fbbad0625bc5a3a589211fccf5bea64f2035721fc890f1300c7ad8cc24c947963145b868bd8b1e23616084715c1f7c1cdc22d7d67f276b40a47d7128406682e85e81d5bc9231c2e0ba81e1435b6758cad2a2c13b471c8beef852906b2fffaa9aa754efab761da559c9a05632c7bc88beece16549a5865ce23e9641b342d50a9535302fa36623e78c2528fec15f05c4d10894b6b296470be291e717863999a08dfef8c3917611b106c3c0d7fcf149fcda404b001e2727cde16c68f0d2b6fc607abd2b53f37df4ebc0948da87f09c293b808a6ed408d6206492c998017f1576b0f560602b645484a4157977f42c8c06d7da44d5617aed1c5adde8cef3ea580ff355eaed2eff0f956dd235e19722d4e2372eea25cc10248a4e2f49507badbe21b1a1e1f3c6fd6166d0f2158c1b7de0ff1af7d4bcd3c97038cbd205b48b0393118d7124fa0dfb9abd3975478089b991d8b949861683d74fca38ba9bf34123a1ec8e637bb9d7b87da79cc1af39811913a4a6d1f12e98907fa863ac80b2eb5f7f7c8353dfadafec1286ffe9126bce1471c700136678c6472bd6ffbffc41fd080160bc0d4585ac70d5a41a3c32ffc26e385fcc3ebc20187cfc62b518bf93dc1a74bb59ea1b2ed59da46fd83d496a12645e037323925e0e71343b2e9a783cffe97066bb956be4c631ce06d31cb438d71c04c8a2cc62fb23f185c142f9d45b77bdbcdd76697e9aa83dad90db8deedc7351c1d4a3e2c9e509008d0cf4b31757cc3593e25ac7d4499df2e5d40049894d00d522514ed67d62079ebb6c98dc916f0025f503e2221fcee68d4189491ff17f53a767382944f83d9a549a7dc86198cf1e5377cfc6098d58a165056d6aace3f6ee1da56c31049ffb9281f4a732489c4062e6b6421f2b987d98190edf9861bce8f0d6627d5dd6ff00ab232658d080ce2327e2e6fc313fd77cdb95ee642c475f3e2e114fa76b9ba8fc64d1b2a26f1cebedca15b588fe16b093069ac015569abb9f7719ca81bcd36b00d5b91f5c785944eb2981a26892c597814a474bc0d1a8c732f3eb287c5a0f602e49769f52f9c840d4a7c409bfe14b8d58109e824a992c09c328268f7f1baafca7ea97198207606521e78cb908f3fd2b5c61a4590db1799a3b6778ff5e08973648017561b35353d1807a8a610f97b115a9d3501cc7a31399f37542aac36009833a96794f10233c2c8d953eb767108b8db8216e32121c0c177faa49b262ae8765d9a17ef3f33c7d9342d122f455d290f8cf7f35d3f177e6e101fc44ee7371fdf8788ba665a5e4eb4bce7aa279089a8fb2f687c5b74b3f4b17013c180736fc6b129a0efa6c09c4bda000d921226402da7c9e956f4be963f41a171ec29b5a1a21587810f8e39cc0027f892f23331e32e1a352712b93b819636f5a28e64da412aa4686d57ce0edc87fd1230032337c038741938e594ed484201ef5015174fb3a2eb01cdc511241087b020d0b93301ed587a36ca929b06131a289ecb9175cb23559237677cb2c522cf002308cd7b2341bed0d793352bb5ddeeb04864fc8d944fb478b30276b81bbfb278cfcc47f02889bc78846f227863c477fbb7f07f64c2f2c05e8eccf45b78a96913a26648c4653d1ba05df96be1f407780bacb579e95fcdfb75d577e861a5cf8aa8ff7d33ab01d30b3fe8f8948144e6ca19ff71862e16a909774e214c5ddbb36ec12e8799928b3d41fae743e0636bd8dd4509311095c959c6db13d5a019f90a7b921d97979f6aadf35ae0e6fe41f84ff0c8db497724c0036371ae3c8f6051faae1a69b1af81f8b9064111c24c0d345ca97a11be56f7c5920ad2c7ea88e848488278b47932c3bc7032f4e747e8116bc4e40961b731e5d641833f42783ecd4667d56eca223468629bb8289b8aeeb6216bfde10779adcb3fedec8d98d856abe0a83025cd441c550787073419a91c2b9746ab9cc437d20ca1473ff5be2abbe112988703b172123899e163687ee6100677a4c96c855165158428a14f06c9b355f35399945a8f3e3338865fef28705ee9217aafc65fa9cf733b73cdad647bb45e652f0a6ad6f2e66628cc5cfd86191a06d2f4eca620f4caf655173963b05752f4f800b48cc1ae8ba5c99b63377b9d65e6f788911338ba8829ed464f2b8e939a7c0f1461809a78b99efbaddd0218dd25743aee4c093f1e64d994c515dff75484d4bab9e60527cc4fcf6c0518961c2fc8fc8afdd8dd03a97b35e3fe8564ccbf9911af99dba5f585d376936bd11d7a11d8e914123ac1a39647b27060bbe5e4eb5eb7b81501b2db3b819a98a47b6d5925e473a683c8a7af6723ccada94d132991dc8d29e1ca28b9bd98e5df4b961948b7f579e3ed64953c1e013d5e43143af3e0960fcaf0f6605f3257e710d2cdc6885e9232d08d9804ed2e300bb2825fdc2e4ac6e6bed99a0ce06948a227690a6dbb9ceed28c7ab1f6c02f50c099125107076b3526e3b15f80a6264d7e4d5ee41d55241d9b58112f55e983256d76fddf14e18c6dcbe03f249ff9abe300b72e83568cdf84cea88342374a5a6c2fc255225ba92b0667e9ad34618a4ba907ee36b7eaa7ec8649a75ba4158cdf1525efc57c425a43f1046dbe39ac4990a0457d7e22325195525a28fb1e2a11b1a94663b4594f4879e6cbc25da4b2b36bb225dd5039aebc46a96abbe7bb67939f1b35a29e5e1af3d6c66a792a32cb2dd7b4ffccc6d5f5e2318ed14c372abc3b607a90d2eaaccf1f4ca476408de5accc6ff5325080d938cebda11bcb630d10038814ff7b6ba38d0d9f91742a49c5e5632e1d6d4c96d23fa6762feed39dd82efa999cab14fc8086a6fc4d40f8f9184eafa756913f6f594e33286c1cadcc5c10788931394a55bb3dfb22d5c2600bb495bb685da524ee125ab7cdb78eef3de004ffbda8d7ea1a9f13dbc107eff7e6774fc4eb5b31deed50b0d9165a85ac532561177b9a882bf6ca8247d29e73f63a8c7b62eeb801654fdfa65bca233ece0277ea548f8f93e4f353b3443e10f2499de09041026f9f4f161edb08fb76a7c584e2d9ce92e0255d326b465838cfd08e9ccb28c5d2c0112900de7b2c3d6d185b5be8edbdd5c6c6fff245155746873628cd2dad747d38cea6dc4b22457057121e7f7fbabd1c6ddaf50d2a0084804a6b16a310260e2addcc84706414dfe81c2658ee02f4d28edb78fcd3bc5fcef6bc0d312961853ef84367da12a8ecfb5f6d8f7ae4fbb1de57a01d4a0d90cea55c36ee154e8364a44e3efbb988ffa2b91aa5945729def69037dd05014df13df2404c42e803e19016d29ff18cfba7f6de0fcc0870df7b908bfc84e9b98a376f45e420e73e2006fe7d78d9cff1863ba250e97855fe6a9f646e6867394c8a9014ac6c2522bfd8e594eae0f8d1beefda5adea7d0b845d6e0d890a0e4585e9f1cab47e3ec2d01f9fe17210ed69f308b5790b49acb963cf8c3436948e352ff421528ac1a6926d899fa95f5bc4f301a353c22c5707855d6bff90f7f52f7697d99e0092d4a78c4d40e754c75745c98b377d8c80e4b0ace03cf7cad8ce58c52e418ff86a35f298e8fe82f0fcb19e1aa04b9cc07b166018b51d91035745a9dc03405af40252cdf875dc792b63d4684c9a06b09c5103afc41971e07a8d356a259418be14f1a58b2e71b2fbf7bd4733e19bf5f18210a7206d42aa6c8cc0537e97a4dd9a51aeedb6f1b39cd56caa2e858d4b768309c436d79fbe8f963c196e344e324126243edeed8ffc3785415f2948e7495c53b588265cb79af3e2e250c20a5d2e5f1ddaf8e3d9426a020b63a07372b8d4ba280b5899a5e7753bda2090ae467de36a31647727fb9a5d31a85b80b74ea04049de47908b20fb9db16e23a4ed5eced5f08ff820f0b18cd840e5ffcbd1447acc1987f710fc2e02d1a6205a1e1ccc1429b3c4c569e6b646d32914ca9760e0d8cb7a8eece3c5cd415ba32437190bf205c73ad89f83ce18ef2a8a6bb59e323fcbfbad3adf0914db2b3e7d5a92a5c75b922c9a1527c0e12cc44f08ac0a679e524f6609ea71f7a38f0a8bbe994093f4c3a19b550ac2d94ca092b9a325f15c0cde42d7a0657c35f2253a38e56c794b21c1ca6f2944d828c22a1902e46fd810803b80072d319dd38c182acce1cd40a27a1545eedba355bc3171cdec772baa0ae21cae37a7489d2c48033b258f9fa9c7fadea26a7f9bbffdec8311ea2b32a67abc2479b35cf5df1abae12daa8736adff1e3470ba28dd9fff27ee46d425c75be67ad85a058d3cb1cba3a4d8bd0df27ee6b707bc202b90e2b9edf1099d69039bed746c36f976a6f15088ed3fae4dc52120d605bae6c94fc74a4da3a26af6fa6fe79e85c826c440621a66e2c2f7252e3b4c63664a808717082e6d6f7bb1d9b477bec44cbf87de5ceed4af62adaadb45362f73a99c5dfe9c16dc5c61770abe3584b8434b3f418cf8821ad7c0f19d33b0f79e3f70558043f595ab4c8f3366d3e214e97cd4a01b4cb6a15d4f896592c7e793dd527f10fc953b4d76bc704b5ef6c92daf77d746f62d0411afb315ea714307c1d3a90d3d3790da7e1d3f72e556807bb50578179faa1cad98798b1f08d696cd42dac72114c05c3e306a131d743a3ff6a787a9ac8f44ce813cc0aebb4c8ef8ed2abbb2a74da6be67316857d0143e97dffdfacf4dd21fb0b58bcf51fd1589ed012a54c11fb460fadb3fd0f37a334698549a8ee1b4771300cad9fed79439c10e04356f7196569e3a57b517ea0b8bc5cd47ebddf5894876672a92c9dc27e2c823f3a9795ec0f4136b49fe5c9d310f93f13948159d623370aba85da5540d0ca6e34d2bd5e341352aef8e562f4fb2d3b86a5df29445cfffbb45f8ea7259c482b40c5e188a1c0f04bea511513f753a06456ccac2873d48cb7dcfbebc7edc4f26b324d141c2bfc43b5860cdf3124c1b1acc9ca0de27378d33fce6eae42152892aa277ceb65f4c1b9a864c2489eb5a3ee0e9b389f8de74c30edc66a00f7ac98c3ce6120f4caaebf55170ffe4e7030ff95c3ebe103d0834c04fe98aef338c7281c39c695e4248d215f356505ee125fbe83548d0934cde521cb245556b58638daf0bccf08b3ff9fd6df93dbb83153e2d20b84b1e335cbb8b27208dc63db70dca014f194a91d25cc7fddd7d668fb2b91b33b945cd6a273c056801d67b49cb48004427eacaa03dc5cefd76df23214695ce8dd839d947814fe18353338e1cf20259198bfaa73948bac9a228e2665b87c5ebaa35fe3ece575b679a037a507abf6c6a3ac87088ae300070c4ad519a78ecb8a180ec5d345c6a4b4ebb81bc9cfaff4c5d9b5ef3d3a356b6c0d6637ef8db9e9bffe4cfe7d32dc25b0e26240ce5d2eda335e84075aa4290a2cc0ecb11a5f4daae6592429809e310b948acdbb4185065cf73cce68bab81829d781424f8781f1b15564c7864354c7947b6395d012d00365a1b1ad75042dec9e12c6a9ba72ef88690f059452c94629ed6ed6242505fc9aafb290b22da6e5278858f209644a834b3cfec1a90690c5c2c7836b3f71e4ba0a266e8810e46cdf16e4c7bbbe07598966a0d5074d383abe03905c6de42db042e0c317ebb76880f998f536f8f1eb8de9d796230b748c17739d71687acd6e8110583065d8621c70309bb0257226cfa2299be267ecdfb9a771054a42212c383f0cbffaffffe5c348c5c2cbde9861fedea38268ddcfd587e77674cf70880803c84c0db8fe4f7ddea74c16b6671982b12f607431d3f55389fd7149a8d30594d31d3917f5fa6b0d413df2e7bcb7fbabbbcd6a4b881fe814b088c72a32df2ce745807db58cddbf8e7a19abfc98f2a0a3425853f794661abe96abaedc17844a8406a51bd57c586395a9a0412da4366f8307c3002b002ee19bf11233956bd154791c1f123f872ddade8ea44b431c320a7dfcd8c9ed6aef8124c9002f949bc39378a99939d79d002ba729174903761611c2d8481cb5f4e63e5962a8a2c92a2f31febbf113f4a3fa47214a63dc7d7bb3540b8fda03b720897ecb86613092eb918ce3c3a3a5708eabcfb02c78885bc700acb1b04df10c9668639b511df95aee3dbf7e6fa29deb0812f78e1812bf5a0d406906071cfd5e452399153268e7f4147e09daab902aafa77153304ce7d9e2b585b5802dc85d0984a01b9c9770393692cc1237fbb995b7e21b86dcf78b87139ec405c138e223d163fa9f3e31b6a2a8aa96113b0538cfd835af538fe9a57f901c58b8bdb6613bdbd46c722d52c25e96d77f1d45c6d82d6e8042f1583d1f7a82147145a8e02e8e557bed4dae36d1645d50b30a6de0f9c416421d2c5cd08ed0ea5c399e11b4c6a2dca6c02c558e54a7178d2c9a4075ad8a260c329fcf93993f39c3829916da2f997b3d042a7383318467776268061c059ae01a0ae2de7390439585b670e8fbe7e23f4dac79b11fa556cf1291a7ab37ac09a36e5f6cb36e74ea143e3c8b689083a65c62ff1690a0feddc7c9f49f1c4dc840702536b61f7b63c0836d3e7247c5e4a3278142f81da416dc66b40c7e6a5f720a5afec13a8dcf7bb83fdd548988542b4db067f9c5555ccd732890768a03f6f54f913486a46b386c1c06aa099699434a86ed832ff4f6b7bcded0b18eddecf244430c2b763258d4eeedc1a9d2362761df7a17731c67ac325460546ed1321c800728ff6a55f8c4f755ed18df2427d1a19a2cd7df5ef6a7d6c597acec2d2b88113334720e596d6f8ef90bbf0a852e4125b76f8ca733703c2826ddc038fd7114b137042a006b6945f22a88739b3444527fc63ef0ef994e758984d3856f846d33161c505843448692e07a69ec9cbe35822dcd5aa3023e38a64ddd68ce60d54be4c3853b659cc333078791bcc948414e589714cec497611b1451cd7e851359d558f58f84d41a210311549a48333c84bd91f21815622e74668919740883cb074d4c8d149de07e5ab79a08eeebd740af1a6568d0ad99c635f24f3f45510b07b5f1de4927a2f1d827eeddd7a36606a392178cdedd54195772fa904eff0edae4560947a164282ba732cae6cdacf300f85d33e6d063d49b00bd2990e7dfd4caad02a56b9797b90e44398f4e370acc6ba08d351ca7e1363b5095c75f755f4228ad0ab73fcfd589092859ce7857b2bf168d2c2ad7edbb351949f322a2f5ed6aa6a8b4e97d524bec8771ec9e28aeb51410d8272c51967dbe9e887c8bd98d9dd074ac2e5cf6d098d7b31a0d2c1cfb380ea73d80c2596dfb4489ef7a738659e575c73ffcefd7728f81f7c6783c3d4056c8b936b38d72d998a8a597f6fc302468c36bfcef15485698f35ff3393aa0267413aea0db72b0d52fd98d593760057bbed60b34738402652a0a2bf77dedec77fb6126c3ccda518756a0815bc5ab51aebe0ddb73331c56b8bdf86d476d12a0df0147c6fe5523cb595c0f8b784d03e27f6ba2ec02ef2e85a7001049e5173050f1c5d22d3ea5e98d6167e686eca0e28b67b9f3cb7946463f04bef5f35fbe57b13f9e12e139b3a9db3f4910d2d1211d3c5aead3fa45be4bc1e363734b5efc12ac0116995a35a2e3f7f4d1192132a072df742fdf9dc1c9af2cb6f6d6152eca5e085537104d126d74e68aafa2068770c5710a88e64dca28d513b770a004c6e6339098177c0deb4682fa6820aef38bacb249d3cbf0d0b7a563f1095c3b10f305706d4e8730063eae5c3baac4e21c7170b6ac1529c0f143fc5cacc067f0050aaef457c51bd77e922ebec4588b9afb177a518fa4fdca02ac1ac240ae4d7f4a69a6b0a34a6483df28633cd74533069192f821e7e70253f415336dee8989628a2339e823d13501a2b02e861b318fae91e10c6a5b7a6e40a948c29a458a2fdac7ca0e9a98adb34aefe67cb36b39d19a85e3cb4a6a82afb5d2c3e8ed427489164353ee83e99bc2d46d7e96324c13553d9fb20f69b854b2af3c98fdfc94148ed6c9014ca6f060e6ee0575d1cc44a3afd9eedf08d695097f4fa1d76f3fe875b98d40cde4517cd489fe211f58f3f5d3b4708f4c2557ca552fa9352b531681178c4ff492e737145eb39ce5578a037826b35906702fab4c905ea1911f300daccb1fd78c2167587fd4eee86a1cfaf71a147720b0054f08d092ad2714d1c74633186e19cfa4835e462b322347f3f2284de24e669cf28d252838e6002f0cc65bcd558513a2ad199810fa168b8708b88f5e5b3d0ca16816584fc217edee15b02b8e6bd88af4db40d75de494a2e6a2c3fa76870375812e549c53375da3b8a30b679b4d4bf914b1d9783b10318526af3a9aab2de5e588693794316d205aac65e7b22d60cbcb08255e49ab6bdf4ce5211811d577758de948c443541d2586a86e3398ed26d5d5e94510f7cbb85ed7abeb447354618001c3cc38773c974f4a0eb28b36b4b5df4e3d50e9a995b7536c32c594e145acee89ade6a4e7a511d8d40f0d5235a0bd2440eb7f73ce6c257a168694b4e23f47a7bc768d7996b501ff29010127c1e365e54000b8a86c21874a1c29cf1395ee205d01b72f38f9bcbecb409402ba0a72f585137185cbed7d2581b0806dc08ec098e947b2f1df62d04a15cb4d1e47b89476172484cf9dc6637d9a49de8b015db53f40b318c90289eb522bfe85a9ec4c7fd93360749634621ca66892e6326ecbd7dd26422863b275f146d48d5796e70e3d9060231ea1a47d766c3aebda8b462a405026f84a50fa703bb4bf2451f3a0561de940850c793d26afbb9d1039c18ef63057af43fb1295b3bee581d3202feda28b8f761eab5628c4acfee92a2bf4a7f4b02c81113ee2b91714f266d966e5fa2e79a91baaed162e8e990a836422f189238b4e1226a0a1bbb7b6c1c21cae136683c3f1df827cb2862e921b9bb2b7a59b2776752c0c3832e6fba0fd7967e855e91df040b8125f6d7e6d02a191d80e66d357440aa416f479a4d66ca8996c58ab7af5b600e0fa6b46e3f20990df236262d260b9366a59b9ab582be8a1a893b905ddc7227268659749e2f61e20802cef122034310b05ffb723c161d7faf308338df56cc541e46335f798f84cc429ec89bddfbf03e5fbd2a30fb0b3d17bd56075b3a72c02bdf75f171f9cd6925a9f781011fe602e1765479aa99c257376e0ae01660857cd9e65d947401c3787e64722e58b22cfe9d6b74fda1b66d30aae790a3d1cb907cfaa5aa514834ebbaca7385b841f4252e113e6a47cf950243227a403288e5090ae70bf4a0669593f6ea98d3be5e8274b271d0780cd888c76a5e9bc0e04375f6a3a44a37480fc0c5c83f2ed6199935964646e4a7ceff804f81ef1f80508fb7b1f93f6b73ce0df270f972bf6036fa16f1661341d7fb4feee9dcfe94a9f0f4fd6425bf3de9c75a0d906c5d08d582f580606f62863c8e9b2113c3d2dae5e73f3120f8c55fb9e392a70219a2e56154bf19f264104e06c472408b9413efb1981b154581a17409f0469dbfd321d8b750792a1de1d988078ea90dfd700c498e5e2cbd75262164ec3c587ae9caa96220fd41c2e8b25f63060c9aeb74c08cb6c96905aa3ce3cd8ace08635a6dfdf136c18b378fbac3f2d629137c5d09f4b6720093a6dfa6b43c9ea7d1f6884dc02767c9cd4e7b3e9307dfdd521637d9076a3590cca53cc8b5a703ace1cd3e465d31ce0d85e50bb8a23d7821355d7c97cc37f455edf4246a13c123a65555f70d2c9b2836412e49c2b58c1d704b9487eb086f949b2470145af6fb0143ac2ec95c4e4c858c86907216a87c32b18c2e5f5dfc29ab3c9c84c0a335a740a8b953051e324cdc92d578d593c5c6f46b6929479eecfcc5e99440e71bc221a8d1b12a8b912943350c066313b10065b5615f2feea420db30cdc53a96334d9770021f8cbb8370758fd69d96f6bc5ea9dc89225d36789520667ef52308b945b2d36886d0f6001b10b77f125c88741747c59ce362bbf556ab8615e41201a079e8c6ddc481e39712680ed6ca70cb19fb3cfe0e9ea0a7fa2da9a6210a7611bc2c18ab78a8183b1499e8c01501162a22ddd1b5c73e996fd6ccbeadf498f7d561d8429235d60c7d257882f54abcf7b49157cc4851380ded5aadcfc029ba24960338a2179de4f1ea3f9394b1102aa46fb6651342f69e592c8257dcc8e1e226c561830dbdf17dc553bb27b19251b6c760b5511b99bbb01ea5d5e5b73e6fb589dea3d987cc60ecb041a95119194de45f906e65664571e5a8a7cd62967272599f07808c796f973905cb9c5ec3005d482432e1ee7521632137684275062c4a59ddc01f96c4bc3a70aa457ed8563b1f18a9469bb8136e4d25ef4c35a864bb2e7de9c5dcac24f7be58c76b454b6f8cbc821eca8b0c5eb2d5f1a3d29ab11d5dadd1aca2e176a15232203020ed289f0390d2b6a18a6b84136fd9ea71e468d491729c99841da0450345449737a27ad53e7c161a93e4784089ab2503c5cf8c83823023c2e12bcf7782c9eb184b145ed2240c30e76fd8a13862a33fb4b62f9f60abae2250f6f93a99f12ece58d45307e3c6c41ff3ad8686593b07329fb2a58ae62011a04fcbc0e3a38af837dff883566162d32ac037c5abd45abffb5ad017d98a8b31e0cbd65331be04ac70869df3556b637cd2d8a0b80b37b33a78a4104cfc33dcfb5e92214fdcc95aec69375b4b439f3967f519b9dce1ab246c81a75b29ac42ca0298424ccb8011c5829f82974d0800759112de043ae2d795847b5fc21b12000afa0d380e9cfb052837dcadebafcd93faf1462c534aad8cb9efec2aecafa309de6f49a4bb103f4f64266e2f78e31b2fb644b9999323228e093b45865f967ecb037fa354feb53332390ae4d51551c93c75c597a31e72af1b5a583ea929ea2c613121a03c1658b9298ee6a4ef3c9e21eb76d1b4793418e45465b5f59950d778fb0792f0770ece1a054e40ef79c4a6de261056d480e4cb1cef5f8d13d3692dd0bd4004e9e1d6f70f1db435de5fce919f114804cd73742b81e143c595a823ed68cc0502c42372748d0ec547a8c6b5d3ff76d00a1b692f314951b4af5ee55e9731fb4dda6f032621ac270c74596da294f5258dbc19267dc4291363faed51607d728ded88ad3671103cfe47f2232a0980d90149d30b4677daf1f7c805d392cde8fe552c628cdff18ebac8ff46bff4ab80607d973f4a66dd308a1604b340cb99328c1da1cb7ccd628e96f3c023b38c6bd6d764fd0e542a486fb32bd169158fee17adbda48edc810667d43c8d40e3ee9d2e3c63a82ab9578e0fea3b997ee543d235888439e47f812e16a1d03f45ed29df580ad1e8a03bf879493bbc6228180e49783a79cb330d3b9ece11b476f06e8756fae63ff520721dd95085eb42003258207ccd55f501ace32493951dc3f2c8a59040acc695ec15092122b56a0b56f1f2d531910471f216ef03cb05a5fc27f1356cfcb464d82bb244a29755fb30d4b67788937fa900691b5a73179c42ab063e57301f458a42c9a21085f38a2d1af0bf3fa4dd60898c018d42ca4d11a755a0d8688a9b5497e2e3ffcb508f6f9b7aac3af20abaa5c6af44876abd443c1b70843eca6fb641721a41c3245c807d9c2db85861ac3a6f07c8fc32961946236621ab2e459ad423f4392e5b73714a83296171d94eb4b818e1410a05ff55eedf0760859cf019102eacf9ed4ecb81e68c6cf93c286cf601cc386b418f6e2117e82606512441c2990f4bfd9c39d38570a36e30f98c63544f2ce95cc6a911facfd7d5c43c31b2667bbdbbffae1293b95615330e990cf235f640ea537971f7de0f6531245b2149621fbea797ed8b53470f172256ebf096541566fbf05c6aaa9d26107263d150f48813bea76a19817698e1768e6c195dd530d0823fa3c24c191f25400d687dd0aa4bc00155fdda98788da0acac3c54105a1cfea8ce505b6be0271d64d093ab8d4cef313b950d4899c9f90e10f0dcbc9a5062f26bb6d2d586e9e6e43bca1cef26c46dd195e111e0d4e1dae21e58e599e638edc4c15360d54c466794c490f49fe3a18c66b6bee0004fd40665de8d151546eeb43778e892eb00ffde88bb8d09fedae1529db73b7dc687f40a16896c5831e9840ed873248e642906ad5983405828e70a9cf7e420d9aab339321e0998fdc33de25eae5d6c55d52d2cb052fcc736967eb34848bb45324fcae48437205a324c85afca21937603e24b6e3b1b89708f6d6f15aa9e29c3e69451dfbbfc9c27e91bd8170f85ea74e4ad9914bc8d791b5f58a874f8d281b1ec70aa0a243ff0340160eb01f052ae8cd092bc70a477ae8c9d78526514da44dc72e44a1640370990b4545ff8e8c2e08595b32bbcb29cbb9b5e6912436e904a490444b0ba1e9706f283714e71acc5e188d7f3932642f355e4adacac706046ba39df7a1bcd734ec2bba62d7bf751ba74e456c8bd4b8be74319d7e486a55363c240ad25a59eb6dbb4ac6360385ffa1cf05053a9425dc084e033f62169bb6a775e2cbc688b7adb62f99d6eea31a3c4aa3dfc6ba59687821028e2a77e005599e2b10a0b88400df006645c66371b57d2ef95f64856584aa3ab770c62c65641e3164927edfbb5e8dfb1440595beaca814e44017795d578cc754a6c44a1fb720bd246fdabf18e5610020163fbd83e5863439cf4bf6d7dfc3a763c3640b160c0dce17edb438a7de5601d7817f2d8f5c1d2e3e75b5751453f22d1bc531e26bb769022a0d2380181a4ec55a043ffc2a52a2bddfd2b757fecc66b1901e6b37bcc9a7059fd95eab69fb6a286e1864ed48600b9121321791b64d0c4f340ad2303891af5cdfe8ff5b8224d97f89b1cf5a1e2cfa7fdb138476b9a55904179ac68e251bc2a5fd1a412297b7df3d7588db2bfc374a9b49de4437cab0d9216562cb1599ec31dafd4df8f433eb10f401bba2b6b10726586f7956e1e3459a2493e36aac24404f0988d87add452b35310ce58f74021dc7f5480f4afb07416294d92d02bcd26ac4422f15044c5cddeebfdd02ad6e2058aa6df7a95b52a06df60c0ffd52e3464d1bd3a3f834aee875ae7e25d4ff4c7c0b713329f5f9eb193d09be91d383eae0f4390da2caf0c0179b651a1002552fdac2f31830fa2ef8c110b740fc7e496458e86f944233d5252043d75a7cb191b7f7f4b07121fc7390739d09e1a1726879712d87eb56dc6bf4f8b6cc264d0989d013ad4ae276dd0606c7fbe8430f598eb151324d870ed86d8366bb667a149c67a4d86b82757bce100ebd1e715f20b7214a1970f8628d7533dc67da70579aee9559d6629104e485020ecefbd45e73097867ba43da4c79ed9e26b8fabc0c041e4b6e777cff0d90fae60d75242dec4351c5f99b6e96e7bcc905a91fda7cd2d68ab5644327128a50527cf3f9f20d1b9d19903eb495b45874df1b54a9f7b7b62770da791392208504098510e001cd977bd2b8704d54e10d1079fc829ddd24b984ca61de88d4607d4ef3e20298003757222bb6b7a1353e255a483424bd3ba4f90da8cf84752c4c01caa3e34506418ac746fe7abb8c6e35fe86e1cfa0d39c872b06bf7804220f8bd98985e5d292f43f67345d0597d396b33c575301d8abdf45702af11b599d8477d6957909ba29d26e41633b0132efb75687a6f2f2c84ae18b1078817c62b8d65c3accfd207dcf6dcc00ef926c19fdd2c7b0674fe2d35897653935ba479a52bc0bb8a7e9c60563c9eaa472350026e7fec6f6a6928c079dffed758bc2e73754a93c6a02328a01b02ccc2e13e8246aa6dc6015fdb7cd40913cd980e42b44c27e6cf4f3013e8646871ee256e1eb0877cca963f47126faa4827e9c6643c2a390675aae50266cef7a74ddb161e44bed4e270f3d77f6af65cdbcd136f25f2b5109f2ae861326d0bfb0a25e1e1377f9446b1cbd728b022dd56648ae7f68e98b3ee11c62e65e969438cbb21b0fc72b9d40629049438b7c85e7034082140c98a390ceee0df3ae047bd104ee94dd1820d7219e81ff36d3a8a6e4ab0e2074b5a64bdce85636f07cf03de19aa73f2ceb3429bd10e9c227861e9a2c2b218ba2e9a2ad2a4c5bac9a39e4356ac8ba10679d25e76b370aa9d6a02793ce76fdf904faec05bb633155d073794eaca3ff7d8c928ba59ade2416c3f3288b6bbc4b32988efc7d6c2d9573adfe3269a90a56d7654faa5b63e22eecf1a72e0c7710b96ab1a46fe50c15be332aabe80d8acb36d4f723cf56a00cbc900997f4849e9e583a02143102bf6cb26752b812abc8fca8b062e8f6b1af204c4edecb241b156d7ec36b6175fa2a1695a528cb9cf21efaf0268c30a59d08e3e0282569cf7433b8ca41e70a52d44c34aee8daf927936bd89f8519f87b26f9f103e7bf99e60bb1a0703637be0603824c444fc66e3e7e0a1d42f0bedbd836eb08a3564432afd70d4e62c4fb8bef205a25f3a0ef37f5875fcd7e9792946e839c1c802ac0dfdee9cbb5b8ad236a4765779692a6c877fe0874b7b6b270c43a26d41e2f1be7e37caf4594d16bde757581937fd680003f41bb141db1a567bdd45ae0f3ee4745c687af76887af365ae58f5faf0b4d6c82efea4735991f7905e4ec0422b1db3ef016a6a4d5d841027631172b41a8c051cba3cfe46cf638c4423abc4e76e9bdc13c75ab07ded6ce6b3c80961eb715e1624fb0b7162cee8bcc0f39ae3c0aac1ded57f7871d3872a1fbba30e6e3ddeb4f0f2a762793b08ce199a5349ed095528cca6cb7232f1ec2c973d11f72ab57f67c8a4421b83f8a5e93e80c7693a0bcad78a2fab7ba6522cb2d94c7ee124f86b47d64faab8b944d3a92c93245036ba118cec3af3da2803c272e29efc695f74384858ada0111045a8715c1c2e794f7bc07f5c50a9220fe2a5ec8ba8e206b4ee4ab1b50bb567072a989dfe81e907060011e41c58149acdf72e509bebabadda7e9daff6de57682089e8cf7c8bb89d7842b2389b4c8caba5a72cd038e5e2d46aba62b4fb89fd155cb03086a85666ec276a3e326a2f0d58b236f717e6609919e99e19dcabe6787bb1eca965c6d92783d725a332a7392f587a2625c022c5e030f14f875f9c64bebb1c172cbe7e577d77c12080207af17725893abfbdff4a9379343be1f926bc3a7f97034b6c83f58986a10a28b19abfdabadbe6d3bcb948705e3675e9e9b393bbc5d6007adc37963400ee233ea95acf2e39daef7bd1caf4dc28698b58caf2f7d526bafbfed4258db90a4e317aa119cfd9c146430e4e3219fb8d9e676da67df958ea2e82a70cfc28bf8f9372433f5d61f3c78bf96b45ef4d743512f2c95ea4cd9155e39eb64f720465da06374b1d5c07f7966b02d90827ecfe99d3d5dc3413c3c428ea893ad10e3e458304ea0ebcde3a5ecf50dd9d179724fabcff74d6d25423e5a069f7caa082abff5558498927283c72ec9f417fa68b853673838968338d5b94055515434bfbb9b54db51dcdbce477ed2ec0c08045423274b43718c4d9e933190b8149e3fc2041e2f8f465382b14cb0bd1327aabf68191339d00f9fce61ae5af7b97b291ac700c70035a9a683fc7e69de83b0772bba8701b7bd86a478f3ef0af1f1d8411ddab22a05bc12300a340ee29a1b628ff725261dc106faf1ea8dc89238439a01ce728c9fbef9f7dcce872c6229a4d54d0be118be28d7605edd8aeea6726d9af8f2242947c41df79b8afbaedf294e1d1a3e9ca5c987756fcf44b919ce2b3b715170e2af62d1396a52e5c44a144ce67a3d857ea31480b1e8eb1a42ab3599859756736d9e8f94c348e332bde423f1993e34bff1a671f02ce499568efd38747a65a6c7077cf9cf80899d101dc472332287f05a01c771e3d5c87498f0a36a351f6f2efecb3efa1cf22cd8095d1e59b1bcd2c09d51099c418bb7d69dbc019542be2edc1520090a6287057c947147f77fc471efade4a644f74bcbcbbe5cd28b857165e3a9703a198ea03e0c442e2f150a88bc4dd3cfda5eba33d970182df5c6ebb0b857b6435584ee059c9d8e0a12613371814641184a37ebbdbcbadd65fb88f2f60158f21e2a71e919e657aac679fa8de2b1797d5e57baaa4630dba0001854ccb4fdfcbf665be8dfc2a26abf4bccd868163a8704e71bfc2e1e15c90837a6d459f8355ade1510708ef6a887692afc282173f5c38f47e11dfe7ba0a1467a12a5b0aa6a738bcf8ce974dd0c6756f811e5c8730e37d95a91e0e76482156638cd094089fd8d8d8e0d2d441c0f313044d3016a26534a87219706fcfe1a86779a9038d346b3dbbfcfa2d416473a5ac50c719804c8369976ee734198123dd7a8d0fd1ea04a63155038e57efa1cd2cb4ab5d6dd1637ec8ad63b8e0608d80fa4e29cc4f67477eb9615b6179c6bc3acfb582dc23a9fa4ef44a6ef28ed9eac5a1130f3f5e28fd9611cd278d0222cf3dd1e6bbdd87ae10f1599c3755e970db0b2b9061d806bd8155227dec5fe19e5d15fdda79258cbc82953a55ce7f1843a1f681cb387fc99a172cfd85c8c549a1d5572fe6839b0c94a273e3bf0d8dbb970b80ae25c25c2895385d69a4f0d5dd7639a0928f3b043f325ba0186a73c8e100d2d872888a539247d111579f0da166e9a05625f98ff08a293d656d43b5093de01d0c0f639d4d9d9712c183108167bf5a626d49fbe686faca8857990527d07a1abfb829d5124bb402dcdb309737f5f46f0e521f56b9ce50ff4d9206b16764066568c3a4f96bb0068b77c8ab396326ba79ef207190aab296999606541518b362bae2af952f84bdea42b6a565962c3586a6e79facceb1ca331456da3b7051f7ec888e43b6db49acc7e7d4807737edbea43825fe41eebb33084de3b01eaf57bded99889586b22f42133384b03a3faf2acbc705fe0720a218c8e948f44499b5930cc7c90347035c03046908b3c4cb054986833b7ded62f57a8b55bfc713a233e5c3ed0ed2718915731169a83c2c5f8201480d137b54c5488238648b0c1b2e8e1d747f9810e927a9098200b3267e0e38d3e08c556c70845782536182c65e8eb8fcdd83b0d4d43c26921809f9650195d71668a443aded3530577542c66069b8d4fa847f835c4c7ffc3459cf9da226312d8da135969ef95d39f14412b699a2f0001ae1c49f8cf3a1a699fb520df047b63310ae12d22e7187c4bb41b20a9c438b479097a255a187933b1737e463cb544bcba42a8316b450f4ce4fd6ceb0ea5fae2fc33521c162509b1ebc9b0cb0b32bb99aaf4154ac289ab8eed2bc45744fa0a3c578868f178bf39948dc45108dfde3805952fdb76807bf17d3666b54c67a2e5a7c4f4d520e531a213ee8e4f5695c11f1b0c730b22c1f72c71995298e4289984d07db061093c2fa81172eb0fc3db24b2850d6bf3ff48a7d733437f60948cfe1a1d7d8b3f567f6209d9dd568ba9b015a16830a0568c10c9864fb7681db86b384de3617d4a89942aa6c2e2ab323b2cbf2c73546b76c7d95cccd5b88a726432cc0fb2a026b4bc3c1e01823e909fec7657e85b6d2e061ad37a60487455620d90dc8d4a8e985c191f6cf21c83a4b6471ec325fdd9f930415dcb5adeef7046f2ad2d2c3aea3d7007f13539f0e51422c3b6e0fca282c006fbe7ff9bd5ae2746527dad77563d02a72cc3b6da7bb9c8a5d04d0c6deedb5d975bd93835a1d569c0a23952513039f74def1c26c4c242861fbd9bf76c6ba0a32787ed89edbfb5a2f52ee6ade23b13aa5139c20fbc9849bb39cfbcc4632707d63de196942d2028ea37ec1d9c54427575cc43730a5cdc072c999cba5799157005f9959cca0c67a419261a5d3b71ecdd1419d9b479e0ea1068bf42f027540dbc7a776ef919db520750ac120d79f057a301eded576af8691a50c579c58b0c4944f81df19f36b78ad3f014a8e8f64b3df4de4aea964a55b735716765abfbb7723fe4084db544709c0ee9104380ef1688f3b1f1236551dbe222442e4918bd13f669b4b4583779ab05e82faa1bfe66d82aebabac8cc21b7cdd006b6737a0e718acd1f15a3568a108cb44d8484167f396253caa456a7435bd87b12327d4913339d11ccfe21761cd5dfcf5f794b30c7edff34bf0a9f10c513323362ee4e747418aa2a4ca18aff7faf27cd8ec222c9fc6eadab153a00139fb7b0d2d1d09769576578ce9ec99140fd8ee4f7bd92bdfe60a090bb50e2aeafa0e68f2a6dec6e4cbc0a7bff028ba14901881b46872e7ad3a2ceba88e2a3f2c38f5be8e34ba0e99ae496d46e715a9991d8e26da53df9f09fb4d86ef674f760561abcea882914abf018e5d24b3f66eb0610391171066b2eb6edb9943ab73c4b2abfddc2c5eb0a13c46742173fe38a7995a3755dd122cc61701b26bcbe28c7a9aca93fae8eb33dee64847153776920911f275b916cc898ed81e6f573d13ccb1857a08a174af8d634d351a82d12d8327df242ca0002967bf6fdbdd560d20b550939fdc1459725e203133ebe1551a2ef593ec55baa9d4ed63bb01ec41295b24f362f1dd294cba704979288fc968ffc14cfb5539d79633c1171211aad159b8a27c2a5a46ea46168733092c756284854cb343e87073bd0fdefbf0453f33f42c0bdd59ff5e03ec23229e2c12d5fdcc6c9d36f0fe732cdb6674f9a95feb564995c296c2ddf58ef26b80a1a7882959e4af0965937a7cbec2555968f7dc15e4d9f8b1dd1a9501dd1e3a4b3bc05fd8a3c5b5ead7230ab409ecc6f00a7f943153aa47c3a93ffc1e0f7bc05d6b3447c26853a309ddd1770aee0063ee21579e999ea8cf5919750cbe704c8bbe7519f4af877b77f18426120110348b9a5638db6a1b9e59f3a972d19768c4fc2b3a13ab08156510b4c5a1a0d25e10eac5eb6140e698825fea6f86aa05c99f71f61a5666115b3a9658b2d83ee6be720f8a80870bdbc35f2b225a4fcfa17186b214475a4bceb2ea663c82035bc322c0d0915001c89042ffcb224b42fe9fdfc5aa2959d496c8a8e6e9006c13a508932238464b330e8050edc91d97995b1ec7bcae985088a2c0e67a9c7128071d81a80f999574310007b6a421c0d835d236347a3d1324470052f6f6077f1289d20488b9065f9d9d2c240d5e91dc5b69a6dc7500c864b7a1f44932ee4614095fef7ece8954178d9ea9d15016468806464180cf2d0985af1d202076126ef9a477165ac96e5d408489c328b69b4391e03734101191692f6f4d3fe388d774888bc09a0a3fb62ab956d62fc6a54a6fe2a7c6c597d657fe61b0359c7b9ac9d5d981da79e67ceacee201f3e71acf90133f83dc84bc58252f17d8af08ce02e8360bb0935fd8a8d1ae0246c0f1a59969836165a9498df6d212ae8a5ed79ad5dd2a3ecbad4b1c396e923e35c1687d034dff5ae3c260f5972af779987ebc338069072ae948f80c79735fa25671da7a49653a47f58cc68980d34ef1eae481a10cafd37c935bad657c38c795edf0e6798bb0e5d5e37ed3770b8c6d65da1c4a0e146a5749a32b1cf0863b9befada4be7765988f73680b4277e01a4a4da22bdf0e8b0d366cbca85a45ded669a8f7594b86a5a512149a5cedf978168a373ab80307d1817903d6c68bb11ffff106b812e7fc613aa4ce34526c0e02f47a0930d658039ca5b08567858074fb15672d81c438e26af11cc856788f98aab7f417a276a2d48a48448b413cb9cef22c0082c7536ee99920ba9e8e4b5003ae66fb1ce1da05e7da78b6bf075f946192fa30d993265d43d009bcb683095cef4889d34a4b6ccbdf3cae4af1406b3e9b7ff26732f201702c63baea088f94b47715141f65e5f56dda22453fbb233df6d82b1d2545c86c74bb02b8f9d3cf717daf4126ebb847318f601a77e20840a27543c78fced585399c88ea6aadf77bc1984d39e10d7a97e53de26cb3dfcd4f75225e2e7933335df73809858e32c889b3c88c208091e693add68a662f4e21b47b1d72e3e0975603141f292623da0f4d53cccf36f98bb3c341b0e31298ee76315bc1c2ea9a715144c32e0d177bdae30202e82506e93ab5330cf430e4edf176561fe649da7a535d7a6d7ada82afffb5a0905a6f15ce17cc3f25a6dbd56fe148a46e40d8dc07f6274939e5a0dc326ed72d67faef0cc48972997df18895311400768576d82cf2e99dde18aee9472201ef34195832eaa456594848cd7458e060ddeea4c723d9fae562d4f299f823e86d95d5dce00694072797096b0627468c81c4a64bb44d476a46907a562bcf00cf3fc9f76c80422e874e3c2b358215601b50d4eeda20c1e16fdb1fc96937e2400ab6050152583b5e45d5c02a21e8679d24eabf0afb2375e20af5b6e43013f1a70d2a7bf2c5fa3d8a437248a0ab9d92e4cf45517af25f65233ef46812621a67e9bf9acab580a2ae7a6d8ec7274f97a4d907898933113bb9574be0875eb7bfe2f84707cd27089c55f399e616674de9ccfff91ea793efbce9963fbe369d0ee5c845ca6a7abc4e8135993000e5f7443a603b222a2f032879806c0ffacb6388866134da7d7dd0c9f1b635d4bf0558b4b39f1a829f319b0cfce1c10f706b828654bfcf88be40b83c628151b92dac5c7242a67a138998952f89e78290248fad18559f51babf185ebce2483b08eee5cf3c491b1174b6eba867ff634ae1a108e19178b01282abde0600c1156dd72cf0a64e8a8b8193db9c9b2477f9dd31de8db5395f707e1735633b39c2e576e840ac54cfc3241f0fb0b7f48ef70ed9089f713201188ecb79ef5707d53d0bfeb0036edc65f891f861c1d4609924d8047066ce8c35efffc3a97227e8bea4d75b3950a856cf7140c4b3da20c68785fe4a3ac9df234a20abf082f1d4caac7c03b531978dafe3920ae8fc72f95bfef3421b6ef33be0a69bf1dfdabeacc5b1119024f38c900cfef0cddbf9338091f3659ab4bd379212849ff2af66c20e0102df58a971b20985acd0c035c7d7850abe6c6c78d1f79d2f4f3971e8b1571f915bdcee9019cd158e5245b4f5ff3ce88f6d9d24256a17d9feb16f9efb7a3a2d6e2e3b27a214630b077a268bdec71484338169a29dd9e4053675f658c5e542815824cb54e0669ad65123edc79648c422710c34092f0bc87d2f1cef4904d1fb7cca8d0685a04292019b7c08ab2e8c79c57b5d96218ee954df5181727b1d973867fc80c39673fae07f1c991a390e7306ff32f9d4f1291f0870f4d47ea5aff3c7104e6dbd7c40d52936beec2ee62e0fa230f661b45056778a12c68882c2991fc7a3f2a33dd9ce412120989eb8fa18d8bd6f93e2e38d6a8c78347e868ce26c40e75f38dbbf8278d21a8823edfa0d3074295980a3fe6539158ddd38ddbf6f068c81f9c1fff74505860af7607adb4741ef8e3c6273237e73aa551d590187201935fe876b0780f8962b1bf36d9c24e6133dfa67c19fb3262fba54b6be0eae45a51959d565adf24b852cdcdd96b6c4c5898a0d82df45ae857dbd20439dff0b69ab87b6b05acc1209789cbe8d930a775dd3d3b8ac12406d4e3446f1519f1f11a3267866db52e4c81b536fe2039ecf88631507d8eee5a979d0a919c81c29d7aecec9dd63f36dbc0e3a4624bbe93806986eb0f82e3cd3e9715d1ca455f4f9df77123f4462ea138a19a0ddfd0af2233c45a6b1b942852002891395f3356ecbfb39222acaa95625db4b601b35d01bb0d960c7b661e74f619d7becc17f342a26630188f07316993558d366587efbe8f038f8f608b77bb4100cd044826ababa7aca6fe9559de2eaa34734f165ab9a832e476ca3bdbb27194494234ee3ffef7f3f9b34c9ad2c14fd7ba240476ffa45be0214874286d1ae079da145ce2201088f4fd6dccb33415f4056bf4bdd7f387777962da4906cbb45bf8b8ebde463314c703a0e0e352626b7c2145ccca1fdae40fd84f26e8c63802cc6a48e56e6fffd860b364bb053d6fea4c377f93b4ac59f39ebd413924121b69b030ff56b4ab160c58e51f6ce65fb19183fcbc8a5842c789c00e62dcda24d58afd408a626004a231315ca7fa2e9c74c88e18c23b0d601a764b0fc88af74345c873d4f9f7cb9178f25dba796ccc0be489cae220989013fa85995bf324c8d0440a619575dd436e937f6bd2dd3fd3f0da03b993e84dd9b0aa8c42f2c111305b6405ad902a26e4c2e861a6b6807079350b1ceec473d622284691c16e0d955586ace871d549f8c9d76dde7acf6f4b49ecc2912e1c2e8fe2fff5a79f3f8e0dfea60efa5088e302de193bd27d32ba5eb95b22ef969310ba0beaae9574ca2aa3e04a60c64428eac93df37ae42c90bc5f40a9c487d2386795972dae62ae33323b86da3891b64c75b743abd571492ff09404c9c08ba21c9aec8dbedd55bf62d9a99e9ef3c93c2ac10198ab785f4216c8a128db415e22b589f60605bf4e4c7153ebdf31c26860f393e7cd8c67ac0e53deb6257e7427768afb15cbc32807e729b738f5bddd953c449e4ec743f76a4c64b14c84fccd165fc22336f121a2c09ab8d002e7f9bb38fd15b7b355e6f1b24ef2e6438c3994790331461137c8230a04d6aca8829faced13026a33b54df686891352b6b87d30ece6f6deacfd4ddc4a50acaafaddd77a77a4c225b12bc708499b33d17180d858ab7590dd4cabf47424bf33bf3eb7476979e2494fc880354432dfeb5c3ce4dfb2be9f2af5193d2f611025774f7645c1e14dd5ceeef464c289a9f09006533b4c6279832b72fe0812860b66c3edc5a5d4f7abf5d3a415ee996427b5f509e7dfd078f45622c39ba4fef69fe0d02c1e816b714bcc1373026d9f85703eef4a8070082d966a89bcfcd2520812b95da2dca5ce859fa05763ccdf30667e7bc41ebfdb801105b1c3d42bc3edf118a1322a4ae8f0b23cb217fc6acf41a89de1eb930f737965ebe65a51c2383f8c3b0bc657507047fa66f4d51158f281912263b398991660647134a43e75d38e0968974a0014c98ed0328b17dcef34510db742c9406ed852768a6ab15ea2c1845f9c349d02cb860fbdb20be78afc9a83d23554add3886205e550cbd0b137122af0127e7262a605ba872c52aae327e623b07bab76c1dda9fbc380743b1dbdf83610c854194a844e27973f7820f02ac2fda23efd6caebddc073150bfbcf84f86036591c0c0fa5d2b7c53870f530862a566f3705162f82c0a0764cea1e7f6ebda603a63e4387beb9198f9a4b56d8c084831d1791cc8398200c07f7e6536fd7c3342b221cb9767c78eb4990120a650229ec138e465c4e27a1abb393d0245d038c8c0b2d2b6303de5b5a560671934bfdee42e1a952bbdcf152efe5c1ddefaa374c886396c71de352ec7a8ae09503569184cf3785fd6e5cf30d95b000fc8e4e23ea174891829a6bee03eb965b08a98bd3505c3af5153fe69aab9171512f44794c254884ce26ecd1e30fff81893d85e02ea0375e3a2d07b0be5c44c74150426ce10328629200b1fee81cec681bbe19371a1fca015b149a7647d595de359a322361f44c370decb869f14f918690323c724ee3f4a76e4c3a130d2b0b17326088fe2e7905ee3599c0cc70ec75dc452f004dccc9c84320f339a9538c02c6627f9f5ce7987b9b2ebd0409c82d47ae21018028772dda82ea27c08d3e01facd11897c466a071199767ba792f41d35ecedd325270905591dfd10e98063e1d3d38b89b4b4b73623a49d40fdce3d55f0ad13ecb288cccd9568fe722f87bd4d0dd4c351c01484dbb96bfdafaf93ab57b37b1a35216471b362060671638f115b25b35eaad4e8d09eec4354f7916e743f6ae2636fbfc4fcb1f807fee1331eaf3010c6f1f6fe5a784b34a7ff5a4dcd639f1af66220be53ab6a9cf73e5237f0854115d8d72ce289e7d2cffd7582f269fa4f8e58e058ad187027b4ec40bc0679cc8aafe7eaedb95fe3734b46b3a689eb1e67c5675f1e7b8b45ee73080c344e766b48bd9a6bc9366aadc8fcb64a448203e1d52236f91918e16f47954413266d11599c866988a2ce0966300e0a3695429f8e73f7b648212a3d5dfbf013ec906df47c660633f9a6be51c1671cac1d59e1b03d9c41ae0bb32d4a9ab7d4791446cad8d48ae5e86133e757751ccd18cc7ee29335b57cd6b4bbbb33c2b6058e0daa13fae009154d22eac22bcefb8653fe70f829f228927833705dedc3349a4be69487050bed574a63805d72fcb556cda86f1f1ee89a8ca7454e7dab19204c1e32b866363c7787a9fa509002f388da1db23750165078a5e6d2dc2998c838f8ceba6d075680a89e6b43af40645e454c58d869faa2148a8ff1a87055887eebfd07697640a7e850f10778d4982eb8e36c1546567797a700c334e5499407fdefba684f19638ea34b134ede3e4b39d3c62f131f0bd062975a5bdb80d9d71b092c61a5252189c445eeebb55f8a8da5c61dff8e61ec83df9d7d9f2e247fd73710c72ea8ae276f2843bc140dbf11d5f7b01cb0abcce483ffacc77c9d257bf8ed0ab4142e85244c370e04f08b98bf761129409cef44f6820790dafa685caa69174667da6acc19aa3a97e93e79009597457dfef385a1aa40a09f5c48bc6e88df8b01253bb216d5eff7e71cd57fa60de343b0ad16b763d4d59f7b60f80b515a6f193a51ac85e1c99fc7a441917895a4957a145dfff72e61eee64131503e65945c4cb6d220426457d5185eb21d1568b70a5cd57371823b23a0934cc134e5371d9c550f115e83216dd52ad72fddfbc5de9f3f086ff2bb7966451e9784a851b0f0c5fa4d6a861a4ed455f7ff6b9e1729ca09f0a5728b66f00ecbfbfc2827421cfe03adbbb58d836f245b2490cc64b445d32c00f9f21c669bdbdbe0fd6aad02c0617c7d5d394e0d95bb4ef3c4ecf6dcea24a7b14b3601c84853d71c48309492b537b3089b0caf344a2dc59b396986471d7049c75f04bf10feb539c55670189b71b17b72aefa119bc4cea437196202b64d633a3f0d756b0ce6c7c16b54327befccfee1bd2dea970f84b6d19ac86f7d9781b001b9778d9c2dd13342448c27dfad6f6d53ebd3512d85631a7a5efc051ae13c35c4496d917821b0c5c84c4dc6e050ad7ea227d6d2717cf28ca9d3163e72d70d495f690aaf483c0a6da5ef7f39a89093e35df69104b47420ecf9a59272a5c559657d3d90984fdf3ac16d7be1bcfe8934911852edf5b541dc6a38a7d5a438c23cfa66a5bfd8c50a562389c01fc7292636051bce2d5a14a0b901e6e0f64ee5ad47ea65aff36221570c6a01706e865f7dea1b3f758419a723fe190057746d6b5579ae49530f53ee12b77b1662c4fe8ab6fc3438a868eb15956769693680440e4cd9f4f93bf799f607d78a8701f07ddbf9eef70521582ea06921f543b86bfc999460b8afdfcd7254696cab7be6980388551f126493305efb46310e7fed4173f1ad1af3587d6806a09e0226b95cc70ed7fdd6fae3cadd50a0b7af6bc8624ea1ca2ef8e712fb0bcd90de9adaf3e689a00fbc7bf9fa4f09c90c5e9cc4275dadc327d67f880c374033de14d60f2134f4197cecfa678215397468c7e3d5e3b9ba82351c809fa4b4382ab0092becd4ef4f2d7befb15674591e600fabd00f966b28e88f4325f002255b9dc9fde7be6cbd5311a7bb77c1644d2db1642fadfc482c602eb38d3740bce7d1d7f68b3f2bb31a5324617f77b61d5b41977b7fae89d046bd9f1f7c4ea3bc761c3debcc89f2f15773732bbd9618091002fd3c63e3c49a06b0049d80016ed7120f9568e85ed3cfad2450978f9a455957a8a1009d3b2a5c400fe610d9d97f557aed06332cbc5d4b317590b5840e21f5f3d14793e4726fb84cb73df9c70ef2adc158b50413abdd106d4848e5b66fd06fb78035689966bcb861f633a5eebcb9e2df6f969243267129f9e26b71ed8effc6a9f593ad56009602125e13c435b9c35057fb73c656694506f171b7cf05685024fca15d6b637940894d7612403ccb863221382c6fbbecb9afa3c3d6349a3f44d9fb14231bdaa9135a144c8967156515075826aa2bdad1c99c96405f0c2e6dec3d4cd81a23b23987ab91f50fabe367ad66c433515de91fd02dae485bc1b5a10cf713960b0257b465f868d3c9eebe6cdc3b1c02002c6f9e96afa00c683c428e9f2b3fb08bbfe1d684091aef1e3ccaaffe2a4be57fa1b2137b4e0a6c31449ac153665869c4af7da88f1bace13ca89cd5408670f8cbff781b012560b9de09b16eca9c4f7f7748ed3a8060e6e43ff3d395d0c494f56d8d4084d57cff8104a0c26c65b89e6bdbdf85aa3e496533e14372ff04aea2c2631639bdef1119f3a97187d88e66e15566daeea5ae17672455d4234977f99bfa8e0c4754e72f7f60e7bc73569f0a6ea061c5b9ab9f78bc8b78b3d231b08e7677c60a9b79d8c3cad3b7067d59e0aef382ac5eeb90d31327cff9c9583ef61f43e173ceaa3f3f700ec7d607a2944702545a7c481028cd4d7e994cbb1af87516860b33030b197a345cd039636114a69aad32e1b7b4510b6736edaf324b2c44bd72653ba03669cf9a6709ff5b0d8667598b35b39e44e02db810286f8ddf25a2bf4df0c2c066ca1cd91ccdb44c5b7faab5be4393cdfd5062f817332d5aae674d6b6d0c8bcb4e9359b7eeb6d478b3fe2d01f381aef7256ad7649ca8007f6ccec1806b709a24206b086186071d25bd4d5a80831be3c91bec6cca9c65ed55fa638127c46d52f60c4815f8b866ecb8851a8b857c1d6ac10fa2cdc0bd1baa70117beb2a19191809422fbd45525a973a7bb70cc5246e1a25e1455a77470455dcfd19f61d30a752e4e37994084477e0db42e00b4c1d04e1e364df11c69dc1cdc72fc003d6e28d187b8b50a5adcf4a269232715b56faf19f966f036e1d66def43a17358af99623e1db30e587b41ee8756a845765d0722ab2c644bbee3f06fccd1b05ac18213ee2f7d3c1add4be28d1dd3283d77a2f43cac8858c9e204360092d638fefc5d88d07253905c151e1ce731514f3ec31b5434db815989c3d0da6ba4adf201b751cd3ae590cd64e73e2c882813b20adc6322f60da6dab679353118e2ae3ce1e76a24149742d7871d5582cc2794ceaa0d296b51d9500c70aa7fa486461a53ee54da09e87bcecea44fed53a0bab3117ea38692f81ff6cf02d05447b2b68ef9d8c20c29df805ff180cb1e7b6c200c149e58e79f44ed104c1c4cf74aaf83e65526b8dd20fd301260a08ea98f570a4f9f5a44fcd1f0da33de57f7b3926768cc7060ccc1136cb92094e29afb84fdfef09c55aa93739bae43bbbcc5ab4f927c58ad7e1111c30871b73a6c13e90739d58d867f6deb96241f509c6fb424ca4417d56da234cff57ba13122c3455507ada3f1a976efc0e8b44d91d9541b432c1122572544c549f8722d80cc5f69ba5d281ec5191205535a0a022f582345c381bffcb5696352771736157f7e2a229eda855e3607e6174895da8818381fc97748609382a3689b915c5aefe8c49443dbad48612cfa4261c703ec7fa6879786825fc4143bd5395ea6a44cb288b92b9285ca59c267e17e9d98dc46852fe0345cbb6417283577a7c41849605c223a6e5a951963f43d7a4a9210ea37150289dad75b90a02153451ded1753fc8a36278f591164e72d39055a71606e5e0f54695d1856ed5931aeece1ec5567365805b3b81e0605293925f6c1aa1c5125e0295e7cf3062af85d1e069242254c5b087bc26c3913c732a7cd9d8d0eb3ef5a9e6a6096eb1f235ea0894672ab5ec06fe64f173fd92c9d6e0d452e58ed1472838ff9140c8679b2593ae5dd447669d61f05e542883d56d79bb8b8e7703d9190ba10062463b5ac9271a05937874a1016addbc9fd8d3257feaab97a475ef2b148d23262323e44fba2c28cc3fae4e556b7b3ebfede89517bcf3aa96e4d08317de46d7b696a2c89f08df2a5e9f0c65d722aafe88fe31799475808d52666ba15691a39b6054f98bbfb6836b95088b43bfb082066d04fd062ce1fbdea3a6f0ceee06bb3d70c2264e4a1885dfcc140e1dbc3f736bf79d4281c0e4ae7492fd07b4ee4476e693c5991c89f9641c3eb11cecc2f14f785b2ed3d7ce77f5749e61e55b562e8a02c14683c3e2f62d47a47b480c93cf4c46e59abd6b522ce1b3c7a26fa9208a42ce1a4a007e4327f573fb262b7e53297809ef46584cf0b0a48f4a2b94edecd15288400e3a8678138f7ff4dc65bb72a23c0fededdc11d1d1830511a1dd70e764def5a7e9297acade675c41d3a5438ed29caa6f2ff3eb7aba6d4f639cdc879facde6c81894281d4c936164ae2bb7735bff991a5269d0a38d83596983ab1ea0671381842e5d8896e02d45648036ee520a86e7489e191336652f0bab65c14b3961002156944cdd479c66787d8675c37cf76e889c01204481e88e12d82d8bc3c85d045bd63c681cdda15b9599161b95c8156b59fc2a499243d8c4d5c0e318d1470df0675fad692829cf5b0aa1d44f4f77c87cf60bb41b4c468df9d561e6c01a153a7d3bba239a3c6f4cdb8484fb052a37d3637f55f0a8de7b2c442da4ba635b205a0e4c838287bab08eaa229a3868b8de4904c1ebe3b84a3c20c78d6c1b440292d815df2c79e9170f25673097858dfb6e0272cec09aa83d99ad8ebbd746cadb7135b75c17e83f3eb83a66d89df711052995e7ad7db86aa9ba33b68442b16b9b328449682d50e4f8a5edb917c9d71674c62c992362e81e0508c0a2eb1902db4912fc0aa0f747132e2e7c2adf13e7e1493a433aa6e80719c6366b9cf6cfafb3ac75c0e93f5b2d8477535400570df4fb3b5c5757082ec58d14df663d917308f0a60a47d1a2374521515183c46234417c87f4f473767a6924036d3a0dca8c219ee41d071d192e7568f3bece44e6dc17453311bcb972ba88383bd0c3f98b8fe1c6722bffd99185f9505e1e2977c926729dd8728fe1a716ada20e5dc9174f2b4c92479b4b1ba1c09730df54f79ab1d262c196f04e634442c11222a9541e45b122ffa7b5420949c1eb1dae9ffd0614e5cb04cf64b8ae7a9795e68ede30c8b9b38ad0bc3104954b26d8a836baf67526d64c81c16dfad2705bdf11d9cc3ae95976b0213ba08d89845dd886d24b5869b16630431bd73e9f3ada7470eb953679d8072aef056a6b864914f150361fa1bbd83d906388d89f5595c836aecd44a7c02c4cd853a3e66aeeec58731495980357018865a986567690ef40db2684b02bd14409ce7f32faaa8a9a6e36652269abf392320da16bd532758bb16a94e940279bebed0383ff8f8b40613985429fc265fc1da5ca02da4084196cbf644e8e5023d8d31f254e15cad0deaaa15c5af23194869be0f0180c2ae0b450bf2ec2d12b52a1c6906ac13847b001229f811ea02cfdb45a72a1b3b0c8a9b1dcb441a02908f44f05de1ecec1b2473f3151eae7dea233cb7a860705d4083ecc878c61481546dc73e84454f47d1a863a81da8f437e881fc2878727972558027b221c5a5c7e7a4b3c72e15bf819cb63cc694529a97db62aaf6a823095a2677fff2f7700be6fa753bd4cb81921795e42b04f794bd5f7b82dc32c8c5f7622bd2f417d0eeb9c6a1937d172b15fd0b1118d79a972e95e961b120f70d1ee8d6ececab238d9fc2db666c8628b3f5d6765bf750cf4307cd2eb000069f1b4a2cd70fd962fa575c6975b488a188969ff9d6019e75bfdde5d031fd786820917f140638c2fe5a0e313d06c6ac1ea8d4c5e1dcab55c4169276331203a4bbb5619691bd2af69fab1c026750d91a6c15a10c6dd301ffe93426807ffd949b51433f76eefe505a2a764b432be20a7c3aa9453970fff8fbd5d8d027ce610aba4581d7245d1f868bab59368d843244380ccd66bc85ff3d5b250623cb2d4d9d392871d02cf3772638181d71122196897e64dd9aa5f03d45fd51d3709f0ae35109ed98055bd2c1ce742d65e4a10c1326401943c683315f30246846f03f7042ed76fcea4bc70b5df5fde9b5be2bf187efef5b7b4558e54040ecb7b9af55ac7cf47d1670eb9e37b3d9562aae988b145ed6779d5df927b70e307bf0be6562b06d13b366ae605751fe096c02e1b04b9e4de593bff4914e8bf789c8ae884132607a80b7cbc62bd9c5ddc2496e6d681d0661a715ba3839007ff94d80412c6192832eb9b912e7f459ae920c342f2a903fff75b0291472f9ac9dbd49416cbec671ea9fd2eeb3bd446176d708e36ea0601ed61efd8e83b14a354b289a6d82a9eb66b707a42b69ab85ad1c55bc7073717d52ec9b8f72a2ad42eb02b6ae0a9616cc67b9e3a9b372d6e0fb68b2ad4bf38a0373f322a2adc8d73fa8d8d3428a50174c4af9db9ce6a8e04c3070ab97ab30ec69fe78dbd014ebcf39e0810a15e96e9dfb20ad788e9745398ad208e2996620572d1005c75d82486159608faed7eb6967d6fadc87a3fb7de3b99c4b836bab82d2f758f5afd80037f716016f74a4e61e9bf09513e9590e454f591e3e22b99c30c143e8cfa5f67bfb8921159126d96f0244f9dad30930b5ef03b46fce40b1b702e3ef9d93f8e03f30796bb8ebbd7813bae66646b64e3d5d8905c1db8ace90e3c53b8d1dc6420238b2fc96a7751100709eff0c19d189c90d896084bda145276ae3a9bfa3cbec3b9a558c4ea7d5e3160dd64dde8cb893811635be55222e8c062c46d2d0fd0a6c3c81800fb2360c16a8998c3cf5e98be75cbacfa23fa64e6d2bc457b8388b3f5d442b8effc9ffd0980758676ca965a576146bd08c75bb21c6b806418c16f22c78ae4c8a47d25e1428dd94bc81808426f413056df4270a9436311dc737611ebf34f96897f4bccf9477d43c60e452e664e56fbd0d7acc3633b3e2ceb2c7c1473b968ddcdc88cee2279e82d9474d962e51ee0fde80cbd82af002d9448280c8fd14364ff94fed35ad31ae50c6207f29dd34a4b570d796726e503321fd1f12bc218eb0792f9f453ac45117ab096586d3829062ac314a0c5aad9445d223e9b1540d2c39beb1554d84d5f488df6b232263b04130c6be0a2f112e17daed5f7aff365f01474e1bec63f0f50af56ca557389457241f18c4ebf957d529d1aa514ae3ccb49a14b3fb9e7e1d8b75fbe06d2f9e791868a9dc65f35bbd6cc51de4f1e49f9cf52a38d11ffcae19774cc78cce4d79312e0570417a7d151f96514fa6b93f3ba0a0ec6c2e07bf875af77ef551cabbfb3fa34eacf3c731c769dbf2c060d2ea1bd77822c1cd632dd3ee466dbefa40b9e9e60c4f6d3087c8a292ab6c4446c436cd3685f562f74838649503fd0294eb31dbc4f39859a626dba22819dde90fa2ac662ad554ac26855000a348a6498ece5b038a0b47bfa0668ba7704a10829a227b0dc80ea3804b80bf9462d35a932a8ea454ce37f384a9e92575b65820eddfca5266dacb1a965abbfbf1006970a94efd96e31754e88f954777780c2a69159726ef5cf2a695788cf2a32d71313371169b714441365f17217800a385c8268dfb54a5da216cec676a99744eaac15add74a8bc69871195f2826bc0a7235701bea4d7a1c986485c1dc5ff4e97049ae36603d24e93d63595decba70fe81569eb702a5851299410266baf53666c963e29a75d1d9f644ebfe4ecf251b94e0b67815c7aac0f5f67684320df0b280cbdecb3a643fd607ea6353a79682193343c97e67fffe5759d5f7461eb4a0b5c8fc74d356b2c2c5b5127cc26d10530228eff24a57b2b9f17caa26083bc4bedf1989b0e1dd2525f30eb31b4f45756fbfd575ebec05cf9c3395d2afad63fefacef2a93eed2e6ee02e21e7aa54c33bd3cb11f4c59cb382c219e8f064caf9fe5b29229de5feba5f7d81bb1db28935fa74e1f85d2ac96c603e62bf417f634ee3ef03c685557944be9b69241150f4ca9c5a16f4dee80e6e153f5c83e1da3530e3d67fdc7c6f597ef9c85d5ae83c159ca29a3d5189e3de6993dfbed6b897165144e52add250152523ba7149f97f925c80aac2b12648f9f740268d0c8f46348c03b37fa68c6a26dc8b4feee22af7b7d641b299d806fc561f71ea4e46336f156d8ec97b7365b9153444ca7373a6e4ad0eded7736f133b6289c04db1f8f44b95e210bdc81da9bab57d9d854011791f80b16b4522c452c2398e8568087b60ca69f21e5662bed8837f505832c666fc0346556d445cc6d3cd02307e24c618f431af4607e93dc63d575d842b9d28b07c17527dcad251062004fe2bf296596beeda9fb6c86fc608ac37bca20c3985ee83ea64e3e455efff72d0ebf011ad1ce0bf7229c887c7f8e3f554ca8fcb651b481a7b7b6b55ec7657dcd0069cf01ffd958d1031c320f24f1f7cf2547394a82b9c586c20fa24ae9028fc47f3e9dd837e2003c7a9100559fed8a59e1be1b859207c9a10173dfbcbd7e6f3e1b7acfbe1ffb1fd48d44abdb169588da6b02d062ac44b72d291bcd85f70f304166630b0d5b8714b3b03fda3bf8802b067d33d576c9a2930efcddbe58eb3c9fa1a371e305563b27ac5c28a19f6b88ca164006ad68d5ae00451a6dc7fe28ff02d07cabeec351236d7ca2a0c9ef7366333407a5c5d115f31baf08d56e6ac9fa89ef14780b48a47a724b0f3f120e103de97be0ef1713ea60eb48d81d7e9c28504dcce602f1319d8853608f396ec707ce9db0c6e25bb439cca1be03821bc7fa55dba11a391487b7a06b732329c80c9f2a700f7eb7fc2387a36da0b2bd10e9f5a8679bd64de4210e3c922fc764f8d029af71c7abdc9552f156c64c953dab1e60b2063e2ab3e7d303752c5d2967e689fb8c3306db13344bf6ed3bcae3db1995a3b646ed5744fb513e8a9a723e40846114438d90f12e80e449347f3fe598655c825dfcce0010d552fa086acd1a987104d357fd4ddc4ebebec34593f7af697a4105e4cdfabf89003f380b50f2283df40653f368e359d403eed044b827d433dc072426b7cc09557f6ed0b241353e763146b3afcf4a51a51940d04529c9433e239db02bcd0c73895ad712ac178bb6698b72cd560edae7195498f150a765a5b71c076abd53f83f616b3960f86380b0042c554f22b78584a0c9a69e1a578a57f6ae4d0a798f8d2727ae3a1f088dabcff55166a4b2f691c15e702545e42ec1eb91927924ea996babf28503db4198d6cef30d2919825e89830d6f6acf6318b966748cbc0e2911ec8def7d8ae6a7a9a41b40c2d1d93b6397f8f7cc876236144906cb895388917e748c8edbcc1585b16bc3e06c3d4aeba6c3c1d07bce127510ea5599c63bd6d74ec84464dc558e63ec912cc50d63dcb49fd60edfdf7f7e9e02e1dfa84173123def0ef89d0e5ee8524869865f3f1e8bfda3bee43ba4434fd88bd5498d6a181361a218b54939ea04d74051dd8812e5580ee3b0f5474255bc30b3563c0a3611853fd49889d3639e13f4b828a36661a7c29d8fceb40d19f8b82479d9f3d1da34a91be4021f604a7e5cc5993b18aa1657a64ca51ecdc29b55429591ccbbbfb373221869ea3a556347140163164e2c1d401746f7216e576cec13f2328929b3d838359bd8908547f4562063c32c3a99eb96573116c17b29646b3e6debd3bc82e73d78b82586baba0726fde1a313da220ca3b65a48fd8835e9502bd997e3eba0b9e67ef84d8d687b9e8a04649cd1392341ef41a0cbf86de0670c0cf4ca29d036937997382d3b12948a23b6f14bb67cb313373bb73eaa3b5433cdc33b6137b3614542fe93fe02c79947ca60be7074a0bf78a79ec7267b40544137c946102a1e58d5118cd23669bc290e6095c26b39c30bc63a4c9239e8e1804f2440c0344761bbe191c1ea57a5601a427463e7003e254824ef017ec83bac4379fae6559d6942b521c07ff304f3af0b9f3609a50e2cd9e25e455aabc8442ad7c799c88da20e23a5e8b240eeef48334727a883f9f870c79360b1d5e1a80f37d1d3a0e76b4b9aa812731f85bd79130e6df8d2173a65c1345132a2129e456b304bbd29ac1bbebcc35923a44cd7297cfcf13e7e10defe8b28a0e216ca1ef1250229b5e3826d4c95679855d862516a22aedce6d3498a2c0a6da8833d3b7e3148ffcd95e79a8614f002548b6f919184912ba46495dceba885824be06d36a98e035d5e18f054394a245985860904696c1b59b127d15a16695837f94e1304ef9015a17d681160e48dba22e2fed97f4b683381e60d5baa4145e81b07e635d6b7b53b4a44779c9cdfb451ad672299dc4fbf6d572cb4d103a418059cdf922f081393f6ab8d4d2172ded4620dafd352d34bba8a16b1fc5450f2dcc9a9e09a8cea9b0a173b9acbbf63fc904f84bafe2aea9b9729efb11f926965643ebc621030665ad8dd6c235446dffdb3179480b50eacbb922f71bede47f5c50549d7073669ceb49d9ec3380eb563c1064cfec4e2547ad4edc32cf0ce86317c772900cdeae49e55393553de3828734c8d2d6bc42595adb6633fef70bea034e370ff61d6b132a68ecffc4236079d61a7dba6b1fd0a0a76f80957c537f76998e47dcfd3d2c1811a1f6a5fb014b47dccba201d4ddecc5743615205fe1755fec1d27a87e7bdf380c1e870ef21dc9ba397182ecadae0aa91bcf99c20f280b998b9a3fc86a9abd87cc4d395de95c74b71433b046e5176e89533b943eecd7e958900a5bc459bdd508a7bc406dbd12c9b8ce98e105d4b9f6ec6d60cab8059b82aba735d6d56ea2340767c5cfbb0b19de9fa6b64eacfde3b90091539bb7e56641093149cebcf85bf09602671030c920e48a9b2f5f4a832eb77ce22250436959e1de365b51ca8490501a8c3735f8e444fe208155ceda85c2bf6f67dd27ae14063f41ef01fa3e47b3704eac7a304dba2837d102fe75a2f759bfde22a524b441d467d9715f5258ceb1e9d33819bb12177778c4018d051fb1fdeea630ed32a9b362b978d6ba4b7a7ace46bde03895b0a6e9a4ab6077dd7a7ca48827b9c6a8d198478a28287df98d145d84ecd092ff5f3c608c5ffb8077c56bb483d00113f1686abf5ac389be812d69197ed23fb137a432909842d49e032ca671205310831d0fbcfce82b6becc1c7593a6503c7dc5021c09c0c5d245523cb26aab155463e2d5c8c2bfa47b4ec9e8480e05ba22da881bfa4dbdd8c95bdb66d7c2925be8740de17d027fbd08861a7d21f530b353ce07121a40eb3c48cd30d167b14e2e88f336c6b394c4d59e46686c13e067254858e8f980dcca64fdfcf2d36afc1715d7b5601705f060b4a5ad70154420025271df802442a03a1c0616202bb6d076f250419f870bda328d11eb9d7170ba39e08ec320dd2fc287aab76cd182c0aa06a37a8d1d987b549ea9b98da5c268f331a156bcb7d7c3f372cc45c0745070364d98431a907f390dc61da455bfb295041a8fff3e3833909788ab31fe9712619909b032b6839a5e162eb638c064eab287320166350f28bbc39b04315cb0d2ffd46cd38f4c629a22e93551bc7c9b35c6fcd73ed2cf0672900246841e2f7c0affeddad1366ca0c7847e304adeda4635d77a6f0080fc58502f231a01023ae6b3e1eaa653fac55a6a7093174f1e8323b634077fb1ab96b716bb72cf80e167e681d3117a07b81612d96ab64178c0eff885ec7004342f946e9ddc0f6b5c1471be38573876f41290b4e96451271c43dae4b8775b4cbf13dd5424a61805ffcabe1b220d3c0e1d0c6516fddd603c5a310e8c3b529e7e6d7ef9604262a4b28985c26841848929f341af6292e500f2728dcacdeb9dc90f28b737f54bea4aa23909265c7c7868f97a38d71b7ba2faeaacc3e3146b515e54adaa336f20e2f4fc8f26210692c8d5eb49f2db2df2ef8ed253ad4093c1e8dfdbc0f6470b875cfe98737179f92354bce4a07c7686c2278ae0a0c8da075e838e2f78503726f45d116b761d4305cd6e8e5b63b8d9362f302c8101511efb09c4a33b2b4bc997794d82ee872c70d27fd2c15d17478e5d54cfee840e97914d3806546e7fa7a6fcaa7353fa41dc90970aa42acae09935005acf00e200103c45b4026cdde581d9dc68ee9d56b7f4e46bfea2f8030756590a3cf052b5d8c777e2c58abb172f871ab2b40636c23d76a66dde768e8129d5e8dbd49aead5c582e65be7ed8d67bac0abf9ffd009c835b49169532ca89733a110b50398af3c7dd6af8d32fdc2e24398311b9ca5f5687b5d2d14e23975e3131f7c312fa330742562e9abba66b37bfde154f04eb8c1a60c9aeaea9a56048cf0d7e9797528d9afd2fa70271275faef229a51c58f50e207587f70d785980ec7960e5be8b7a329f551d881bce5e2513f3f7ec654db1ad1e603c6557a318278dfd5375dabfa140da17c1e73f4cf78d4ffff1963f8cb10e88964a8293c7884173caa5bfd63b600c4bd447cc341bbc440f50f07d71a9931e85e6f185774b02ebc5967bce0593e76350f582dba6c35ca9867b7ac4dd76c7d68173c6e8fe2fbdd5b186cc7d90572bffa0661d7245155084d8a08a202b8429da58b552e09e6ab85db56a1b1d1961454399d0b64c3dbddcfecfea392fed9ad0800b846d803ca0373c3f7cdad00593ebb28380c944ea419b2c0a6a3ca3f74ca56aff4c2bec0d2372dc02e001f4dc3b10a0eaa036144fde947b7292113fc307f0f103ea077abe65fc39715aaeddfff042b9097713279632c9a7761f91890e63372b1cd3afe8abe7288dd851a19be644b60ad1cbdfefa819f063f7543bb6aa68cee1c082b84a0a5dd17969107a57d2e879d57df5bb932feb8fef47a7a0ad3c1d9aaf08dc8106822e371f3ae09953f00621d62d38961b65cecbbe5b4e645bfe888cd5df145786685b8a6dd68a769a0e1274c2a85304dc2995e4be469c3303b9c48628bcad6bd805e793392840d4ac653e120b5c63cb08c714867f00a945f1918248e16131d779a1aeae12f29563640fe3d571a869c967bd98b9c8b4761be558755a285085efeb289970cb96ac31ed27535cd1221b120969c321a38073891631f6e839c2cdcd230d2e425a3097d90643b22a0c1fe2934d712857f044cec60c34284070d436dde04260084ee1c0b22ae781f4ffacaaa50286960ed027c9f8e77eee4cc50f36bab5b13e750c8bce6a607b47153f11486463442677c0b443e7932e053901e6ee8b2aca1c606da0b36103baeb32a84f41b1480b60677eec4fb65a037b48ce67215dc8d8f92d7c416bf02610fd20344163fbd9b650505cceee18544d84c39421ee963fb13d4d0c489c89919b6828110604ddb2e99b3c0a04d42a95a4b600306da8b182d741d2c5ba01a3670f9b699023fd854eb5c78d13421de7947c775b85912b54ed26302168d1c2f7b4276af2f91a1e9996f086d6b557d295da79161b2870ffa288272e369372224feb5d8ce5e1021ea54d09327c33d325ac2623d64a5e22cc390d2f00d0a243174f12dda1e24ce1da0379f4b072aa026e8326e346bfd7605c2f605c1ff62c083c53112692a28096598973c846d9bf1dc1b2daa23df41c640b2216c7a0cc0c91aeb20f19539343ae02c25c63cc24257652204d5d23362dce41d9c1946137d66c7d85efd7cda7e903d9e72d715f6af9cd10b91275e606a87f66a4e7205a0fb3f80fde04f1c046f2e35fd15251b368445773edf987dc9c7f92d2ef2ce264bcf3b7288e37ffb57754ebc68da81e697aaa769df9753af3b73fc3c1bbdce2703ca42e0f3b79eced92c00a1e2d0667228112dff87cb9716cb915ce828ae586cfce2334cc175fbf7d3085b0b4b5a06bcdde23fb3a3f483e727e40f5f31d6b4190dd48305033a66ca653013df82efc20ffce0e237f21bf2e3b3179cbfbf47880dca9a52b16cd3cc72fa636d5862cb4d38e02e118a98e604e2c5bc87a717813fcc129aaa4f87e4691db605aeec7dc59113d6a208672f350ed8e7a1385e5a69e1267a9517e4df733aae05285099f0afd0e22dcc2a7267e9e5c6fe40ca21fdea71e625c043b4acb2687333d7df8db805543e46a8cd4a02be839a05929950f2859debf95278b3c51abfea09d5e4d89ac5bbf4febb571426a9640f1d9b8e798d385e916c6a337a5ae1793358ba014cf244731d2c589114ef5d4bd443de5489d795e2020e025e24c88528baa6b635e9b53590aed9146350b80efc016d838902e491bf757c11f407cf4d1a8c5b5bc1f759bcc6d6b706074f4db45d269e0b84109e7f960320f82dbbc55a44e72c3c672e0dfd2598c7fca5d276aa3a3987785b1cfca3a8aa4b70b06f64a2939a1d8bf17eea0cc7e0ef8bac06416828b647f047e9bcbe7ef3898646f6ea48f0a00fd1b9d0b1c9868e5f6832ecb65dfefb72a76c9c0bce7371a4ab3eac84c9dbab19d35f7dfea1ccec0d068082e19af2b724eb03866c291f0190b74b207106655203e3add1852b4e0e5041a48ae3698e4c7385f2f8aed0ab82c7d87c082f84db4b9961e52264277d9fc8708262acf13ef2755b19173248548273710e90ccab2c659c13b5a15111a47b1f366af7de601c6bb9f2b030e51158d466f640acec3dbd23d83d74a3289e4fb92a01e6097c27306d66aa8ad0cfad1867db94472ed1bd73ade89906a679a671a3a916af17eb253a84e84befafacd8a8f305420a877b9ea1adbb9be92ead6566913225f3efb0adb3a8ae51112c7311047cde556141c7c4993e01aa6772d9876fcab63f0b3686c824193c616eb9cc6c0e0389310ae4c26e14a91857ffa1bef7d152f1507cc19c9be89500f62ea1066b184789861dba9c7e9518bf0f3a0e3c6d7f10230577ec41b42455962cc3c3cdad439edd4b5a61019b9a81ac01e5e929d5bd47fdd849e6931369649aad2a2dc898d46f66ef4452e09ccc027f1fcb91f92cfb67efd01f7700b91d096127428b2d0ef05064418dc3bea4eb4c97d3f743607caa014d2d8cd27b6f53bdb4b4a6c772a9ced9f21076424cd1d4db0e3917c1e341cfa12f887520e91502a386172840f741f8a2d926857bd261688f3370af22bd1b72f40943f770523fd9547609466b527386aa55d2c018f1a6df226d8cbcb7afc638949202b71b402e98b2a34177c7f58f683a90fc71cea99ff53cf2dd5d3ca510923a08455ccc2b2d629d82a82c9ac39eea1fbd8fea8182d1f441f0b597aeebaac18ee22728918e836402191c9c6f37fe0e31d2dc1eb6d518d76ce4c6f37b72a5b550379d94d11b210844addaeb6755ac75bb3676073684e4fb887117b0f90cbc3af72ff0218a4a90070e686da4bcec8aeb9c6a06e9490b495272858b3f729495deeb2394d0a1b6004109eb33c7c1c3cee269147878d07f1e4a80c3831c41fed063a518a4c85f099c6f219f89d4eebe21d3df3146d3578c9db94faff8aa76e271a2bb9ea37e0ecc39b1d044e69b398ae52514a59a8754a04cb277bdf240dca388ccd07b7fb8fcdc2562bb845c86e8e477bd0c1b1f7bcc86a37834eeb15657472c144164ebbaad4195672a2ea0a47ecac68a9f7eeb7aea90cf98aaa2887ac92a583f9d7bef4d4f474dcf0c7a796575687ad03db03ad2f573fcb8e7da977bfc8aa8c753b62bd1d71e74ddee6c31d1e2668b6a486583c3d6076a906978b9f236d664f1bda68ceb370827df3771889d78721768cccc12a37b4c745dba5ae8b510f9006f992561a802760358fa1b5943936471a0412a4dbaabb32bf42bb8a6add063b0e4721a097c2999ed55904bbf1787439f30eb621a12342c47714c4aeef9c94157ea7c000b85d2f6c3bd8f5ac0fad93e055bb71cf113b488f3cb427c49b29731f1b592b32b54f50b6d83c5fd5f68e3dea38fbbd112f5fddc1efa27977319be9b75558db71dde306fe11e967ded650b57d0c903cfa918338596532abbf7e2969257bb84cc976459a76f4a906594116f066815c46ce133d22a54ea6c2281a79f410f59e07878e7523a0e0201c4886e936228a7422866d0649f630cd9d21b3318ab176c2a255f4345b21a78c3c19fa6853cd9c0a0f2e7a791ed8c201bbca1b9b568aeb294764a19fa5567889499d0a95d15de0cd51bb24e3888c7c26269ad9d3072788f176aaadf6fca221523e78cb8be19914db7cf6583f07b5af448e8d55190d2a20b8ac8c8915eb69312e13fff52b6f32e4a16afd797e2919caf78baa29e6c86f5a1298047e19ea9c4efd6e567e4e24458a431bf628063265eab2e5f40de9e3b89907e63a2601bbadd3bc3922892343a43aabde39b44e14b7905c7ee7641da49ce8e4dc8785db5580d40c2493ac8f5ed3b1ce2e1a363b036969ac3400d012eb3fd5b60c4686c3346f193cf3498fd3effefa7d224a60533c4670427285cf3ee814b10023cb53bff02a15cc4c27937104ac872a59a6dfafc8cae6a3f3b020c016897e7a0efe6129102b52783a060c4b841c455a0367fec0dc18d62f6351a26fccab655cd93690cb128af734d3ebce0f6e1db46660251bcf4eff6231e1576419603568abb18a05082ee1667f94ca1764ab73d5c37df6c427b6e4cfe975c274a52cc73ea6159dcf31e36e3532c82ecc78dbe8a622d9029178b2a4d7c15a3cd76bb7b2b1ad4e0e7f9dea52ebec48b366da2a9252c14316d97d27e51857575c5eeb68e57acc152365dc2716130d18845f4915bbdaac28c654241dc3c887bef9095c7c9b1e9f863243b90231929913f0b3c69c9ed3ce5b43187958b8932c3baf790dda3fe028a906b28ad8a9a671d262365da5ef337be3a027b040501273541d87873147ef599f13a078ed3a1f1bc51420c832a64b4a1bd3ec75f8f8af35c02c928506c44f0e2366b9ddc52395454c02e0403338231ae9737428bd2824010c99d766149fe973a7560e3fc2c009d8e639a0e951b80ef54fb7fbf4ac86c2cd057e6ac29e4d9f1e2e99310d4328d3de04b4b5daf9892efa4ccf03c28782edced5483409e520d8e53b67d8dc8aaf2320806643272718b16ab243d5d66489b296346add74af0449214daeb60af0dabd77b455e7622d99185c6b70d5fc75392c5dbbb98d3a35da014112eea6fa4ae9df199ea415040183f52d79af86e681db171200e6daba01a5cc204ac4a236977e11375c664596464db92bc6679dc354c73745d1b81335e198d3b30edd986e6f10ed2657661405c0cf4df9c3b64f5034cd807cbe8faaf9f122f6ae05d010d80f205714c40a656128da01ddeca57013724f7835636aa8a94d6bee3f6150e319e7db7a8d4f67b1c18d8b3cc27e98aba0e4bf7c4798c147173dc76a267ae11cd133ab7bd19e33b47e9bba8960fab578c330c4d3b882923066091ab3ecfe19c397422a10d5566ca45fb219509150032df152364039cc58aba3f728f153445788de49b9aad0deef3a4ba76eff23707091ae836415044fb6a257c6ae8c45d6976149348cb89a3adcabe9f120e994f739d0c036befc16235084c2c79ef5998b1a07fb2b062b5d504fce010da998dead62f38c2126b27926cd703155c19f44628ca89da9e66b2636e0a1b2654797559f88ff3e5d238fbbccf63312a23c8f47f2b2d026f62ef353c4ae1efd1b7d531437343ec32e445682d58ffdc1f6d7443c431de35731fe6e367f1a9059d19b9ddb83e736ffbd7ba8c2719d8077360e21092aedef0e1828f5ade33ca37e59e38fda58479122fb93f1f2b27fc2f9f53dbacc7fe63b61c424c8a9ec3d9618d991045df7051222d605f25e56c0f9d12e4ed8ac74330b315a249d6dbb8a404c415aa5001eb289db8934c682520896276953f59d5a69f25b5f10ae3dec00fdba0d071225db83c8374670a86c5f85a83cf75581f2245b7b70938f435c949f0c6752b7b7e72588b9fe629a3e6b5ac81d4ef6c3b8ddbb712ad6d03a943b1afe776e5ac5b4523ed5668e2dc43c95e60d59e492539f0dbeeb10d79dc52a8476454de94625c45abc8bb49d867545fae77042f0fd45ba5461892b388368d284103f62048fe3ceda16e067b7c747009c58c4e75ed7f9e3adaf1cf14a8b68f92730acce7504b7a534a8b83c70b4346a7c44a48acca3d4ad27c7f083a52bcfcd481d6f8b3923a7d89a9b3df8f3cf292bbb7b4dfca6f4c6af026dc69dadb51711a4c776b30d1fcf92abc82e6e4e38e1c4f05739b592e819a39f9a870987efbebb7ac21fc60f4bdd050f36426862c762c9ae19bb42bfe9ebb596cb90f236fd04f10e61ceda405c6fb826f623ec94ad1493e3ed9aed9d30f3437bf3e7f69f39d9435b10146f0630f429449baddbf382670ac02e8aa5a51b83c265988f65d0368be79c4a9841f8a25accaef44d087a4725356d6074e5aeef61a6564f55e46cade6771943ca0961b415815a64b629ca78d1a58f43324618e23ac9a558095ee18061ac37528fc43ec0f02187900a2bd8d38e37592287cf8a12ac8755177b48c3103cd2afaabc4cef5754a4ded692c827188b5628e420956218db2e7be81f8bffc23228f7bc33ea84c3f7a3c85d38fd1157a3894f2c068f034ed04f1fa3c77b5836f3d1634f499491e9c98b6baa3d1b8623f9e7ca8430b96db59225e5f1222ab15b62c713a254a7a59a246dc937c763c0dc2df659af21676aab8ef473b3203ba0a3e6ceedc2866e1a22bd5c21572badafb69d463c0a408113519fcae71eae6d5055173e6417dfd78a3c1c99e945e74bcd4ab30205dcc5a373dd2357fa1ff288e9e45fb3fb79b2e953874f9164049d4e67e290a0f5e5a53db1eba1b69f16c9c63e3611551a8c2d47249e1c36fb6146a19fea4e37dc3651c3a2eb29fd14003cdab284a71e1d65ef8d79219425b08047c1123f26bf11507ffd60fac02552f285774c40b58fb923f8b3a801e656b1bd57646926e2f16e40bb6ae112426ae7f73af30bf1fe0d959bc888a16ae9bdba35e129fb82b5c13aec57b401ea56fc6fa033a6f71f6b74e1289545f4f088bf72f1ef6e1aa3ab4489ce3c0edeb5dafa2b775d87f8f543cb2a64c70fcd72514000fa00b13ec8c12044b9b883ffbd1df429d6c81e5127a179a5369be8402bc3db13b2038596e0a8f5b292f6e71e3c8189dbe5209eabe0b5dd0fd17fb7062d309f62211571eab53abd98bbb1ab1e7c8f7d31c33023254a16285d579ccb1666c1e87382928e28fdc63c1b6ae1bb7d107ce0e6b9188260d8a9f9d61aa3f455b8d3ea634bf9cf053090ac0078d66c76d1bae97438fec54536d02a85ff4b7ef3cc44f58442728f516819eab3f4d05820eb5d1e51fb0538a16dd4c9956e567f699ea43d69d1dbfc4c6fc41adb86d3f1fc945a8c98f25966b7009efe598cfb03d1a3421f4b728a650c28d16af9f902fa7d95c522b338935b9b5e7487871741e93915c00b976de0e6ad04469cedef587f0788e3dbbad5354be7a91e35d0f0dbdb5f21fb34d6b8bd6a11f63628f4a84c5fa413daff4040e0c703dc3d37e7f5d4354d9f55518220dee671cecf3f99ec42161d811ee26278777a7d3e77c5d2528bf065bbc5c1995b7eece4b0e9982ffd7507b745e3fe39683d19e397a0c9c83a6d9e699b628f5c48dfd09b2137d05036541b520cfd8a88e780f5c979584a623c4258b03d2616476491bb395ab55dd601b459040bfa3cd376242e3afeeb044cac690dfb92a26887f890a09061bff33d9a52a4b0e631500da79d368d4bed29d7ec2afadc7dc4e5d056f070f447d6052e02046aa4d42df8c58b2d9dbc5af39612591543a6def822cb1811a03f1c707686eb6a3a938480c1a30761a5e1822ac4d4ec202d54ddd5aad2cb73c44c792e1c75c5cc936a7f0c46d1bd60a030368d41e1e47cddee732d24a78f1568f9e17608353d62ef634df38cea6b9e391c8c6554d88c7f96edcc16e3fe69e29aef3770e1c8e1a47e29b43a6cc05940a9381c30cd1b397996818261527ef2f7004c862a117329df1bc44a1a4e666ca7451f120b8ed2db56190dee0e9f0ba6cc80e0992a647b01d0bec94b0a58eba250d5e52fdbb80eb549c943b9f917958e3cd3c7959aae757c22fd2c9d559aab61f8b59afaf57ee93b5af6af259c10fc2ba0515e061e01d49c9c04994cc02f82c3db1232a1200f4a0af5d7b311f47901e6c288da2a90e8b6171f7d500bae68ce0453b20c7fed94b2d2f8439b6f18cd5a5d0b30370107432ca2e745e18f24085f601d89ec0ef1634e1373ce9deb8660289421b16b61218568e6491960d6be33712aef48d22886d8ae2b47e2a282b247e2b2b6bf8358a4ad2cb2b63ba123d158710531474ad9558db9d18aa40ad013f6c50ab560b9b1c94c0949a3d80da35f20c6ae5f02bc544ffc8f9662d85ff45434a76597f35866ab8ee8f91525fca4b7dc79e73221fe714bf8263afd6cff1c51805af01f7fcb2fe16f41482aeeb6a982dfffbf7b8b3fc963512408f6db083fe80d01bd7e3754ea760f937cc9ee55bcfd8b8628d41bee8a8e55ab644aac09c1a3b52faa901c237cf3b555141f645fb8e81c9a6f99aac5cde3cd8b5446882d011fb78c190a592b85e75d335bdee91d2c0abd5cfb6afc6fe0f8e38217fc0481dbd49e24a86d5019e999314d5e6281ee10979e9221b829a4f7c7126219857c9b6afb3ca66ce38e9542c36b09595a7d5fcb9f34026b99a97e0867c64c21d93f2fed3908ffd82149b7d3bee734f12e0260c32736a504c45a5e020317b961471bd0565df2362019cdfce46a6643a2c7f0822b0a49444f541ec9e3eea3b37ccc8ccf686d8bf442ea8d26bcccc95b26c16e9c8e37c8f5fa050c3ceea211c31d2d1e4884efc111458cc28ea3eec646c53b6481e7363deb33a1051b6d8c3611609a9c55db3bde43bada192523e072f87a556b9676e75b2515d4b9889db43157c061f11c6b28a7d27603298dcdf4fd762dd9efd9261f1c970d351ac5e604f75b30c3d261ebf1aa25fd67ffbe8cce2ef0f5f2d0ac5c5a1aff1f46959ead6e36f8828b07461bd4d5a7899218c2dc1758dec77716af3ae1eede81c93ac877ce088ad271e8cad1987942d5c92af1e73e9bd23b5f8f4d38aa0264be6f7be0bb6f1ca34b6bda1dd7297535a19511e94cfc02de665410fdd64ff4489a5d77e74103adf61a2836a9a543350a2999cc555e866148aab036a2259fba6a3bf0be5e82e485e8fe8786df672b700ce6bc11981e731d4bf8b03e38ed77e2f45639adbf23b1baf41a3a8a75fadc8d56bbb39a36601022dd55de57e51bef138658dfcdb982202a8fed01934fe59688705257fb0a6a6ac78f43403ec1da101d8370c0b00c86e46b5d892c34b326094ce0159ac0964858512d1282840afbb90a5e4a48bcefbd6104600abe69aaad8a6a5a084d06d3977fb5ce8f3d48c2a3c2ca56f360d3ade6a286e2b4f5400862cb126a66b80f62eb63a54c98da5b25d39c892b86922fdd9ab0e4eec8d1871c5fb096475e17880ab2cd1a4804e0c3b56a01bf97c838776b114027fe6de77bd0c536575f3c94a947c119a9d92e5e1335048d57cce381d0cf044524f45b00c1f7eeadfb58d8b14d633c5eef4b6f71b8fb001a554226626eeed76ed91933c019e5de19caac00e88b2178d83667b89b485fb7df611d5ac0321bbc6fec85fbc7ae6a11c09a3e248f70b1700f7e38ce3d46820ca007fe14a31cb0f7e0de873363e858c3554bc4bbb920a5ffaafe0d5c6caae9bdb03ec9f961afc18bfc494778a4b1c373917f378aaab410f69b53b66b9044f54040e6b2f82327d8bb98f5932db79a9ab18d8682b8ba0541bfb92c2e3804aeba2f552eb707fa5a48caee9f4c43e65c71cb0c76d049307d0e7fe30f88835e41bcb233df3118bc804954e8d3893e98fbca11f4f0adfb9a278e6ec2c6697a800132cf000aa9f2aad5420ee9703f656785d75d27c6f071eff62d6070a92edd3cd5c0b459e33738ad3f879ed96ae150b0b65028f33e0892d450a984dde4306c8918efba7210ec63a748c0c6964fac0206db1f1b2dfbd25367623d7b3f9570cb8ac0203fc76596366c5aac473cb6af461cd60b2f0b19f8db76d2278d724e6ef2a8ce538f31e334ac9ba0b8d61372361aa74b750b561de9e67d0edeac965b3bf00c083c25f467693337496602c5896f4dc00b62f2be2aaed748b9a10d40c7a0bffcfbecc85798dcd2142a26aeb7c18d9b533353a74ee3f62763946cea166a2a6a0a7f69799f3a084eb7493ebb74eabe0ed2585824645f938a79f8e261d2999f31602ed44ed283c09764a3594c313e51509376d5bbab98d743388d9bb7aa21b16d50b77abc42e1b05aae80b0331256a2e2f0826aee8177dbc964fb450802882b97a34e9f7c5cf76e41ce1bb8b5c4017d4cb26fbdb57b2cef14f3415e72fcc851d3a5cbfddc625c69380cac33d95eecf153bab811bdc26044a39ff6e8731549ac1ee32e501c3c87c0a74e1abf052ebeba6da6fa0e4c17696b6fd98bc56cd5cc44d6d3bae2a794f0b6a601a9ed032f955b86614246321243867982641a57bfd55e4d8667e676da58a2aa10a5dc875474aa85c772b095996ead73a12f8d85d85c668fc704bafc433f102b58991d4d8af5d5483ac47f6fa1c6a0ee6053464429f24ef6467a0f50573f60075abe6309de96a1a8789fd255a2d088f60fcc14a54bb69a493518981dc9cc3116b5a1eb7da2e316babec7dee8fab95076408a368cb3f8ddedae039f75785794d0ea9ba1f37051c8529b5dc9ff70fa80f28b445df5f0c9c4930fe7513737207ad6313d5ae2ad1c342e1551fd531bd998d4290d807299abf8d0b3e584983c50ec3a60e4707d6377e629ed933db8611474a8a015c7f5901e35e37cf7f3eb241eb33c7a13ee2da88a395edd5bbdd065d1a692ff3869b563b277ad6cacf647efa858c8df872ce80c58bd251d17d4d3e40489bda27c6bbbd56c981c0b99a17900424ad4d2d1cd669694043b105f28fae4d3e7a410d15712699abcc4361f53ffd8a5c66677e3bc18c6c8bd1e50a020bad8d34f0f6586c10e2f28a3fb428247573a6753a5f3814a8c97d585ea14e93d23c11ce9f41afa8e231229b6596d841ef7ca23104a2054860e557ae1d24674b0e6c034e8c6a80d46edaf5c0ffff8de785b1ae4a2569c9b691c82ccceab6e9d1b6eb944257e0614a6cacb7ed294dfc0a52f0e110595875937f570fd3112771b666dd1d94f91c1af0eba1fb8bc05d42af81e8b38bfca736d7d02aa19448baedea9dbbcb90db90f1b14b3e738ec3ee1e375d850c90f9a7fd76baae74c35b1cf5b36239e9489b1705176a4839be8bb73a4480e2246eaeaacf9069bed4bf8675be51c07293d5adef5a718f82c27042573a80c956623e1707dc625db1f717185c811f2ad44d0f1e50c10166eac2d7c55ce2f9f1dd185b1325209044c62477d1247a79159f030113201aea885316d1754fcc61a9afc6ee816cb6711f2d612ca814d5e4cf6ad5391ad0a44a0714ea3d4be51ef661a43ca095c2a8598a9b3778ed8f7afce73f3edba4cf5a6eecc28d20aa6ec18a974cb0f55580462342546ee6629f368932034b8312c9caa9778a01d55d894428f91299603a4083fec28c003cb10069d270e2b10dbad142713016ff125a2202c37e03f196228a7e8b79c4199b5f3384a2cda086d64b06db33e8e80b934e39018734a127340620bb31f420fb68da51ce95cfb58a882ea126818b3adfb5ebbffe7a832f50b4a737befaa3de85f3e467a9d466e5f228a8db4cf8617afd304c50391605c2b88ae221c616774653f128fb8cbb8965fe166c0c667994964faa450ad5e1b3713a94f524979eea13afd8a582bb09ac6ea1d06d3cf620266170876b24936c710c33c73db7663fe10033964c29d72ceced9d9d6a8b94766aa73eb1810adae721a96e4e542d80135ba72dd6135f64587dbfa4232cb5b036d884735afb26ca787033a20f2ead2b580aac295e52f8b7884a21f5f241a1708ae36512abe160e9305f012bdf0fefe2a70dd51c71dbb0553c99b58ed3e6b7e9745b123cc55eba36b51cd8acd1fd8e81a8c207b07eeefd547ce94b566cd49baf220e8911e037d7c35d14e37f68206de3f0ce7a413cd06eec1f0560400776b9ae6b511459ff96cd9d0ec8da372799a9fc0bd19d5171b2f4e44e5c2604d5e767088ae4d5f4560d66aab2596f6c7c56737cb91a98e84cc616c995e7c0e3a7c464b8212cdf5a02cdd0a5628e8da0dbd849cece0aa14697003833cee2c289f99c32c414d4c9fb7ce5a97aaf82fb775e2f949cd322cbff44e52c24983a29d18b38a45d228270cfca423236210dd2de895fd24c198b73b87cd4d5ce9807fe795e4ee610a34360a564d9c939b88ccb70d8a6f12f58c57dc1e91860ac802c884c3eedb584ae05652a0a2cdbc550857f90bb55c876a4285446ae859eb027e753b6466276c5db1d6a2aedd27752b5675d73b5c14f952dadf1a712d60ba44c99ca8230cbb1f3d71704322c90d06b479a2e561703a9d0399eeb0072379471f1ff813e3aede8d50d44891e02389d15b1ae622f18693ee8bde6ab7387eff1dc18fdd4ff41f1819be830a335a2763b4f73697790792411ce8144e8a5e3f9c6485a86e050222e5b3f9f9dcc49a294bf785fc4e6dbed9f7ae1b911005aef3e97d969e7e11fa269e55012bfc5a6ad064bf6fbc7e8a270f3eb81beebaaa67031dcd776dd46239729e611009298043e24729a1c3fdf562690f06e16bfefba36f595910baedbee7c7aea040cf417af5ff0b6aec25662dd887d1c7e3ce4145d443009a261dc8ad59f40d16f187a74374bdda2c580524ee47c585ba09b5e6d19a8a26b86875a60cce3b692785c215148daf25f32477dfb534d4c200582b097746c6c29141756a3db076c2f270d0478279eca469dbd69b74c849cfe89f49876cd082d79911a92482ebe6e7e497824274d11e9c598a992ccc6ab3d5c80c43d45d4110d958aa912bb6a4bb387d677e4a735e72392e32d4ad89232eba291fa26e9ec7021ca86575b59347cb7d979af758713a829dd2a3191a21156b15c08a8af3144a89872c32de45a365bba64421100cd06c70eb430e771c20c4c0502ce089bb01ab307f411260751e34f60f8cd9091dedb7a8a38acb82fdcb76be477f3bc534ef8fe1642b96e4de48cbb592fba5389dda0904ef4495b4db3df43f30e356d598f8544990d8c3a9221dce9d53ffd6d200e8393a96e8ace4e333850726619ca211ee35460f9a9cbd0bdc524c85c8e02ae99ddcc3227f5d24b5f06ce11ef01ed78c81c5de96f8f2cad47b119af3744ca7f2db0f1ef8a1352095b7d60df6a1fe0c2dc4899de829d12d90d6433e69181f9ccb74e97eacef3ad3305071bc38a16997135a622b9858f4ba3658e211984a5abb8d3a39a11c098051ab4ef284a5fe99a80e798722e250f01a52c592e525d36ae869813765e6e7c7615049fa967d594d4a1d1b9790f09b6dde385a31c7e1f76c96cb8808916631c7f896fda46510f19d734aab39b2941787d8d5052290867158f495d1f9d9c05964ccda81c646dd1066e0cab3e8ebcf585105b19e86687ead88a76b09f47aabd1720ac84baf4d017ce5ca51716a49667237711bf13498d82ed7fbe79dd0e62169b60d610bc01a363096e6aa9fc263be3c430da66fb380b5f5ad5acdd9cfe5ad0368e992b9bf4f0433312c29712a1105d038467534ae5a90f801e8abe8ab472b04dd0804647bc3bb3d5b9404035304727973f8cd82b064923111c1c25a8bb10556909ef750898e3f3b3ae1cf6da197fb31bff367cab13627e1c8499edd62c4e71aa1049acbb9de68633ee2888b367eb4524e1d12583335daf82a6402cfbfa56427f85f2751138811231b7caaa9ea40e1a2130ec8365b993bb22d4f489d8e0446db424d0abddd7b17d6cfb012ac3fadd0953dee59cec633367865aa735df272062dd1a48c4180a7ab61596a94d404afdef1887ab5c3190cd391b10cc7dd478cb72ca84e4e8f3866f6141dd7cf13c8976f48685c2bce10aab8ee4fcbda7ad1930c6583cc399486263c0c290acdd18e505efae4c1c8c8f80f0661175e37a818ac491f647357957cda803f40c3d8a43cae4419fd000d3d3c0268ae6c35b0721372abac0639c1cb01ac70a9e8c8e6e84a49a3982b2ec6df9a81fcb1c3112c6394e3432b3698df4a61b7326c16ba9484c7b4162a64ff2414b51d7add27bf481d0a282a8ad242b478798ad3316c3dd6e030b7c89f1a2d3f060fdb779a161714521688864f8b96a262c4c995aee15471e1dfd7cef0647365c8afc8dfa9792a328a195416fb505f7ef9858921268cf253f7dfd8b29223e5a06a5adabd24d8c2adf77c3ceb9071f0e0615dac38cab7780a449d79b92e1c5ea22a162ad1788eea2d0dfceed9c24e8c4bd3d707fb5f5bf9e5e3b359bbcc8ca3b588a1eeaf714cc16fcc937418fe3ad1ea553033cfeb438581df0d2bc7a606deab69253ed8771e45c65159ee6fd11549cddf314b8c4ccc63921620fab98972ec7f816fc5cde384f0bd52e810d33f1f1bb728ae80aeed4e2a4a95dcbae95a6126d097a4e0425402f8f7e30c8668874ea158dd3353f8ab87015f9eec0860c139c6831efda2f8bbf67e11bb063d51cca527f7b9aa867f672f7000d7594541e96984e99bd7cbeb658a6803361ca5ad918291804071279b92dcac965609aa72bb8f83bd309d7773042d72eb51eacf61d04ff96b6b6a6bdb5929745563ddc1872b5201c23fe1b4cf7445b0dbf7dd81eea8da1800b8a1c190ae04c3497222995c5c724e39c9601419b0cc61ed1ed182d0d7168c6c1b64227554e6d48670043fc685fad196f1a45f6e89cc265767fc2077e5863a9b0b9dddaab29957757ae8d802b2fb19f4b842590f541b779165c6f698e532b57773d77e8de3a6934404117cbba652e94fd9bcaf83c7e7f4a2481e4ea1ce7813b543eeac79d6807b492cbc23d3b5fda0786c931a5dd1558a47725649e6b58b2a0966812be5fe9a270a99fd8a5183f12c1ec670972f59ad6ccc98c3da3e0f5b47f4d4c8d0b0bc081b06594597e7af0a8df9c2825eb9341973a5fde0443789de1d257a4d31ccb0432677209967b5449bad1721c4ec3d0f2c5cb7c3fe5f4fc168c22ff4fd8c716c8079173b5b2066ff7a34e2e87469cf82910367cc2c320a66f00ce40b6040244d64e22d2013e62816f3a9f1171cbcd03b8cacd8867103441ad1f755f8108f646cb1d374c40ba4feb1b1a7877989042f91e66e536139bdc396c9b63ad74f73493cd9b88b8e286c959945d456acd8d4566da9a1034648ef2b01a7b077d75e9873eadd975930a1f0b79d565f3e37f0639c88c056699ee1c1b353a2e00174f69b2a929ecf0d87f1fdb00b3f557b78276d77f0a5fd439f43bf5330b43b01fac57fbf3746814e0e28acb541cb589c2ac461fc50c425c729c151d64cd14842ee973ce85f6f7e6ec11ab9738ec2e67a7b4672a991a5cc7de76035d480ffad02f3402e385365113a0687c38ddc7df8243c61681016943b1fe448a5c4f8bb761e711878dbe4a8fc99f466ed858253e63db8248a1a2ae5f5d8efe52e274aa889ec4b24b49e90f44b8a02d8a4a37f70633dfba24bb709d5052120a08b391c4c6bf45fa0f4bda404cda5f4e1ecdff7362bc7c9fe72d95aa1c8cabff24cc685efc8d1f1f529ab71ff7fb5777d4ad5bfd8a57cc7f7ee9cb0ff921117ae6138c1fcfb70ef1f756e7fcfa3bb9c9929b6bc5ac07bc634784216266bbfa5de8abbc562a1f65fc1bb3181b1cb999fe04729286d9beff9fb23ae9d03bc1fe427f4de2de964d650a498d4fc2f0b4d07fcc3e3c7ff82a74ddcaee207631fd5109d1d5d8f48899c72e3f83154e7db25116bd7fe943d3a789494a8a20a546f35b80b3b133aef050de74af8203d248babd65414f36cdebd76b92b3c60d7414c7cfdee0d6422b6eb651f0dd2f2f59f932b1961ffecf34d0a62ab264b33889e7ffcd0ecdcc692f34258192c23f5f3c6ac29cfaa755ae71e554cedddfb0e1eeb8ce596f86ebc68265f9a40260bbbd8a18beb205798848d0ea8a0abe4094cf2664053fdd6b6034e734e50a258de9e96ea40b78e3c3aac8365d26babda71b8eac2d5c7beaf9e147976d90d7abe72309ab726dc249ae34955e625309db6329198ec4f411f40343522116bbf9e473a06b3511fa04f57783793e174a9a708f38a87f0426dded7b6bf8322d3e5cd0416d3fccc149fd3589c92dd02c56430d24bb4a3544d1e7fc93c445a323f352218e71b5dd594cf7c1ffbd6b46286042c94a11059991b4ada76d74b9c2f4261ab86885eaf3d7ab70b188771d2eb7b4cda558ed6fcae8cda0dab9a38a4bc952daf6ce90e192ced8209c12ed57ce5755190c830291581d4c1bb447eb076818cdfce5d1cc83416cf05ba83c46a08635730952016783a13773e6ee9be36d2346b79aa174988adb96a8494696d2e209d13e68817a1a17a4dd3c5150e8d1c2022a513543d2b1f1a3f9f3c70813357ced5f041d6e0fd2fe7ca765ecb41da743652bc07d21c0c1b54da78ee251785d6c7cbd394cb18509c3dcfb10425d677ada4440d1de04186f96bfc4e0875874d9cf5b1a42519cc1a6be00f65093c29a6bace2b422d5a8084d32e65b53257eb6131c3e963d16d7ec2fce7c869c36c989073c604360f83bb68821e4a1ead3fb1aba7fc8ebd48e0dc537f8893b3427d177c1a9511bc5bd9fd90d39d9cb4886a81f9967d9624ef0c97eac902e8a975164b37c607ba107722039d01075e9ca8260b7d461704b8c2f5f27c33a1af787db6442a668838aaf90e50fbcd42f58cc965af3262555bb972c142e3b664adbabbcb6158dfa2dcdf9bbaaaab2596b5e2d64b2688924ba209e49f5dd33e188973bd8a12c2893d96bacf0578815e53c02344c5efdc2453453052fae7fffa7fb55ecab4a53ce3e7f7bb5136f4d63aac3cef32e8b769d8e90f4e29efd39659a39ce8874ffa1b8e99dad359b112ac43239521334f348aa339324c53471df96c3ee7b1f3c38189224679063a6385a691581a97abee9df7f91ce2ab1f84f9962b519bf07ade3aca48d6b722a8e1074ff2285a95cd0a7076a4f4603dd05f41ce1e955575991a3b5313fbaf893f132f827bbdf963ca24ad9211d714cf2c80bbb48feb37a8b4fc280fbf0f4323bc3168e0a2299a26c723aebe573191f5655b15e3d9fee1168b27bbaea1e5e5e9e2484a2802465c022e3fce54e7c074e6f66f40565dc7e627ff7e84a368e920a2b65d0c363fb0a5dc49547fbb4e9a924f1ea059ec781c3cae36edada697f615bff11d189923df2cba7a890890d401be7f04483904a35c01d4c9566577ed342854eb84432453e75e2e14fa3dec125f13740a1324c8e51c7778cdc655244fcb93f9bd9866a1864a729dd54b9b243b9ebcf7cd6051aeaa5684ff48c6ac09bcab98b6c92c40e8a3fa7376eb19d8eacc11538e84f8397ec56c4a53b5345dd8352caeab3cc65ef0cdce20d31c7d7d21a9396690ed15c31b90efa27f3c3dd0f2d5bd7adfaf4630f1d5678c4ab4c28b51c7ddfaeadd9cca8f7b1aac5482b90ca7047a997cc2c4d86a4905920c79e8ef46b8f5e6a6c35ba93aca1e46a7db08d0f8f02d573c73a6572fdaf184d76f9c0724fe2bacd43ac999a8dbe2c2a803252d5146dcb79736722f41ed00c7e5726b6bc6048d318749fb011014b7f8dc2400a595df372c42ba7b5ee03df9b5060e999ad8985f5ac3872c2cc8eed55220c09a7befdd58524487b040a0a9debea8b5409bb9e513d3e0087c8f259514fee558c6221fe979db877f357344694df85d79c550dacf6cda8b7ef4f9efab1e3c1421ebaf36de095bf10eb73860aab203c041cd44858bf871c6dd5b59b32ccc211cb7a3352b2135c4900283889b2e59c95febabfcd6d6f39ef782aeafa8b8cce3dc6d11ac668443b3aaa5f7767519f11d2591297871da5e8635984cd0e5f2f3ed51c9a7e74a586a9419eef8795202297ffc96b8997ffa2beb65efecffe85cede901d381f49d99a6b343d2b8d704e5c09d1ae5ff9ff59c431b4a2a5360f459c34b8a027be8f038c5992c653fd81684242d40cc338138f6035e32acf8e548f6bab3a25e21045dc22d53fec52a7c13762646cc68bd80a9bd85338fc3d33a74b24b30dff6c2da28f3305ece7691f3ebf6ea6ac2be32bac7f8233b4f392917448c82964513f937a3e2c6598afbdf7d9a66ee559f63be6906a2a996386fc16bbe284f82144e2b0653bd4ef7b9b4791d7b6d6fe30f85c597e51fdd3d92a0a32799791a3815b42ccdb5045e626d8bee860ff9a2c1e1ca655b1d18ddd63bd1a1c933ba6ca067aeb41e69164a42398cb06696cdacb7cb1de580d3a6d32dbf245a8ea6fbb121aed8a69d744b00ea0314d3cd7af3817979130c3a3d06436c9b7d58abf45a561fe19b189361ed60d97d6b644f4ccf5d2f859f08e8a7b64b700f1b92c31336e003dafe4f04fe0b08cda369b10070148f751ba0c9fa5fe37a9ebaf4a48a7cd79b30c3eacf12a5a85b63d053bbdba5efa5d639b527ac14ba2c661c15466abc64322303004e97311b7e4258e40a2698971b505a465525293d690ab26eae69a9d68018b4d38c044b94bd1b11ccf7bed93f79210c3083df7ffa4f40ab28dcc430cdecc08d70097e2ec60bde41aebb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">🐶嘿嘿, 你没有权限进入呢！🐕.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.1 BFS中的Flood Fill和最短路模型</title>
      <link href="/2023/01/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-20230131-2-1-1-BFS%E4%B8%AD%E7%9A%84Flood-Fill%E5%92%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/01/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-20230131-2-1-1-BFS%E4%B8%AD%E7%9A%84Flood-Fill%E5%92%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-1-BFS中的Flood-Fill和最短路模型">2.1.1 BFS中的Flood Fill和最短路模型</h1><h2 id="BFS特点">BFS特点</h2><ol><li class="lvl-3"><p>求最小-&gt;第一次搜到恰为最小距离</p></li><li class="lvl-3"><p>基于迭代，不会爆栈（一般1M，十万层）</p></li></ol><p>类型最小距离-&gt;从内部一点到另一点的最小距离<br>eg.走迷宫</p><p>最小步数-&gt;整体视为一个状态，状态的变换的最小步数(状态本身作为一个点，每次变换视为一步，问题是状态之间的逻辑关系)<br>eg.八数码</p><h2 id="一-Flood-Fill算法">一. Flood Fill算法</h2><p>可以在线性时间复杂度内，找到某个点所在的连通块</p><p>使用BFS的过程模拟洪水覆盖的过程–从四周开始扩散–填充整个连通块</p><p>连通类型四连通八连通</p><h3 id="1-AcWing-1097-池塘计数">1. <a href="https://www.acwing.com/problem/content/1099/">AcWing 1097. 池塘计数</a></h3><p>注意双层逻辑：先遍历每个格子，每个格子再进行BFS搜索过程。需进行标记–判重。</p><p>BFS使用队列实现，队列中存储下标，二维时可以使用pair</p><p>注意是否开始搜索的判断条件要想清楚</p><p>搜索时注意遍历方法和边界条件</p><h4 id="C">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS中的Flood Fill——AcWing 1097. 池塘计数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 存图，注意使用char</span></span><br><span class="line">PII q[M]; <span class="comment">// 数组模拟队列时，数组大小为所有元素大小</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 标记是否搜索过，避免重复</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入坐标位置参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 数组模拟队列。bfs基于迭代，每次调用使用一个队列</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;<span class="comment">// 初始化</span></span><br><span class="line">    <span class="comment">// 分别标记队列要取出结点的位置，存取结点的前一个位置</span></span><br><span class="line">    </span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    <span class="comment">// 初始状态入队列</span></span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 进行标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        PII t = q[hh ++]; <span class="comment">// 取出队头元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展队列元素</span></span><br><span class="line">        <span class="comment">// 枚举所有可能的移动方向</span></span><br><span class="line">        <span class="comment">// 注意区分四连通和八连通</span></span><br><span class="line">        <span class="comment">// 这里要注意八的遍历方式</span></span><br><span class="line">        <span class="comment">// 暴力枚举3 X 3 矩阵并挖掉中间格子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.x - <span class="number">1</span>; i &lt;= t.x + <span class="number">1</span>;++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.y - <span class="number">1</span>; j &lt;= t.y + <span class="number">1</span>; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i == t.x &amp;&amp; j == t.y) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 挖掉中间格子</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m)  </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 注意判断是否越界</span></span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;.&#x27;</span> || st[i][j])      </span><br><span class="line">                <span class="comment">// 是否满足条件 </span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q[++ tt] = &#123;i, j&#125;;</span><br><span class="line">                <span class="comment">// 满足条件的入列</span></span><br><span class="line">                st[i][j] = <span class="literal">true</span>; </span><br><span class="line">                <span class="comment">// 标记已搜索过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]); </span><br><span class="line">    <span class="comment">// 注意采用字符串读取方式</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 要记录的量：连通块的数量</span></span><br><span class="line">    <span class="comment">// 从头到尾依次遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !st[i][j]) </span><br><span class="line">            <span class="comment">// 是否满足条件</span></span><br><span class="line">            <span class="comment">// 这里的代码的书写的思路是要掌握的，一定不要乱，不要寻求直接找到符合条件的再遍历，而是全部遍历再判断是否符合条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j);</span><br><span class="line">                <span class="comment">// 符合条件的进行广度优先搜索</span></span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="python">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的Flood Fill——AcWing 1097. 池塘计数</span></span><br><span class="line"><span class="comment"># 使用库函数deque，速度更快</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="comment"># 双向队列deque是栈和队列的一种广义实现，是类似于list的容器，可以快速的在队列头部和尾部添加、删除元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里没有另开查重数组，通过直接改变原数组实现标记</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    d_x = (-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    d_y = (-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 不能使用st = [[False]*m]*n这种写法</span></span><br><span class="line">    <span class="comment"># [[0]*n]*m这种方式是直接将[0]*n复制了m遍，是=号复制（注意不是浅拷贝，=与浅拷贝的list id是不同的），</span></span><br><span class="line">    <span class="comment"># 若[0]*n发生了更改，则m个都发生更改。[0]*n作为一个list被共享。</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q = deque([(sx, sy)])</span><br><span class="line">        g[sx][sy] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> <span class="built_in">zip</span>(d_x, d_y):</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m <span class="keyword">and</span> g[nx][ny] == <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                    q.append((nx, ny))</span><br><span class="line">                    g[nx][ny] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(g):</span><br><span class="line">        <span class="keyword">for</span> j, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(line):</span><br><span class="line">            <span class="keyword">if</span> ch == <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                bfs(i, j)</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># // BFS中的Flood Fill——AcWing 1097. 池塘计数</span></span><br><span class="line"><span class="comment"># 数组模拟队列    </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    d_x = (-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    d_y = (-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    q = [<span class="number">0</span>] * (n * m)</span><br><span class="line">    st = [[<span class="literal">False</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="comment"># 不能使用st = [[False]*m]*n这种写法</span></span><br><span class="line">    <span class="comment"># [[0]*n]*m这种方式是直接将[0]*n复制了m遍，是=号复制（注意不是浅拷贝，=与浅拷贝的list id是不同的），</span></span><br><span class="line">    <span class="comment"># 若[0]*n发生了更改，则m个都发生更改。[0]*n作为一个list被共享。</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        hh, tt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        q[<span class="number">0</span>] = (sx, sy)</span><br><span class="line">        st[sx][sy] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> hh &lt;= tt:</span><br><span class="line">            x, y = q[hh]</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> <span class="built_in">zip</span>(d_x, d_y):</span><br><span class="line">                nx, ny = x + dx, y + dy</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; m <span class="keyword">and</span> g[nx][ny] == <span class="string">&#x27;W&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> st[nx][ny]:</span><br><span class="line">                    tt += <span class="number">1</span></span><br><span class="line">                    q[tt] = (nx, ny)</span><br><span class="line">                    st[nx][ny] = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> g[i][j] == <span class="string">&#x27;W&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                bfs(i, j)</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-1098-城堡问题">2. <a href="https://www.acwing.com/problem/content/1100/">AcWing 1098. 城堡问题</a></h3><p>四连通遍历</p><p>取二进制中第k位<br>x &gt;&gt; k &amp; 1<br>本题注意二进制解码的方法</p><h4 id="C-2">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS中的Flood Fill——AcWing 1098. 城堡问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 四连通时的写法</span></span><br><span class="line">    <span class="comment">// 常用技巧：使用偏移量表示移动方向</span></span><br><span class="line">    <span class="comment">// 注意这里的方向顺序必须和西北东南的顺序相对应</span></span><br><span class="line">    <span class="comment">// 只是为了方便后面进行二进制解码</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 分别标记队列要取出结点的位置，存取结点的前一个位置</span></span><br><span class="line">    <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    <span class="comment">// 初始状态入队</span></span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        PII t = q[hh ++];</span><br><span class="line">        area ++; </span><br><span class="line">        <span class="comment">// 可以在出队时统计，可以在入队时统计</span></span><br><span class="line">        <span class="comment">// 这里为了避免第一个忘统计，在出队时统计</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展队列元素</span></span><br><span class="line">        <span class="comment">// 枚举所有可能的移动方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 越界判断</span></span><br><span class="line">            <span class="keyword">if</span> (st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[t.x][t.y] &gt;&gt; i &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 使用位运算，解码二进制</span></span><br><span class="line">            <span class="comment">// x &gt;&gt; i &amp; 1 取出x二进制的第i位</span></span><br><span class="line">            <span class="comment">// 根据第i位是否为1判断是否有墙</span></span><br><span class="line">            <span class="comment">// 这里的顺序能成立是因为按照了西北东南的顺序，</span></span><br><span class="line">            <span class="comment">//且题目规定用1表示西墙，2表示北墙，4表示东墙，8表示南墙</span></span><br><span class="line">            q[++ tt] = &#123;a, b&#125;;</span><br><span class="line">            <span class="comment">// 符合条件的元素入队</span></span><br><span class="line">            st[a][b] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, area = <span class="number">0</span>; <span class="comment">// 要记录的量：连通块数量和大小（面积）</span></span><br><span class="line">    <span class="comment">// 全部遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])&#123;</span><br><span class="line">                area = <span class="built_in">max</span>(area, <span class="built_in">bfs</span>(i, j));</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-2">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的Flood Fill——AcWing 1098. 城堡问题</span></span><br><span class="line"><span class="comment"># 使用库函数deque</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    d_x = [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    d_y = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    st = [[<span class="literal">False</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q = deque([[sx, sy]])</span><br><span class="line">        st[sx][sy] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 不能使用st = [[False]*m]*n这种写法</span></span><br><span class="line">        <span class="comment"># [[0]*n]*m这种方式是直接将[0]*n复制了m遍，是=号复制（注意不是浅拷贝，=与浅拷贝的list id是不同的），</span></span><br><span class="line">        <span class="comment"># 若[0]*n发生了更改，则m个都发生更改。[0]*n作为一个list被共享。</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            area += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                nx, ny = x + d_x[i], y + d_y[i]</span><br><span class="line">                <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= n <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> ny &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> st[nx][ny]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> g[x][y] &gt;&gt; i &amp; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                q.append([nx, ny])</span><br><span class="line">                st[nx][ny] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> area</span><br><span class="line">    </span><br><span class="line">    cnt, area = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                area = <span class="built_in">max</span>(area, bfs(i, j))</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line">    <span class="built_in">print</span>(area)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的Flood Fill——AcWing 1098. 城堡问题</span></span><br><span class="line"><span class="comment"># 数组模拟队列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    d_x = [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    d_y = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    st = [[<span class="literal">False</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    q = [<span class="number">0</span>] *(m*n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q[<span class="number">0</span>] = [sx, sy]</span><br><span class="line">        st[sx][sy] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 不能使用st = [[False]*m]*n这种写法</span></span><br><span class="line">        <span class="comment"># [[0]*n]*m这种方式是直接将[0]*n复制了m遍，是=号复制（注意不是浅拷贝，=与浅拷贝的list id是不同的），</span></span><br><span class="line">        <span class="comment"># 若[0]*n发生了更改，则m个都发生更改。[0]*n作为一个list被共享。</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        hh, tt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> hh &lt;= tt:</span><br><span class="line">            x, y = q[hh]</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">            area += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                nx, ny = x + d_x[i], y + d_y[i]</span><br><span class="line">                <span class="keyword">if</span> nx &lt; <span class="number">0</span> <span class="keyword">or</span> nx &gt;= n <span class="keyword">or</span> ny &lt; <span class="number">0</span> <span class="keyword">or</span> ny &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> st[nx][ny]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> g[x][y] &gt;&gt; i &amp; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                tt += <span class="number">1</span></span><br><span class="line">                q[tt] = [nx, ny]</span><br><span class="line">                st[nx][ny] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> area</span><br><span class="line">    </span><br><span class="line">    cnt, area = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                area = <span class="built_in">max</span>(area, bfs(i, j))</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line">    <span class="built_in">print</span>(area)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="3-AcWing-1106-山峰和山谷">3. <a href="https://www.acwing.com/problem/content/1108/">AcWing 1106. 山峰和山谷</a></h3><p>本题要判断每个方格和周围方格的关系</p><h4 id="C-3">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS中的Flood Fill——AcWing 1106. 山峰和山谷</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy, <span class="type">bool</span> &amp; has_higher, <span class="type">bool</span> &amp; has_lower)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span> ,tt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 分别标记队列要取出结点的位置，存取结点的前一个位置</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    <span class="comment">// 初始状态入队</span></span><br><span class="line">    st[sx][sy] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123; <span class="comment">// 队列不为空</span></span><br><span class="line">        PII t = q[hh ++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = t.x - <span class="number">1</span>; i &lt;= t.x + <span class="number">1</span>; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t.y - <span class="number">1</span>; j &lt;= t.y + <span class="number">1</span>; ++ j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 判断是否越界</span></span><br><span class="line">                <span class="keyword">if</span> (h[i][j] != h[t.x][t.y])&#123;</span><br><span class="line">                    <span class="comment">// 判断与周围方格的高度关系</span></span><br><span class="line">                        <span class="keyword">if</span> (h[i][j] &gt; h[t.x][t.y]) has_higher = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span> has_lower = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">// 不能提前结束遍历</span></span><br><span class="line">                        <span class="comment">// 要把整个连通块都遍历一遍，防止重复</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!st[i][j])&#123;</span><br><span class="line">                        q[++ tt] = &#123;i, j&#125;;</span><br><span class="line">                        <span class="comment">// 入队列</span></span><br><span class="line">                        st[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 注意这里不能先写if(st[i][j]) continue;</span></span><br><span class="line">                <span class="comment">// 只有未遍历过的才能入队列，但在判断四周是否有高低点时与四周点是否遍历过无关</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> peak = <span class="number">0</span>, valley = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用来记录山峰和山谷数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有方格</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n;++ j)</span><br><span class="line">            <span class="keyword">if</span> (!st[i][j])&#123;</span><br><span class="line">                <span class="type">bool</span> has_higher = <span class="literal">false</span>, has_lower = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bfs</span>(i, j, has_higher, has_lower);</span><br><span class="line">                <span class="keyword">if</span> (!has_higher) peak ++;</span><br><span class="line">                <span class="keyword">if</span> (!has_lower) valley ++;</span><br><span class="line">                <span class="comment">// 这里注意不能使用else，一片区域可能同时成为山峰和山谷</span></span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, peak, valley);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="python-3">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的Flood Fill——AcWing 1106. 山峰和山谷</span></span><br><span class="line"><span class="comment"># 使用库函数deque</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    h = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    st = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q = deque([[sx, sy]])</span><br><span class="line">        st[sx][sy] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        has_higher, has_lower = <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 已经在遍历时判断有不相等</span></span><br><span class="line">        <span class="comment"># 注意这里的逆思维</span></span><br><span class="line">        <span class="comment"># 大于周围所有-&gt;山峰，小于周围所有-&gt;山谷</span></span><br><span class="line">        <span class="comment"># 不存在大于周围-&gt;是山谷, 不存在小于周围-&gt;是山峰</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x - <span class="number">1</span>, x + <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y - <span class="number">1</span>, y + <span class="number">2</span>):</span><br><span class="line">                    <span class="keyword">if</span> i == x <span class="keyword">and</span> j == y: </span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 注意这里的逻辑顺序</span></span><br><span class="line">                    <span class="keyword">if</span> h[i][j] &gt; h[x][y]:</span><br><span class="line">                        has_higher = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> h[i][j] &lt; h[x][y]:</span><br><span class="line">                        has_lower = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                        <span class="comment"># 只有相等的才会入队列</span></span><br><span class="line">                        q.append([i, j])</span><br><span class="line">                        st[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> has_higher, has_lower</span><br><span class="line">                  </span><br><span class="line">    peak, valley = <span class="number">0</span>, <span class="number">0</span>   </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                has_higher, has_lower = bfs(i, j)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_higher: peak += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_lower: valley += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(peak, valley)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的Flood Fill——AcWing 1106. 山峰和山谷</span></span><br><span class="line"><span class="comment"># 数组模拟队列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    h = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    st = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    q = [<span class="number">0</span>] * (n*n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q[<span class="number">0</span>] = (sx, sy)</span><br><span class="line">        st[sx][sy] = <span class="literal">True</span>;</span><br><span class="line">        hh, tt = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        has_higher , has_lower = <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> hh &lt;= tt:</span><br><span class="line">            x, y = q[hh]</span><br><span class="line">            hh += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x - <span class="number">1</span>, x + <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y - <span class="number">1</span>, y + <span class="number">2</span>):</span><br><span class="line">                    <span class="keyword">if</span> i == x <span class="keyword">and</span> j == y:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= n:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> h[i][j] &gt; h[x][y]:</span><br><span class="line">                        has_higher = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> h[i][j] &lt; h[x][y]:</span><br><span class="line">                        has_lower = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                        tt += <span class="number">1</span></span><br><span class="line">                        q[tt] = (i, j)</span><br><span class="line">                        st[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> has_higher, has_lower</span><br><span class="line">    </span><br><span class="line">    peak, vallery = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> st[i][j]:</span><br><span class="line">                has_higher, has_lower = bfs(i, j)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_higher: peak += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_lower: vallery += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(peak, vallery)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="二-最短路模型">二. 最短路模型</h2><p>宽搜具有最短路性质：</p><p>当所有边的权重相等时，使用宽搜可以在线性复杂度内得到起点到所有点的最短路（单源最短路）。</p><p>第一次搜到一定是最短的，不需要记录额外的距离信息。</p><p>特殊的dijkstra算法-&gt;权重相同时，按层搜索使队列为优先队列</p><h3 id="1-AcWing-1076-迷宫问题">1.  <a href="https://www.acwing.com/problem/content/1078/">AcWing 1076. 迷宫问题</a></h3><h4 id="C-4">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS中的最短路模型——AcWing 1076. 迷宫问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line">PII pre[N][N];</span><br><span class="line"><span class="comment">// pre记录最短路中当前位置的前一个位置（从哪个点过来的），也起到了st数组的作用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">    pre[sx][sy] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        PII t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; ++ i)&#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (pre[a][b].x != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            q[++ tt] = &#123;a, b&#125;;</span><br><span class="line">            pre[a][b] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;g[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从终点往起点搜，避免反推路径时的缓存数组</span></span><br><span class="line">    <span class="built_in">bfs</span>(n - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function">PII <span class="title">end</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 推出路径</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, end.x, end.y);</span><br><span class="line">        <span class="comment">// 不能直接判断end == &#123;n-1, n-1&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (end.x == n - <span class="number">1</span>&amp;&amp; end.y == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        end = pre[end.x][end.y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-4">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的最短路模型——AcWing 1076. 迷宫问题 </span></span><br><span class="line"><span class="comment"># 使用库函数deque</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    g = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    pre = [[[-<span class="number">1</span>, -<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dx = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    dy = [<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">sx, sy</span>):</span><br><span class="line">        q = deque([[sx, sy]]);</span><br><span class="line">        pre[sx][sy] = [sx, sy]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>):</span><br><span class="line">                a = x + dx[i]</span><br><span class="line">                b = y + dy[i]</span><br><span class="line">                <span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">or</span> a &gt;= n <span class="keyword">or</span> b &lt; <span class="number">0</span> <span class="keyword">or</span> b &gt;= n:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> g[a][b] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># if pre[a][b] != [-1, -1]:</span></span><br><span class="line">                <span class="comment">#     continue</span></span><br><span class="line">                g[a][b] = <span class="number">1</span></span><br><span class="line">                q.append([a, b])</span><br><span class="line">                pre[a][b] = [x, y]</span><br><span class="line">                    </span><br><span class="line">    bfs(n - <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(i, j)</span><br><span class="line">        <span class="keyword">if</span> i == n - <span class="number">1</span> <span class="keyword">and</span> j == n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i, j = pre[i][j]</span><br><span class="line">                    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="2-AcWing-188-武士风度的牛">2.<a href="https://www.acwing.com/problem/content/190/">AcWing 188. 武士风度的牛</a></h3><h4 id="C-5">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS中的最短路模型——AcWing 188. 武士风度的牛</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">155</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line">PII q[M];</span><br><span class="line"><span class="type">int</span> dist[N][N]; <span class="comment">// 距离数组，保存距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 移动方式， 注意这里以“日”的方式移动</span></span><br><span class="line">    <span class="type">int</span> dx[] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 起点</span></span><br><span class="line">    <span class="type">int</span> sx, sy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">    </span><br><span class="line">    q[<span class="number">0</span>] = &#123;sx, sy&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// 初始化标记</span></span><br><span class="line">    dist[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        PII t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++ i)&#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;*&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[a][b] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 判断终点，直接返回--bfs具有最短路特性，得到的距离一定是最短距离，无需额外判断</span></span><br><span class="line">            <span class="keyword">if</span> (g[a][b] == <span class="string">&#x27;H&#x27;</span>) <span class="keyword">return</span> dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">            q[++ tt] = &#123;a, b&#125;;</span><br><span class="line">            dist[a][b] = dist[t.x][t.y] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, g[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-5">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的最短路模型——AcWing 1076. 迷宫问题 </span></span><br><span class="line"><span class="comment"># 使用库函数deque</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    m, n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    g = [<span class="built_in">input</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dist = [[-<span class="number">1</span>] * m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dx = [-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    dy = [-<span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>():</span><br><span class="line">        sx, sy = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> g[i][j] == <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line">                    sx, sy = i, j</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        q = deque([[sx, sy]])</span><br><span class="line">        dist[sx][sy] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">                a, b = x + dx[i], y + dy[i]</span><br><span class="line">                <span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">or</span> a &gt;= n <span class="keyword">or</span> b &lt; <span class="number">0</span> <span class="keyword">or</span> b &gt;= m:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> g[a][b] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> dist[a][b] != -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> g[a][b] == <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> dist[x][y] + <span class="number">1</span></span><br><span class="line">                q.append([a, b])</span><br><span class="line">                dist[a][b] = dist[x][y] + <span class="number">1</span>   </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(bfs())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="3-AcWing-1100-抓住那头牛">3.<a href="https://www.acwing.com/problem/content/1102/">AcWing 1100. 抓住那头牛</a></h3><p>这里注意问题的转化，要有建图思想，转化为图的搜索问题</p><p>注意确定路径范围的上限</p><h4 id="C-6">C++</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS中的最短路模型——AcWing 1100. 抓住那头牛</span></span><br><span class="line"><span class="comment">// 注意问题的转化，要有建图思想，转化为图的搜索问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 注意确定路径范围的上限</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">-1</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[n] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (t == k) <span class="keyword">return</span> dist[k];</span><br><span class="line">        <span class="comment">// 转化为图</span></span><br><span class="line">        <span class="comment">// 每种移动方式表明存在边相连</span></span><br><span class="line">        <span class="keyword">if</span> (t + <span class="number">1</span> &lt; N &amp;&amp; dist[t + <span class="number">1</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">            q[++ tt] = t + <span class="number">1</span>;</span><br><span class="line">            dist[t + <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; dist[t - <span class="number">1</span>] == <span class="number">-1</span>)&#123;</span><br><span class="line">            q[++ tt] = t - <span class="number">1</span>;</span><br><span class="line">            dist[t - <span class="number">1</span>] = dist[t] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * t &lt; N &amp;&amp; dist[<span class="number">2</span> * t] == <span class="number">-1</span>)&#123;</span><br><span class="line">            q[++ tt] = <span class="number">2</span> * t;</span><br><span class="line">            dist[<span class="number">2</span> * t] = dist[t] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python-6">python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BFS中的最短路模型——AcWing 1100. 抓住那头牛</span></span><br><span class="line"><span class="comment"># 注意问题的转化，要有建图思想，转化为图的搜索问题</span></span><br><span class="line"><span class="comment"># 使用库函数deque</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    b = <span class="number">200010</span></span><br><span class="line">    n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    dist = [-<span class="number">1</span>] * b</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bfs</span>():</span><br><span class="line">        q = deque([n])</span><br><span class="line">        dist[n] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            t = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> (t == k):</span><br><span class="line">                <span class="keyword">return</span> dist[k]</span><br><span class="line">            <span class="keyword">if</span> (t - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> dist[t - <span class="number">1</span>] == -<span class="number">1</span>):</span><br><span class="line">                q.append(t - <span class="number">1</span>)</span><br><span class="line">                dist[t - <span class="number">1</span>] = dist[t] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (t + <span class="number">1</span> &lt; b <span class="keyword">and</span> dist[t + <span class="number">1</span>] == -<span class="number">1</span>):</span><br><span class="line">                q.append(t + <span class="number">1</span>)</span><br><span class="line">                dist[t + <span class="number">1</span>] = dist[t] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * t &lt; b <span class="keyword">and</span> dist[<span class="number">2</span> * t] == -<span class="number">1</span>):</span><br><span class="line">                q.append(<span class="number">2</span> * t)</span><br><span class="line">                dist[<span class="number">2</span> * t] = dist[t] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(bfs())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/01/23/hello-world/"/>
      <url>/2023/01/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to my blog!</p><p>身为一名CS的学生， 一直期望搭建自己的小站。这个blog完全是照着<a href="https://www.fomal.cc/posts/eec9786.html">Fomalhaut🥝</a>大佬的教程实现的，虽然主要的工作就是拷贝，但完成后还是很开心滴🐹。</p><p>希望通过这个小站， 我能够记录自己学习与生活的点点滴滴。在接下来不多的大学时光和更长远的科研道路上，不负初心，在自己的道路上勇敢前行🤓！</p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
