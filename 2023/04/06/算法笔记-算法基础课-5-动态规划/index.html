<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>算法基础课5 动态规划 | 梦凡のBlog</title><meta name="author" content="沧月倾"><meta name="copyright" content="沧月倾"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="未完成">
<meta property="og:type" content="article">
<meta property="og:title" content="算法基础课5 动态规划">
<meta property="og:url" content="https://www.dreamgo.fun/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="梦凡のBlog">
<meta property="og:description" content="未完成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picbed.dreamgo.fun/img/cover/27.webp">
<meta property="article:published_time" content="2023-04-05T16:10:09.000Z">
<meta property="article:modified_time" content="2023-04-05T16:17:01.790Z">
<meta property="article:author" content="沧月倾">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picbed.dreamgo.fun/img/cover/27.webp"><link rel="shortcut icon" href="https://picbed.dreamgo.fun/img/favicon/chicken1.webp"><link rel="canonical" href="https://www.dreamgo.fun/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"WK463HPQ78","apiKey":"9512f543c4086bf61fa2d55f1a92e975","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"本文最后更新于","messageNext":"天前，其中的信息可能已经过时"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: 沧月倾","link":"链接: ","source":"来源: 梦凡のBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法基础课5 动态规划',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-06 00:17:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/pinwheel.css"><link rel="stylesheet" href="/css/plane.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="/css/readPercent.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><div id="myscoll"></div><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picbed.dreamgo.fun/img/avatar/a1.webp" onerror="onerror=null;src='https://picbed.dreamgo.fun/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-HomeLoan"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dushu1-copy-copy"></use></svg><span> 学习</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/algorithm/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biji2"></use></svg><span> 算法</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yanjiu"></use></svg><span> 科研</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/papernote/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biji1"></use></svg><span> 笔记</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/frontier/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rengongzhineng"></use></svg><span> 前沿追踪</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xindong"></use></svg><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/poem/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shuqian-copy"></use></svg><span> 诗摘</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinlexiangban"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tupian"></use></svg><span> 照片</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shexiangji"></use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/record/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--pencilcase"></use></svg><span> 记录</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rili"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei3"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg><span> 留言</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie1-copy"></use></svg><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picbed.dreamgo.fun/img/cover/27.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="梦凡のBlog"><span class="site-name">梦凡のBlog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-HomeLoan"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dushu1-copy-copy"></use></svg><span> 学习</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/algorithm/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biji2"></use></svg><span> 算法</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yanjiu"></use></svg><span> 科研</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/papernote/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biji1"></use></svg><span> 笔记</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/frontier/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rengongzhineng"></use></svg><span> 前沿追踪</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xindong"></use></svg><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/poem/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shuqian-copy"></use></svg><span> 诗摘</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinlexiangban"></use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/Gallery/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-tupian"></use></svg><span> 照片</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shexiangji"></use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/record/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--pencilcase"></use></svg><span> 记录</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rili"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei3"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyan"></use></svg><span> 留言</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/">         <svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie1-copy"></use></svg><span> 友链</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="search-button"><a class="site-page social-icon search"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:0px" aria-hidden="true"><use xlink:href="#icon-sousuo3"></use></svg></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法基础课5 动态规划</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-05T16:10:09.000Z" title="发表于 2023-04-06 00:10:09">2023-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-05T16:17:01.790Z" title="更新于 2023-04-06 00:17:01">2023-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>67分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法基础课5 动态规划"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="动态规划">动态规划</h1>
<p>动态规划先化零为整，再化整为零。</p>
<p>化零为整即将不同的方案归到一类去，用一个状态来表示</p>
<p>化整为零即将每一个状态分割成若干个字迹再分别来求</p>
<p>DP能解的前提是为拓扑图不存在环</p>
<p>DP是特殊的最短路问题，是没有环的最短路entire</p>
<h2 id="背包问题模型">背包问题模型</h2>
<p>每件物品i重量为$w_1$,价值为$v_i$，背包至多能装W重量的物体，问如何选择物品获得的价值最大。</p>
<p>背包问题解决的问题大致都是：从某些物品里，在某种限制下，选择一部分物品，使目标值最大。</p>
<p>背包问题是选择问题或组合问题的一种</p>
<p><strong>DP问题的优化都是对状态转移方程/代码的等价变形</strong></p>
<h3 id="1-AcWing-2-01背包问题">1. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/2/">AcWing 2. 01背包问题 </a></h3>
<p>每件物品最多只用一次</p>
<p><img src="https://mdpic.dreamgo.fun/img/71015FA210F785ABDAB0E6E8C6543B60-1679975268081-5.png" alt="71015FA210F785ABDAB0E6E8C6543B60"></p>
<h4 id="C">C++</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 2. 01背包问题  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// 状态表示，属性为MAX</span></span><br><span class="line"><span class="comment">// 隐含了初始化，没有物品的时候，背包的价值永远是0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件：f[0][0~n] = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            <span class="comment">// 不选择当前物品，则价值等于前i-1个物品在同容量下的MAX</span></span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">// 如果j没有v[i]大，则说明装不下第i件物品，那么含i的集合就是空集</span></span><br><span class="line">            <span class="comment">// 选择当前物品，前提是j &gt;= v[i]，则价值等于前i-1个物品在同j-v[i]容量下的MAX加上第i个物品价值</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f</span><br><span class="line">            [i<span class="number">-1</span>][j-v[i]] + w[i]);<span class="comment">// 递推式</span></span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python">python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 2. 01背包问题  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N = <span class="number">1010</span></span><br><span class="line">    v = [<span class="number">0</span>] * N</span><br><span class="line">    w = [<span class="number">0</span>] * N</span><br><span class="line">    f = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="comment"># 状态表示，属性为MAX</span></span><br><span class="line">    <span class="comment"># 隐含了初始化，没有物品的时候，背包的价值永远是0</span></span><br><span class="line">    </span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        v[i], w[i] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 不选择当前物品，则价值等于前i-1个物品在同容量下的MAX</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="comment"># 如果j没有v[i]大，则说明装不下第i件物品，那么含i的集合就是空集</span></span><br><span class="line">            <span class="comment"># 选择当前物品，前提是j &gt;= v[i]，则价值等于前i-1个物品在同j-v[i]容量下的MAX加上第i个物品价值</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[i]:</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i])</span><br><span class="line">    <span class="built_in">print</span>(f[n][m])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>优化——滚动数组：使用的两个前提条件：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>状态<code>f(i, j)</code>只与<code>f(i-1, ...)</code>有关，只与<code>x</code>坐标上一层有关</p>
</li>
<li class="lvl-2">
<p>$f(i - 1, j)与f(i - 1, j - v_1)$ y坐标都小于等于<code>j,</code>都在<code>f(i, j)</code>的同一侧</p>
</li>
</ul>
<p><strong>DP问题的优化都是对状态转移方程/代码的等价变形</strong><br>
可以发现<code>f[i][j] = max(f[i][j],f[i - 1][j - volumn[i]] + weight[i])</code>只用到了<code>i-1</code>层的信息，因此可以用滚动数组来进行优化</p>
<p>滚动数组简介滚动数组是DP中的一种编程思想。简单的理解就是让数组滚动起来，每次都使用固定的几个存储空间，来达到压缩，节省存储空间的作用。起到优化空间，主要应用在递推或动态规划中（如01背包问题）。因为DP题目是一个自底向上的扩展过程，我们常常需要用到的是连续的解，前面的解往往可以舍去。所以用滚动数组优化是很有效的。利用滚动数组的话在N很大的情况下可以达到压缩存储的作用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01背包问题——DP + 滚动数组优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">// 滚动数组降维</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件：f[0~n] = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="comment">// 注意j必须从大到小，从而保证用到的是第i-1层的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;=v[i] ; -- j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-AcWing-3-完全背包问题">2. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3/">AcWing 3. 完全背包问题  </a></h3>
<p>每件物品有无限个</p>
<p>朴素的DP就是暴力+递归存储。先不用考虑优化问题，对于每一个不确定的选择维度，就都开一重循环进行枚举即可。</p>
<p>状态表示的维度和循环的重数不一定相同。对于复杂问题，往往需要<strong>在集合划分时也使用一重循环</strong>。此时先不要考虑优化问题，先上暴力枚举即可。而优化时只需<strong>对状态转移方程等价变形，用前面的状态替换方程的某些部分</strong>。</p>
<p>集合划分时需要枚举每个物品选几个。</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230325122140072.png" alt="image-20230325122140072"></p>
<h4 id="朴素算法">朴素算法</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 3. 完全背包问题   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: f[0][0~n] = 0  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m ; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; ++ k)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="python-2">python</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 3. 完全背包问题   </span></span><br></pre></td></tr></table></figure>
<h4 id="对状态方程进行变形化简">对状态方程进行变形化简</h4>
<p>这种变形化简实际上反映了利用两次递推关系。在集合划分时，由于我们思维能力的局限性，我们只沿着第一维i来寻找递推关系并推导，但对于有些复杂问题，我们要沿着第一维i和第二维j都寻找递推关系才能充分化简递推式。</p>
<p>这就需要我们在由第一维i推导出的递推式基础上，继续寻找沿着第二维j上的递推关系并对现有递推式进行化简。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 3. 完全背包问题   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: f[0][0~n] = 0  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m ; ++ j)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="python-3">python</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 3. 完全背包问题   </span></span><br></pre></td></tr></table></figure>
<h4 id="使用滚动数组优化">使用滚动数组优化</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: f[0][0~n] = 0  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m ; ++ j) <span class="comment">// 注意j必须从小到大，从而保证用到的是第i层的信息</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="python-4">python</h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 3. 完全背包问题   </span></span><br></pre></td></tr></table></figure>
<h2 id="3-AcWing-4-多重背包问题">3. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4/">AcWing 4. 多重背包问题</a></h2>
<p>多重背包问题每件物品i有$s_i$个</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230325121902131.png" alt="image-20230325121902131"></p>
<p>注意区分多重背包和完全背包的不同：此处注意，直接借用完全背包的模板是不行的，因为物品数目是有限个，而非完全背包的无限个，在背包空间足够大时，递推会出现错误，因为会多出一项 $dp[i−1][j−(s_i+1)v_i]+s_iw_i$，这一项不能直接利用递推的性质得到 $dp[i−1][j−(s_i+1)v_i]+(s_i+1)w_i$，因为物品$i$最多也才$s_i$件，不可能取到$s_i+1$件，所以不能直接借用完全背包的模板来优化；</p>
<h3 id="朴素算法-2">朴素算法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多重背包问题朴素算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件：f[0][0~n] = 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; ++ k)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-AcWing-5-多重背包问题-II">4. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/5/">AcWing 5. 多重背包问题 II</a></h2>
<p>使用二进制优化方法</p>
<p>枚举优化：<strong>二进制打包枚举</strong></p>
<p>利用二进制优化方法，可以将多重背包问题转化为01背包问题</p>
<p>使用$1,2,4,\cdots,2<sup>k$这几个数的组合可以表示出$0$到$2</sup>{k+1} - 1$中的每一个数，注意每个数$2^i$最多只会被选1次。</p>
<p>对于任意一个数S，选取最大的k(满足$1+2+4+…+2^k = 2^{k+1} - 1 &lt; S, 1+2+4+…+2^{k+1} = 2^{k+2} - 1&gt;S$)，<br>
$c = s - (2^{k+1} - 1)$，则:$$0-S中的所有数都可以用1,2,4,…,2^k,c的组合表示出来。$$<br>
注意因为c&lt;2^{k+1}, c和2^{k+1} - 1间无漏缺。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制优化法处理多重背包问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 二进制优化，转换为01背包问题</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * k, w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * s, w[cnt] = b * s;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件：f[0~cnt] = 0</span></span><br><span class="line">    <span class="comment">// 01背包问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; -- j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-AcWing-9-分组背包问题">5. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/9/">AcWing 9. 分组背包问题 </a></h2>
<p>分组背包问题物品分为多个组，每组有多种类别物品</p>
<p>关键在于理解之前的背包问题以每件物品作为i，而分组问题以每组作为i，每组里再讨论选那个物品哪个物品</p>
<p>同样注意，对于复杂问题，往往需要<strong>在集合划分时也使用一重循环</strong>。</p>
<p>分组背包中集合划分时需要枚举每组中选哪一个物品（包含一个也不选）。</p>
<p>类似完全背包问题的朴素算法</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230325121719809.png" alt="image-20230325121719809"></p>
<h3 id="朴素算法-3">朴素算法</h3>
<p>类似完全背包问题的朴素算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分组背包问题朴素算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; ++ j)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j]; <span class="comment">// 先要等于不选本组的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; ++ k)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt;= j) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-v[i][k]] + w[i][k]);</span><br><span class="line">                <span class="comment">// 注意这里f[i][j]不能用f[i-1][j]替换，因为考虑到每组里要进行比较</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="滚动数组优化">滚动数组优化</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N],s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; ++ j)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt;= j) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-v[i][k]] + w[i][k]);</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线性DP">线性DP</h2>
<p>递推式具有明显的线性关系。线性DP一般从前往后推，状态表示和集合划分都会将前<code>i</code>个数视为整体</p>
<h3 id="1-AcWing-898-数字三角形">1. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/900/">AcWing 898. 数字三角形 </a></h3>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230325171911856.png" alt="image-20230325171911856"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 898. 数字三角形</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 当递推式含有i-1,j-1时存储从1开始，方便应对边界0的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + <span class="number">1</span>; ++ j)</span><br><span class="line">            f[i][j] = -INF; <span class="comment">// 注意为了应对越界问题，要先赋值为极小值</span></span><br><span class="line">            <span class="comment">// 注意j从0到i+1，而不是1到j——边界的越界问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意边界条件</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="优化1——滚动数组">优化1——滚动数组</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 898. 数字三角形</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 当递推式含有i-1,j-1时存储从1开始，方便应对边界0的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">            f[i] = -INF; <span class="comment">// 注意为了应对越界问题，要先赋值为极小值</span></span><br><span class="line">            <span class="comment">// 注意j从0到i+1，而不是1到j——边界的越界问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    f[<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">1</span>; -- j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j<span class="number">-1</span>],f[j]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="优化2——直接在存储数据的数组存储结果">优化2——直接在存储数据的数组存储结果</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 898. 数字三角形</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 当递推式含有i-1,j-1时存储从1开始，方便应对边界0的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        a[i][<span class="number">0</span>] = -INF;</span><br><span class="line">        a[i][i+<span class="number">1</span>] = -INF;</span><br><span class="line">    &#125;         <span class="comment">// 注意为了应对越界问题，要先赋值为极小值</span></span><br><span class="line">            <span class="comment">// 注意j从0到i+1，而不是1到j——边界的越界问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">1</span>; -- j)</span><br><span class="line">            a[i][j] = <span class="built_in">max</span>(a[i<span class="number">-1</span>][j<span class="number">-1</span>],a[i<span class="number">-1</span>][j]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res = <span class="built_in">max</span>(res, a[n][i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-AcWing-895-最长上升子序列">2. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/897/">AcWing 895. 最长上升子序列</a></h3>
<p>状态为1维。</p>
<p>这里一个难点是集合的定义。集合的定义要满足递推包含性，方便进行递推。集合递推所用到的额外信息往往借助状态的维度进行查找，这也影响集合的定义。核心在于想清楚序列是怎么递推地一步步构成的，需要判断哪些条件。</p>
<p>集合定义时一定要满足递推包含性。首先，序列的构成显然具有递推性，即一个个数字往结尾加。而本题要判断字符能否加在一个序列最后构成上升子序列，关键要判断当前数字是否大于序列结尾字符。为此，为了进行递推，集合在定义时就必须能方便的表示出序列结尾的数字信息，即结尾数字的位置最好和维度相绑定。因此集合表示所有以第<code>i</code>个数结尾的上升子序列，而不是前<code>i</code>个数构成所有上升子序列的集合。</p>
<p>本题的集合划分也需注意。DP的核心思路是暴力+递推存储，对于复杂问题，往往需要<strong>在集合划分时也使用循环</strong>。本题中既然序列的递推关系由最后一个数表示和决定，划分时我们同样也可以讨论序列最后一个数的位置，这即对应于状态f。最特殊的情况是序列长度为0，其次可以遍历<code>i</code>前面的状态，取MAX。</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230325172802737.png" alt="image-20230325172802737"></p>
<h4 id="朴素算法-4">朴素算法</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长上升子序列朴素算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 边界条件 f[i] &gt;=  1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        f[i] = <span class="number">1</span>; <span class="comment">// 边界条件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; ++ j)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>) ;</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出状态">输出状态</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], f[N], g[N];</span><br><span class="line"><span class="comment">// g[N]用于记录状态转移的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        g[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])</span><br><span class="line">                <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>)&#123;</span><br><span class="line">                    f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">                    g[i] = j; <span class="comment">// 记录状态转移</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (f[k] &lt; f[i])</span><br><span class="line">            k = i;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[k]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s[N], len = f[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)&#123;</span><br><span class="line">        s[i] = a[k];</span><br><span class="line">        k = g[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">        cout &lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-AcWing-896-最长上升子序列-II">3. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/898/">AcWing 896. 最长上升子序列 II</a></h3>
<p>贪心加构造单调二分$O(nlogn)$</p>
<p>使用DP进行求解时会有冗余——会有多个长度相同的上升子串，针对问题所需求解的最长长度来说，不用考虑子串的内容是无所谓的，因此冗余。同时，对于这些长度相同的上升子串，应用贪心的思想，会有一个最优的子串——终端值最小的子串是最优子串，能插在其他等长串的数也一定能插在其后面。因此只用存每个长度的子串集合中的最优子串即可。</p>
<p>为此，对前面所有子串进行分类，使用一个数组维护前面每个长度下所有子串的最小的终端值。数组 <code>q[i]</code>表示长度为<code>i</code>的最长上升子序列的末尾元素的最小值。这里一定要把维护数组的含义理解好。</p>
<p>在这一前提下，我们发现一个重要性质——该维护数组一定是严格单调递增的。</p>
<p>可以使用反证法证明。证明数组<code>q</code>具有单调性，即证明<code>i &lt; j</code>时，<code>q[i] &lt; q[j]</code>。假设存在<code>k&lt;j</code>时，<code>q[k] &gt; q[j]</code>，但在长度为<code>j</code>，末尾元素为<code>q[j]</code>的子序列A中，将后<code>j-i</code>个元素减掉，可以得到一个长度为<code>i</code>的子序列B，其末尾元素$t$必然小于<code>q[j]</code>（因为在子序列A中，<code>t</code>的位置上在<code>q[j]</code>的后面），而我们假设数组d必须符合<code>表示长度为 i 的最长上升子序列的末尾元素的最小值</code>，此时长度为<code>i</code>的子序列的末尾元素<code>t &lt; q[j] &lt; q[k]</code>，即<code>t &lt; d[k]</code>，所以<code>q[k]</code>不是最小的，与题设相矛盾，因此可以证明其单调性。</p>
<p>由此，我们只需要遍历所有字母，对于每个字母在维护数组中查找小于当前数的最大数，位置为<code>r</code>，表示该字母可以插入的最长上升子串长度为<code>r</code>，并用其替换后一个位置的数，表示插入后子串长度为<code>r+1</code>且恰为相同长度中终端值最小的子串。同时更新维护数组长度也是最长子串长度<code>len</code>。</p>
<p>找到一个最大的小于当前数的数可以用 <strong>二分</strong> 来优化，使用<code>l=mid</code>模板</p>
<ul class="lvl-0">
<li class="lvl-4">
<p>二分的思路：</p>
<ul class="lvl-2">
<li class="lvl-8">先定义边界，<code>l = 0, r = len</code>, 其中<code>len</code>是<code>q</code>数组的长度</li>
<li class="lvl-8">然后确定<code>check</code>函数, 可以先找到不等式中<code>c &lt; x ≤ a ≤ b</code>的<code>c</code>
<ul class="lvl-4">
<li class="lvl-12">通过<code>q[r + 1] = a[i]</code>来将<code>x</code>覆盖<code>a</code>的值</li>
<li class="lvl-12">同时也要考虑<code>算法1</code>的情况<code>1</code>, 需要扩大<code>q</code>数组的长度
<ul class="lvl-6">
<li class="lvl-16">即<code>r + 1 &gt; len</code>时, 表示<strong>超出</strong>了二分边界，这时就要<code>len ++</code>更新<code>q</code>的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="C-2">C++</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 896. 最长上升子序列 II</span></span><br><span class="line"><span class="comment">// 贪心 + 二分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N]; <span class="comment">// q[i]存储当前长度为i的上升字串中的结尾的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>; <span class="comment">// 记录维护数组q的长度，也是当前最长上升子串长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 贪心迭代顺序——按原序遍历串中每个数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        <span class="comment">// 二分查找每个候选对象的最优插入位置——插到可以插入的最长子串</span></span><br><span class="line">        <span class="comment">// 注意这里l始终初始为0，这样解决了a[i]小于任何长度大于1的子串结尾导致找不到插入位置的问题</span></span><br><span class="line">        <span class="comment">// q[0]此时相当于哨兵，a[i]一定大于0，对应于至少可以自己构成一个长度为1的子串</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="comment">// 找小于当前数的最大的数</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>); <span class="comment">// 更新最大长度</span></span><br><span class="line">        q[r + <span class="number">1</span>] = a[i]; <span class="comment">// 更新维护数组</span></span><br><span class="line">        <span class="comment">// 注意这里非常巧妙的处理了初始的情况</span></span><br><span class="line">        <span class="comment">// 初始时l = r = 0， 直接将a[0]放入长度为1的子串的结尾维护位置中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 896. 最长上升子序列 II</span></span><br><span class="line"><span class="comment"># 贪心 + 二分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    q = [<span class="number">0</span>] * (n + <span class="number">1</span>) </span><br><span class="line">    <span class="comment"># 注意这里q[i]存储当前长度为i的上升字串中的结尾的最小值</span></span><br><span class="line">    <span class="comment"># 因此从1开始存储，只要开n+1个位置</span></span><br><span class="line">    </span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        l, r = <span class="number">0</span>, length</span><br><span class="line">        <span class="comment"># 注意这里l始终初始为0，这样解决了a[i]小于任何长度大于1的子串结尾导致找不到插入位置的问题</span></span><br><span class="line">        <span class="comment"># q[0]此时相当于哨兵，a[i]一定大于0，对应于至少可以自己构成一个长度为1的子串</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> q[mid] &lt; x: l = mid</span><br><span class="line">            <span class="keyword">else</span>: r = mid - <span class="number">1</span></span><br><span class="line">        length = <span class="built_in">max</span>(length, r + <span class="number">1</span>)</span><br><span class="line">        q[r + <span class="number">1</span>] = x </span><br><span class="line">        <span class="comment"># 注意这里非常巧妙的处理了初始的情况</span></span><br><span class="line">        <span class="comment"># 初始时l = r = 0， 直接将a[0]放入长度为1的子串的结尾维护位置中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(length)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="4-AcWing-897-最长公共子序列">4. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/899/">AcWing 897. 最长公共子序列</a></h3>
<p>本题由于有两个字符串，所以使用二维状态分别表示两个字符串中位置。</p>
<p>集合定义同样思考公共子序列是如何递推地一步步构成的。只需判断第一个字符串<code>i</code>位置字符和第二个字符串<code>j</code>位置字符是否相同，如果相同就可以加上该字符（所有在<code>i</code>和<code>j</code>前的序列都可以加上)。这只对应一个情况，而集合要对应于多种情况，同时可以发现定义时不需要额外限制条件。所以集合定义为所有在第一个序列前<code>i</code>个字母中出现，且在第二个序列前<code>j</code>个字母中出现的子序列。</p>
<p>注意本题集合划分比较困难。集合划分时讨论<code>a[i]</code>和<code>b[j]</code>是否包含在子序列中，而易错点时<code>a[i]</code>和<code>b[j]</code>两者相等只对应集合一种情况，只讨论两者大小关系是不够的。<code>a[i]</code>或<code>b[j]</code>还可以与前面任意字符相等，从而被包含，为此需要划分成一下四类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>所有在第一个序列前<code>i-1</code>个字母中出现，且在第二个序列前<code>j-1</code>个字母中出现的子序列(<code>f[i-1, j-1]</code>)</p>
</li>
<li class="lvl-2">
<p>所有以第一个序列第<code>i</code>个字母中和第二个序列第<code>j</code>个字母结尾的子序列(<code>a[i] == b[j]</code>时才有，<code>f[i-1, j-1]+1</code>)</p>
</li>
<li class="lvl-2">
<p>所有以第一个序列第<code>i</code>个字母结尾，且在第二个序列前<code>j-1</code>个字母中出现的子序列</p>
</li>
<li class="lvl-2">
<p>所有以第二个序列第<code>j</code>个字母结尾， 且在第一个序列前<code>i-1</code>个字母中出现的子序列</p>
</li>
</ul>
<p>显然这需要涉及讨论前面的字母，和状态时不直接对应的。但本题是MAX类，使用包含所需情况集合的状态也是可以来替换表示的。<code>f[i-1, j]</code>表示所有在第一个序列前<code>i-1</code>个字母中出现，且在第二个序列前<code>j</code>个字母中出现的子序列，一定包含了所有以第二个序列第<code>j</code>个字母结尾， 且在第一个序列前<code>i-1</code>个字母中出现的子序列的所有情况，但也包含了不以第二个序列第<code>j</code>个字母结尾的情况。但由于本题是最值问题，不影响问题求解，可替换表示。同理，可以用<code>f[i, j-1]</code>覆盖表示所有以第一个序列第<code>i</code>个字母结尾，且在第二个序列前<code>j-1</code>个字母中出现的子序列的所有情况。</p>
<p>同时可以发现，<code>f[i-1, j]</code>和<code>f[i, j-1]</code>都覆盖表示了<code>f[i-1, j-1]</code>的情况，因此这种情况不用单列了。</p>
<p>这里还需要注意，之所以可以用<code>f[i-1, j]</code>和<code>f[i, j-1]</code>进行替换表示，一个很重要的<strong>前提是<code>f[i-1, j]</code>和<code>f[i, j-1]</code>仍都是<code>f[i, j]</code>的子集</strong>，没有超出其表示范围，从而不影响其最值结果。</p>
<p><strong>若状态$s_{i-1} \subset k \subset  f_i$，则当状态$s_{i-1}$不方便表示时，可以用$ k $替换表示</strong>。</p>
<p>集合划分时可以重复包含，只要不影响结果就行。而当要求的结果是最值时划分出集合有重复往往时无影响。</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230325183652600.png" alt="image-20230325183652600"></p>
<h4 id="C-3">C++</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长公共子序列朴素算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %s %s&quot;</span>, &amp;n, &amp;m, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 易错点：这里数组从第二个位置开始存储</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Python-2">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    a = <span class="string">&quot; &quot;</span> + <span class="built_in">input</span>()</span><br><span class="line">    b = <span class="string">&quot; &quot;</span> + <span class="built_in">input</span>()</span><br><span class="line">    f = [[<span class="number">0</span>] * (m + <span class="number">1</span>)  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)] <span class="comment"># 注意存储从下标1开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i-<span class="number">1</span>][j], f[i][j-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> a[i] == b[j]:</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(f[n][m])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="4-AcWing-902-最短编辑距离">4. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/904/">AcWing 902. 最短编辑距离</a></h3>
<p>要求是将字符串a变成字符串b，实现的过程显然具有递推性。两个字符串，状态为二维。实现要随维度一步步实现，集合可以定义成所有将<code>a[1~i]</code>变成<code>b[1~j]</code>的操作方式</p>
<p>集合划分：讨论最后一步的操作，根据三种操作划分</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230325212306766.png" alt="最短编辑距离"></p>
<p>集合划分的方案虽然容易，但是每种方案如何取很容易错。增操作和删操作都意味着<code>a[i]</code>和<code>b[j]</code>不是对应的，这和两者相不相等没有关系，可能已经和前面的字母已经匹配了。因此这些方案必须要进行对应操作。</p>
<p>但是插操作则不一样，插操作是将当前位置的数替换后<code>a</code>变成<code>b</code>，这意味着要将<code>a[i]</code>和<code>b[j]</code>匹配，因此当<code>a[i]</code>和<code>b[j]</code>已经相等了，就可直接对应，没必要进行此操作，因此需要先判断。这里注意<code>a[i]</code>和<code>b[j]</code>对应的方案也是必须取方案，只不过当两者已经相等时只用取<code>f[i-1][j-1]</code>，而当两者不等时需要取<code>f[i-1][j-1]+1</code>，区别在加1上。</p>
<h4 id="C-4">C++</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 902. 最短编辑距离</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s%d%s&quot;</span>, &amp;n, a + <span class="number">1</span>, &amp;m, b + <span class="number">1</span>); </span><br><span class="line">    <span class="comment">// 注意DP一般从下标1存储，这与状态转移方程越界问题有关</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意初始化——从空串变成长度为i的串至少需要i次操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j] + <span class="number">1</span>, f[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 对于a[i]与b[j]对应的方案，即插操作方案，要讨论是否需要加1</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python-3">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AcWing 902. 最短编辑距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    a = <span class="string">&quot; &quot;</span> + <span class="built_in">input</span>()</span><br><span class="line">    m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    b = <span class="string">&quot; &quot;</span> + <span class="built_in">input</span>()</span><br><span class="line">    f = [[<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        f[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):</span><br><span class="line">        f[<span class="number">0</span>][i] = i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i-<span class="number">1</span>][j], f[i][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> a[i] == b[j]:</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(f[n][m])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="5-AcWing-899-编辑距离">5. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/901/">AcWing 899. 编辑距离</a></h3>
<p>本题相当于求解多个最短编辑距离问题</p>
<h4 id="C-5">C++</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>, M = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">char</span> str[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">edit_distance</span><span class="params">(<span class="type">char</span> a[], <span class="type">char</span> b[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> la = <span class="built_in">strlen</span>(a + <span class="number">1</span>), lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lb; i ++ ) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= la; i ++ ) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= la; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lb; j ++ )&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[la][lb];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">char</span> s[N];</span><br><span class="line">        <span class="type">int</span> limit;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, s + <span class="number">1</span>, &amp;limit);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">edit_distance</span>(str[i], s) &lt;= limit)</span><br><span class="line">                res ++ ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python-4">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    s = [<span class="string">&quot; &quot;</span> + <span class="built_in">input</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    f = [[<span class="number">0</span>] * <span class="number">1001</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1001</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        b, l = <span class="built_in">input</span>().split()</span><br><span class="line">        b = <span class="string">&quot; &quot;</span> + b</span><br><span class="line">        l = <span class="built_in">int</span>(l)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> s:</span><br><span class="line">            la = <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">            lb = <span class="built_in">len</span>(b) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(la + <span class="number">1</span>): f[i][<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lb + <span class="number">1</span>): f[<span class="number">0</span>][i] = i</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, la + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lb + <span class="number">1</span>):</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i-<span class="number">1</span>][j], f[i][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> a[i] == b[j]:</span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">else</span>: </span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> f[la][lb] &lt;= l:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(res)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="区间DP">区间DP</h2>
<p>递推式不具有线性关系。</p>
<p><strong>区间dp的状态表示一般采用二维来表示一个区间</strong>。集合是从第<code>i</code>个元素到第<code>j</code>元素而不再都从第1个元素开始。</p>
<p>递推关系是从两个更小的区间合并成一个更大的区间。</p>
<p>区间dp要注意枚举顺序，需枚举区间长度，从长度为1的区间开始枚举。<strong>一般先枚举区间长度，再枚举区间左端点</strong>。</p>
<h3 id="AcWing-282-石子合并"><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/284/">AcWing 282. 石子合并</a></h3>
<p>状态表示时要考虑到由于操作是将任意左右两堆合并，左右端点不确定且具有对称性，因此将左右端点作为两维，因此状态对应于一个区间。集合定义即所有将第<code>i</code>堆石子到第<code>j</code>堆石子合并成一堆的合并方式。</p>
<p>集合划分思考最后一步和倒数第二步的递推关系，显然无论区间有多长，要合成一堆，倒数第二步是合成左右两堆。由于合并顺序不定，因此左右两堆的分界点就会不同，对应的合成两堆的代价也不同。因此需要暴力枚举左右两堆的分界点。</p>
<p>合并两堆的代价是两堆的总重量，即区间和，因此需要使用前缀和。<br>
$$<br>
f[i, j] = min(f[i, k] + f[k + 1, j] + s[j] - s[i - 1]), k =i,\ldots, j - 1<br>
$$<br>
<code>k</code>从<code>i</code>到<code>j-1</code>是因为左右都至少要有一堆</p>
<p>枚举顺序是先枚举区间长度，再枚举区间左端点。</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230325202545559.png" alt="image-20230325202545559"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 石子合并</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N];<span class="comment">// 前缀和</span></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) s[i] += s[i<span class="number">-1</span>];<span class="comment">// 求前缀和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本题递推中只涉及区间数据的和</span></span><br><span class="line">    <span class="comment">// 求任意区间的数据的和可以采用前缀和的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以区间长度从小到大来枚举所有状态</span></span><br><span class="line">    <span class="comment">// 边界条件：区间长度为1，值为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; ++ i)&#123; <span class="comment">// i为区间起点</span></span><br><span class="line">            <span class="type">int</span> l = i, r = i + len - <span class="number">1</span>; <span class="comment">// 区间左右端点</span></span><br><span class="line">            f[l][r] = <span class="number">1e9</span>; <span class="comment">// 注意求的是最小值，一定要先把状态值初始化为比较大的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt; r; ++ k) <span class="comment">// 注意k&lt;r，补去等。 k为子区间的分界点</span></span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;        </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python-5">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    s = [<span class="number">0</span>] + <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">    f = [[<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        f[i][i] = <span class="number">0</span></span><br><span class="line">        s[i] += s[i - <span class="number">1</span>] <span class="comment"># 前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注意这里的遍历范围是极容易错的</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span> - <span class="built_in">len</span> + <span class="number">1</span>):</span><br><span class="line">            l, r = i, i + <span class="built_in">len</span> - <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(l, r):</span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k+<span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(f[<span class="number">1</span>][n])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="组合BP">组合BP</h2>
<p>有限制的组合（选择）问题就是背包问题，可以使用动态规划，只考虑组合而不考虑排序</p>
<h2 id="计数类DP">计数类DP</h2>
<p>计数类DP即状态表示的集合的要求的属性为数量。而这种数量往往指组合的数量，可用DP解决</p>
<h3 id="1-AcWing-900-整数划分">1. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/902/">AcWing 900. 整数划分</a></h3>
<p>组合问题首先就要看能不能用DP</p>
<h4 id="思路一：转化为完全背包问题">思路一：转化为完全背包问题</h4>
<p>题目中将正整数 n 表示成若干个正整数$n_i$之和，且划分是无关顺序的（一定按照从大到小排列），这种无关顺序的划分问题可以被视为一个组合问题。原题等价于从1~n中所有数中进行选择，使其和等于n，每个数可以选择无数次。因而这可以转化为完全背包问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数划分 思路一：转化为完全背包问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: 空集作为一种方案</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j] % mod;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= i) f[i][j] = (f[i][j] + f[i][j-i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数划分 思路一：转化为完全背包问题 + 滚动数组优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: 空集作为一种方案</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line">            f[j] = (f[j] + f[j-i]) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python-6">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f[i][j] = f[i-1][j] + f[i-1][j-1*i] + f[i-1][j-2*i] + ... + f[i-1][j-k*i]</span></span><br><span class="line"><span class="comment"># f[i][j-i] = f[i-1][j-i] + f[i][j-2*i] + ... + f[i-1][j-k*i]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    f = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    mod = <span class="built_in">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># f[0][0]表示的是从0个数中选体积为0的方案，也就是1个方案</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            f[i][j] = f[i-<span class="number">1</span>][j] % mod</span><br><span class="line">            <span class="keyword">if</span> j &gt;= i:</span><br><span class="line">                f[i][j] = (f[i][j] + f[i][j-i]) % mod</span><br><span class="line">    <span class="built_in">print</span>(f[n][n])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    mod = <span class="built_in">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># f[0][0]表示的是从0个数中选体积为0的方案，也就是1个方案</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n + <span class="number">1</span>):</span><br><span class="line">            f[j] = (f[j] + f[j-i]) % mod</span><br><span class="line">    <span class="built_in">print</span>(f[n])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h4 id="思路二">思路二</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>集合：所有总和是<code>i</code>，并且恰好表示成<code>j</code>个数的和的方案</p>
</li>
<li class="lvl-2">
<p>集合划分：划分为最小值为1和最小值大于1两类</p>
</li>
</ul>
<p>对于第一类，为<code>f[i-1][j-1]</code>；对于第二类，为<code>f[i-j][j]</code>；这两类的推到其实分别沿着第二维j和第一维<code>i</code></p>
<p><strong>一定掌握这种集合划分的思路，应用到了映射的思想</strong>。既然讨论的是选取方案，我们就可以把是否选取最小的一个元素作为不同点进行讨论，这里关键是能够进行映射才行。</p>
<p>只要能进行划分并能用状态表示出来即可</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230325225807811.png" alt="image-20230325225807811"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件: 空集作为一种方案</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            f[i][j] = (f[i<span class="number">-1</span>][j<span class="number">-1</span>] + f[i-j][j]) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res = (res + f[n][i]) % mod;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python-7">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    f = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    mod = <span class="built_in">int</span>(<span class="number">1e9</span> + <span class="number">7</span>)</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> <span class="comment"># f[0][0]表示的是总和为0，由0个数构成，方案数为1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>): <span class="comment"># 注意选择的数最小为1，所以j至多为i</span></span><br><span class="line">            <span class="comment"># 按照组成是否含有1来划分</span></span><br><span class="line">            f[i][j] = (f[i-<span class="number">1</span>][j-<span class="number">1</span>] + f[i-j][j]) % mod</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(f[n]) % mod) <span class="comment"># 注意最后别忘取余</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="2-AcWing-1050-鸣人的影分身">2. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1052/">AcWing 1050. 鸣人的影分身</a></h3>
<p>本题是<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/902/">AcWing 900. 整数划分</a>的变形题。前面和整数划分完全一致，但多了一个限制条件——元素的个数，至多只能划分为N个数。</p>
<p>因为这个限制条件，整数划分的第一个思路——转化为完全背包问题就不可行了（完全背包对元素个数没有直接限制，每个元素可以取无数次）。但思路二仍是可行的，因为其将划分的元素数作为状态的一维</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 1050. 鸣人的影分身</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数位DP">数位DP</h2>
<p>可参考以下博客的讲解：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/virus2017/shuweidp">数字组成的奥妙——数位dp</a></p>
</li>
</ul>
<p><strong>数位DP重点在于分类讨论</strong>（即集合划分）。</p>
<p>首先我们要清楚数位dp解决的是什么问题：</p>
<p>求出在给定区间[A,B]内，符合条件f(i)的数i的个数。条件f(i)一般与数的大小无关，而与数的组成有关</p>
<p>由于数是按位dp，数的大小对复杂度的影响很小</p>
<p>对于[l,r]区间问题，我们一般把他转化为两次数位dp,即找[0,r]和[0,l-1]两段，再将结果相减就得到了我们需要的[l,r]</p>
<h3 id="1-AcWing-338-计数问题">1. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/340/">AcWing 338. 计数问题</a></h3>
<ul class="lvl-0">
<li class="lvl-3">
<p>直接求解a-b之间的数的个数并不好求，这里要采用类似前缀和的思想来求解，先建立一个求解1~n之间的数的个数的函数，则$$count(a,b) = count(1,b) - count(1, a-1)$$</p>
</li>
<li class="lvl-3">
<p>针对于求每一位上数出现的个数，我们要进行分类讨论：</p>
</li>
</ul>
<p>不妨设n = abcdefg，当前要求的数为k，分别求出其在每一位上出现的次数</p>
<p>不妨讨论其在第四位d的情况， 则1 &lt;= xxxkyyy &lt;= abcdefg。下面进行分类讨论：</p>
<p>(1) xxx = 000~abc - k，则yyy = 000~999，共abc*1000个</p>
<p>(2) xxx = abc</p>
<ol>
<li class="lvl-3">
<p>d &lt; k, abckyyy &gt; abcdyyy，不成立</p>
</li>
<li class="lvl-3">
<p>d = k, yyy = 000~efg，共efg + 1个</p>
</li>
<li class="lvl-3">
<p>d &gt; k, yyy = 000~999，共1000个</p>
</li>
</ol>
<p>还要注意边界问题：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当k放在首位是(1)的情况将不存在。</p>
</li>
<li class="lvl-2">
<p>当k=0时，不能作为前导零和首位，即xxx要从001开始而不能从000开始</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数位dp——计数问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(vector&lt;<span class="type">int</span>&gt; num, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;<span class="comment">// 求出从第l位到第r位组成的数的大小</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &gt;= r; -- i) res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power10</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// 求10^x的大小</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x--) res *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    num.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        num.<span class="built_in">push_back</span>(n % <span class="number">10</span>); <span class="comment">//首先将每一位提出来</span></span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n = num.<span class="built_in">size</span>(); <span class="comment">// 保存总位数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// vector从0开始，注意循环的范围</span></span><br><span class="line">    <span class="comment">// 注意这里巧妙的写法：i = n - 1 - !x，这样写避免了0作为第一位</span></span><br><span class="line">    <span class="comment">// 注意i表示第几位的位数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span> - !x; i &gt;= <span class="number">0</span>; -- i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>)&#123; <span class="comment">// 作为首位时此情况不存在</span></span><br><span class="line">            res += <span class="built_in">get</span>(num, n - <span class="number">1</span>, i + <span class="number">1</span>) * <span class="built_in">power10</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (!x) res -= <span class="built_in">power10</span>(i); <span class="comment">// x = 0时从001开始</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[i] == x) res += <span class="built_in">get</span>(num, i - <span class="number">1</span>, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num[i] &gt; x) res += <span class="built_in">power10</span>(i); <span class="comment">// 注意i从0开始，所以这里不是i-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b, a || b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++ i)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">count</span>(b, i) - <span class="built_in">count</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态压缩DP">状态压缩DP</h2>
<p>可参考以下博客的讲解：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ibilllee/p/7651971.html">状态压缩DP入门</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Tony-Double-Sky/p/9283254.html">状态压缩动态规划 状压DP</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011077606/article/details/43487421">动态规划之状态压缩dp入门</a></p>
</li>
</ul>
<h3 id="引入">引入</h3>
<p>对于<strong>组合问题或选择问题</strong>，我们可以使用01向量来表示每种组合的选择情况，如$x=&lt;1,0,0,0,1&gt;$。我们以1表示元素被选中，0表示元素没被选中。</p>
<p>而这种01表示实际上可以被视为一个二进制数。反过来，<strong>每一个二进制都可以用来表示一种组合问题中的选法</strong>。并且我们可以通过二进制的位运算来实现对选法的操作。这就直观的实现了选法的量化和处理。</p>
<p><strong>所谓状态压缩DP即DP中的所有状态都用二进制编码表示</strong></p>
<h3 id="状态压缩">状态压缩</h3>
<p>简单来说，状态压缩利用计算机二进制的性质来描述状态的一种方法。</p>
<p>利用前文的思路，我们将一个整数视为二进制数，并用二进制数的每一位表示选择的情况。每一个整数就是一个压缩的状态（组合的选法），这就是状态压缩。</p>
<p>之所以要用到状态压缩是因为在很多问题中状态表示往往比较复杂麻烦，不容易表示出来，需要用一些编码技术，把状态压缩的用简单的方式表示出来。典型方式就是当需要表示一个集合有哪些元素时，往往利用2进制用一个整数表示。</p>
<p>状压其实是一种很暴力的算法，因为它需要遍历每个状态，所以将会出现2^n的情况数量，不过这并不代表这种方法不适用：一些题目可以依照题意，<strong>排除冗余与不合法的方案</strong>，使一行的总方案数大大减少从而减少枚举。</p>
<p>这里实际上利用了十进制和二进制的一一对应关系，以二进制表示状态，以十进制作为存储和枚举编号</p>
<h3 id="状态压缩DP-2">状态压缩DP</h3>
<p>状态压缩通常和BFS或DP连用，当和DP一起使用时即为状态压缩DP。</p>
<p>动态规划本来就很抽象，状态的设定和状态的转移都不好把握，而状态压缩的动态规划解决的就是那种状态很多，不容易用一般的方法表示的动态规划问题，这个就更加的难于把握了。难点在于以下几个方面：状态怎么压缩？压缩后怎么表示？怎么转移？是否具有最优子结构？是否满足后效性？涉及到一些位运算的操作，虽然比较抽象，但本质还是动态规划。找准动态规划几个方面的问题，深刻理解动态规划的原理，开动脑筋思考问题。这才是掌握动态规划的关键。</p>
<p>由于状态都是二进制数，因此在状态计算时就要用到位运算进行操作</p>
<h3 id="位运算">位运算</h3>
<p>借助于<strong>位运算</strong>，我们可以实现对状态进行操作或访问。</p>
<p>常用位运算如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算名</th>
<th style="text-align:center">符号</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">按位与</td>
<td style="text-align:center">如果两个相应的二进制位都为1，则该位的结果值为1，否则为0</td>
</tr>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:center">按位或</td>
<td style="text-align:center">两个相应的二进制位中只要有一个为1，该位的结果值为1</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">按位异或</td>
<td style="text-align:center">若参加运算的两个二进制位值相同则为0，否则为1</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">取反</td>
<td style="text-align:center">~是一元运算符，用来对一个二进制数按位取\反，即将0变1，将1变0</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">左移</td>
<td style="text-align:center">用来将一个数的各二进制位全部左移N位，右补0</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">右移</td>
<td style="text-align:center">将一个数的各二进制位右移N位，移到右端 的低位被舍弃，对于无符号数，高位补0</td>
</tr>
</tbody>
</table>
<p>常用应用技巧如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">位运算操作</th>
<th style="text-align:center">代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">判断一个数字x二进制下第<code>i</code>位是不是等于1(这里<code>i</code>从0开始)</td>
<td style="text-align:center"><code>if (( x &gt;&gt; i &amp; 1 )</code>或 <code>if ((( 1 &lt;&lt; i) &amp; x ))</code></td>
</tr>
<tr>
<td style="text-align:center">将一个数字x二进制下第<code>i</code>位更改成1</td>
<td style="text-align:center">`x = x</td>
</tr>
<tr>
<td style="text-align:center"><code>lowbit</code>运算——求一个数字最右端1对应的大小</td>
<td style="text-align:center"><code>lowbit(x) = x &amp; -x</code></td>
</tr>
<tr>
<td style="text-align:center">把一个数字二进制下最靠右的第一个1去掉</td>
<td style="text-align:center"><code>x = x - lowbit(x) = x - (x &amp; -x)</code>或<code>x = x &amp; ( x − 1 )</code></td>
</tr>
<tr>
<td style="text-align:center">用位运算求解$2^n$</td>
<td style="text-align:center"><code>1 &lt;&lt; n</code></td>
</tr>
<tr>
<td style="text-align:center">取出<code>i</code>二进制下的第<code>j</code>位</td>
<td style="text-align:center"><code>i &gt;&gt; j &amp; 1</code></td>
</tr>
<tr>
<td style="text-align:center">用位运算判断奇偶</td>
<td style="text-align:center">奇数：<code>n &amp; 1 == 1</code> 偶数：<code>n &amp; 1 == 0</code></td>
</tr>
</tbody>
</table>
<h3 id="1-AcWing-291-蒙德里安的梦想">1. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/293/">AcWing 291. 蒙德里安的梦想</a></h3>
<p>首先需要注意到当我们将所有横向的小方格，纵向的小方格就只能保剩下的位置全部填满，因而只剩下一种填法。</p>
<p><strong>所以整个的划分方案数就等于所有横向的小方格的方案数</strong>。</p>
<p>这里要求看出组合/排序/选择问题的本质，去除冗余，并从多个对象中合理选择处理对象。</p>
<p>需注意横向小方格的方案必须保证最后剩下的位置都被纵向小方格填满。</p>
<p>如果我们以<code>i</code>作为列数，为了表示每一列中方格的排列情况就需要使用状态压缩，以二进制表示每一行是否存在方格。为此我们以整数j表示这种压缩状态。</p>
<p>当问题中的状态之间有关联性，需要将每种情况对应的状态具体存储下来用于后续处理，且状态为选择的情况时，就可以用二进制表示。讲白了，常见题目的原数组是固定的，而这里原数组动态变化，是我们讨论的对象，因此需要动态讨论表示出来。</p>
<p>同时可以发现二进制状态压缩隐含降维的作用，如果不使用状态压缩的话，维度会超过两维，状态转换会过于复杂，而使用状态压缩后每个选择状态都是一个一维向量，却只使用一个数的存储量，实现了降维，便于讨论和转移状态。本题实现了沿列这一维进行压缩，将所有行压缩到一个数值中。</p>
<p>另外需注意，由于小方格的大小是 $1 \times 2 $的，<strong>所以在我们研究第<code>i + 1</code>列时，第<code>i</code>列的组合情况就会对其造成影响</strong>。但需注意，这种影响并不是后效性，可以发现<strong>只有相邻的两列才会产生互相影响，而不会影响其他列</strong>。因而实际上，这是一种<strong>有条件约束、需分类讨论的递推关系</strong>，仍可以使用dp。</p>
<p>可以发现，第<code>i</code>列的每种组合情况实际上都等同于第<code>i+1</code>列所有初始分布情况，状态<code>j + 1</code>是在状态<code>j</code>的基础上得到的。换就话说为了得出<code>j + 1</code>，就要对前一列的所有状态<code>j</code>进行枚举，再取所有满足前面两种限制的状态<code>j + 1</code>。</p>
<p>前面的两种限制可以量化为以下形式：</p>
<ol>
<li class="lvl-3">
<p>为了保证第<code>i</code>列和第<code>i+1</code>列不出现小方格的重叠放置，必须满足：<br>
$$<br>
(j \ &amp; \ k) == 0<br>
$$</p>
</li>
</ol>
<p>之所以这样写是因为我们的二进制表示中只会表示横向方格的第二个方格，如果当前列的状态中有方格，前一列就必须没有方格（实际表示要有空间存放第一个方格）。这一化简很重要。</p>
<ol start="2">
<li class="lvl-3">
<p>为了保证最后第<code>i-1</code>能被纵向的小方格填满，第<code>i</code>列的状态<code>j</code>和第<code>i+1</code>列的状态<code>k</code>必须满足：</p>
</li>
</ol>
<p>$$<br>
(j\  |\ k)不存在连续奇数个0<br>
$$</p>
<p>注意<code>(j|k)</code>表示的是第<code>i-1</code>列的选择情况而不是第<code>i</code>列。因此最后一列还要特判。</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230329212621963.png" alt="image-20230329212621963"></p>
<h4 id="朴素算法-5">朴素算法</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 291. 蒙德里安的梦想——状压DP未优化做法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N; <span class="comment">// 使用位运求解2^N</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL f[N][M]; <span class="comment">// 爆int</span></span><br><span class="line"><span class="type">bool</span> st[M];<span class="comment">// 用于标记是否满足偶数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)&#123; <span class="comment">// n=0，m=0时，表示输入终止</span></span><br><span class="line">        <span class="comment">// 预处理出所有满足偶数的二进制表示状态</span></span><br><span class="line">        <span class="comment">// 遍历所有可能的选择情况的二进制表示</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i)&#123; <span class="comment">// 使用位运求解2^n</span></span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// cnt表示当前这一段连续0的个数</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 2^n二进制有n位</span></span><br><span class="line">            <span class="comment">// 预处理所有状态不存在奇数个0</span></span><br><span class="line">            <span class="comment">// 之所以可以预处理是因为所有组合情况都通过二进制穷举出</span></span><br><span class="line">            <span class="comment">// 这里一定要注意这种预处理思想，不是在组合前进行判断，而是在组合后进行判断；无论如何组合，都会包含在事先枚举出的所有状态中</span></span><br><span class="line">            <span class="comment">// 遍历每个二进制表示的每一位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)&#123; <span class="comment">// i的二进制中，从右往左数，取第j+1位上的值</span></span><br><span class="line">                <span class="comment">// 当前这一段是1说明上一段连续0的段落已经截止</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// 判断上一段连续的0是奇数个还是偶数个</span></span><br><span class="line">                    <span class="comment">// cnt &amp; 1取出cnt二进制的个位，当cnt为偶数时，个位为0，当cnt为奇数时，个位为1</span></span><br><span class="line">                    cnt = <span class="number">0</span>; <span class="comment">// 清空</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ++ cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>; <span class="comment">// 最后一段下方可能是边界不再存在1（小方格）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f); <span class="comment">// memset 按照字节赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边界条件</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 第0列什么都不放，其状态为0，也不会存在小方格顶出到第1列，所以f[0][0] = 1(什么都不放也是选择方式)，f[0][1~n] = 0(其余组合状态都不被选择)</span></span><br><span class="line">        <span class="comment">// 枚举所有列</span></span><br><span class="line">        <span class="comment">// 分割从第0列开始，但第0列是不用讨论的，只存储横向方格的第二个方格</span></span><br><span class="line">        <span class="comment">// 因为j|k维护前一列，所以遍历到m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) </span><br><span class="line">            <span class="comment">// 枚举第i列所有状态</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; ++ j)</span><br><span class="line">                <span class="comment">// 枚举第i-1列的所有状态</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; n; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k]) </span><br><span class="line">                    <span class="comment">// j &amp; k 会取出在j和k中都为1的位，即都被选择的元素，它实际上就是两列重叠放置的情况</span></span><br><span class="line">                    <span class="comment">// j | k 会筛出在j或k中被选的元素，它实际上就是两列都放上小方格后第i-1列的组合情况，用于维护i-1列最后一定能被填满</span></span><br><span class="line">                        f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">                        <span class="comment">// 只要相邻两列的状态满足约束条件，前一列的该状态的选择数就会加在发f[i][j]上</span></span><br><span class="line">                        <span class="comment">// 这里是一种穷举方法，针对第i列的每一种状态，都枚举前一列的所有状态来判断是否可以组合在一起</span></span><br><span class="line">        <span class="comment">// 不能有超出棋盘的方格，所以m对应的状态为全0</span></span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 这里要理解f[i][j]里存的是什么，i是第i列，j是这一列的一种选择状态，f[i][j]表示在这一列处于这种选择状态时从第1列到第i列的所有选择数</span></span><br><span class="line">        <span class="comment">// 最后一列由于涉及边界问题，不能再存放小方格，所以其状态只能是0，由此要求的答案为f[m][0]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="去除无效状态的优化写法">去除无效状态的优化写法</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL f[N][M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state[M];</span><br><span class="line"><span class="type">bool</span> st[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> is_valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        is_valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++ ;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) is_valid = <span class="literal">false</span>;</span><br><span class="line">            st[i] = is_valid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            state[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++ )</span><br><span class="line">                <span class="keyword">if</span> ((i &amp; j) == <span class="number">0</span> &amp;&amp; st[i | j])</span><br><span class="line">                    state[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; n; j ++ )</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : state[j])</span><br><span class="line">                    f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python-8">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 状态是否有效</span></span><br><span class="line">    ok = [<span class="literal">False</span>] * (<span class="number">1</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line">    <span class="comment"># 每个状态能被转移过来的状态</span></span><br><span class="line">    state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">        M = <span class="number">1</span> &lt;&lt; n</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 预处理每个状态是否合法（能否竖向插入）</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            cnt, valid = <span class="number">0</span>, <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i &gt;&gt; j &amp; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> cnt &amp; <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    cnt = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt &amp; <span class="number">1</span>:</span><br><span class="line">                valid = <span class="literal">False</span></span><br><span class="line">            ok[i] = valid</span><br><span class="line">        <span class="comment"># 预处理每个状态的转移子集，求出每个状态后面能接的非法状态</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">            state[j] = []</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">                <span class="comment"># 检查第 i - 2 列与第 i - 1 列是否冲突，二进制 1 表示当前行是牌板尾部</span></span><br><span class="line">                <span class="comment"># 即状态前后表示要么是 [尾，头]，要么是 [头，尾]</span></span><br><span class="line">                <span class="comment"># 此时第 i - 1 列的最终态已确定，检查第 i - 1 列能否满足竖向插入</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (j &amp; k) <span class="keyword">and</span> ok[j | k]:</span><br><span class="line">                    state[j].append(k)</span><br><span class="line">        <span class="comment"># DP 过程，前 i - 1 列安排完毕，第 i - 1 列能转移到第 i 列的方案数转移</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * M <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> state[j]:</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][k]</span><br><span class="line">        <span class="comment"># 前 m 列安排完毕，且没有牌板出界的所有方案数</span></span><br><span class="line">        <span class="built_in">print</span>(dp[m][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="2-AcWing-91-最短Hamilton路径">2. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/93/">AcWing 91. 最短Hamilton路径</a></h3>
<p>本题显然是具有最优子结构的：0经k到j的最优路径对应的0到k的路径也是最优的。因此考虑DP。</p>
<p>但是可以发现，路径的变化导致状态的变化。且由于这是一个无向图，行进的方向是任意的，且题目要求一个点只能遍历一次，因而结点间的顺序是相互影响的，即对应状态间是由互斥等关系的，因此就必须具体存储和讨论每个状态。又由于只用考察当前每个结点是否已经走过了，相当于组合或选择问题，可以使用二进制状态压缩。</p>
<p>又由于最后一个节点影响迭代，所以状态另一维度是最后到达的节点</p>
<p>集合：所有从0走到<code>j</code>，走过的所有点是<code>i</code>的所有路径属性：Min</p>
<p>集合划分：讨论倒数第二个点是0~n-1中的哪一个</p>
<p>这里需注意我们所关心的是经过了哪些点，最后一个点是谁，因而定义了以上的状态表示</p>
<h4 id="为什么使用memset-f-0x3f-sizeof-f-来初始为极大值">为什么使用memset(f, 0x3f, sizeof f)来初始为极大值</h4>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1877662">为什么是 0x3f ？</a></p>
<p>0x3f中0x表示十六进制数 3f转化为二进制位0011 1111。<br>
memset 按照字节赋值，因此我们把4个0011 1111填充到 32位的int上，此时f = 0x3f3f3f3f = 1061109567 是$10^9$级别的。</p>
<p>但问题是，为什么不是 0x4f 或者 0x5f ？</p>
<p>首先$10^9$级别足够大，其次，也是最重要的，0x3f3f3f3f + 0x3f3f3f3f 等于 0x7e7e7e7e = 2122219134，不会爆int。</p>
<p>在一般的电脑中,int占用4字节,32比特,数据范围为-2147483648<sub>2147483647[$-2^31$</sub>$2^31-1$]。</p>
<p>但当用到初始化-INF，直接 memset(a, -0x3f, sizeof a) 也是可以的，无非就是0x3f取反加一嘛，从 0011 1111 变为 1100 0001。但是相加会爆，所以并不是很好。</p>
<p><img src="https://mdpic.dreamgo.fun/img/image-20230329214550825.png" alt="image-20230329214550825"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状压DP——最短Hamilton路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            cin &gt;&gt; d[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f); <span class="comment">// 要求的是最小值，需要先初始化为无穷大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">// 从0走动0，距离为0(状态1表示只经过0)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举所有状态，i表示每种路径的状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; ++ i)</span><br><span class="line">        <span class="comment">// j表示路径经过的最后一个点 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) <span class="comment">// 枚举每个点作为最后一个点</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)<span class="comment">// 状态i要经过j</span></span><br><span class="line">                <span class="comment">// k表示路径经过的倒数第二点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n ; ++ k) <span class="comment">// 枚举每个点作为倒数第二个点</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt;&gt; k &amp; <span class="number">1</span>) <span class="comment">// 状态i要经过k</span></span><br><span class="line">                        f[i][j]  = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + d[k][j]);</span><br><span class="line">                        <span class="comment">// i - (1 &lt;&lt; j)将状态i中j这个选择置为0，即路径中去除j</span></span><br><span class="line">                        <span class="comment">// 这里利用了最后一个点的有无并不影响前面的路径，如果是中间某个点就不能随意去除了</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 1 &lt;&lt; n - 1恰表示所有点（二进制的每一位都是1）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python-9">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    d = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    M = <span class="number">1</span> &lt;&lt; n</span><br><span class="line">    f = [[<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)]  * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(M)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 起点距离为 0</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt;&gt; j &amp; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> i &gt;&gt; k &amp; <span class="number">1</span>:</span><br><span class="line">                        <span class="comment"># 可到达点 k、j，且当前在点 k 中转到点 j 的最短路径</span></span><br><span class="line">                        <span class="comment"># f[i -(1 &lt;&lt; j)][k]对应于挖去节点j，且最后的节点为k的最优路径值</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + d[k][j])</span><br><span class="line">    <span class="comment"># 最后是全1的状态，终点为n-1</span></span><br><span class="line">    <span class="built_in">print</span>(f[M-<span class="number">1</span>][n-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="树形DP">树形DP</h2>
<h3 id="1-AcWing-285-没有上司的舞会">1. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/287/">AcWing 285. 没有上司的舞会</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AcWing 285. 没有上司的舞会</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> has_fa[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = ++ idx; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line"></span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;happy[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">        has_fa[a] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (has_fa[root]) ++ root;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP没有后效性 &lt;==&gt; 抽象出来的图论模型是一个拓扑图</p>
<p>能都进行递归的前提是图必须是拓扑图，不能出现环</p>
<h2 id="记忆化搜索">记忆化搜索</h2>
<h3 id="1-AcWing-901-滑雪">1. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/903/">AcWing 901. 滑雪</a></h3>
<p>状态表示：集合：所有从(i,j)开始滑的路径属性：Max<br>
集合划分：从(i,j)分别向上下左右滑</p>
<p>思路更好想，代码更好写，但运行会慢些，可能会爆栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索——滑雪</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="comment">// 枚举上下左右四个方向的常用技巧：使用偏移量</span></span><br><span class="line"><span class="comment">// 使用偏移量是一种简化枚举的常用技巧，记住这种使用技巧</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆化搜索——在dfs中加入存储</span></span><br><span class="line"><span class="comment">// dp(i, j)返回f[i][j]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = f[x][y];</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="number">-1</span>) <span class="keyword">return</span> v;  </span><br><span class="line">    <span class="comment">// 说明f[x][y]已经求出来了，直接返回即可</span></span><br><span class="line">    <span class="comment">// 避免重复计算；不同于递推，递归中会出现重复问题，要进行标记</span></span><br><span class="line">    <span class="comment">// 这里重复是因为我们在main()中会遍历所有f[i][j]，而dp中会进行存储，避免重复计算</span></span><br><span class="line"></span><br><span class="line">    v = <span class="number">1</span>; <span class="comment">// 至少为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)&#123;</span><br><span class="line">        <span class="type">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">1</span> &amp;&amp; a &lt;= n &amp;&amp; b &gt;= <span class="number">1</span> &amp;&amp;b &lt;= m &amp;&amp; h[x][y] &gt; h[a][b])<span class="comment">// 注意边界问题</span></span><br><span class="line">            v = <span class="built_in">max</span>(v, <span class="built_in">dp</span>(a, b) + <span class="number">1</span>); <span class="comment">// 注意要进行递归， dp[i][j]会返回f[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);<span class="comment">// 将所有状态都先初始化为-1，表示每个状态都没有被算过</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Python-10">Python</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    h = [[<span class="number">0</span>] * m] + [[<span class="number">0</span>] + <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    f = [[-<span class="number">1</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    d_x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">    d_y = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="comment"># f[x][y]已经求出来了，直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> f[x][y] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> f[x][y]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注意初始化，至少为1</span></span><br><span class="line">        f[x][y] = <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> <span class="built_in">zip</span>(d_x, d_y):</span><br><span class="line">            nx, ny = x + dx, y + dy</span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span> &lt;= nx &lt;= n <span class="keyword">and</span> <span class="number">1</span> &lt;= ny &lt;= m <span class="keyword">and</span> h[nx][ny] &lt; h[x][y]:</span><br><span class="line">                f[x][y] = <span class="built_in">max</span>(f[x][y], dp(nx, ny) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[x][y]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历每个状态</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp(i, j))</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>算法基础课5 动态规划</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.dreamgo.fun/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">https://www.dreamgo.fun/2023/04/06/算法笔记-算法基础课-5-动态规划/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>沧月倾</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-04-06</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-04-06</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://picbed.dreamgo.fun/img/cover/27.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-4-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/" title="算法基础课4 数学知识"><img class="cover" src="https://picbed.dreamgo.fun/img/cover/32.webp" onerror="onerror=null;src='https://picbed.dreamgo.fun/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法基础课4 数学知识</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-6-%E8%B4%AA%E5%BF%83/" title="算法基础课6 贪心"><img class="cover" src="https://picbed.dreamgo.fun/img/cover/23-1.webp" onerror="onerror=null;src='https://picbed.dreamgo.fun/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法基础课6 贪心</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/26/2-2-2-DFS%E4%B9%8B%E5%89%AA%E6%9E%9D/" title="2.2.2 DFS之剪枝"><img class="cover" src="https://picbed.dreamgo.fun/img/cover/18.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-26</div><div class="title">2.2.2 DFS之剪枝</div></div></a></div><div><a href="/2023/02/23/2-2-1-DFS%E4%B8%AD%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7%E5%92%8C%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F/" title="2.2.1 DFS中的连通性和搜索顺序"><img class="cover" src="https://picbed.dreamgo.fun/img/cover/45-1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-23</div><div class="title">2.2.1 DFS中的连通性和搜索顺序</div></div></a></div><div><a href="/2023/02/28/2-2-3-DFS%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%8A%A0%E6%B7%B1%E3%80%81%E5%8F%8C%E5%90%91DFS%E3%80%81IDA/" title="2.2.3 DFS之迭代加深、双向DFS、IDA*"><img class="cover" src="https://picbed.dreamgo.fun/img/cover/11-1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="title">2.2.3 DFS之迭代加深、双向DFS、IDA*</div></div></a></div><div><a href="/2023/01/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-20230131-2-1-2-BFS%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%BA%90BFS-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97BFS-%E6%9C%80%E5%B0%8F%E6%AD%A5%E6%95%B0%E6%A8%A1%E5%9E%8B/" title="2.1.2 BFS中的多源BFS-双端队列BFS-最小步数模型"><img class="cover" src="https://picbed.dreamgo.fun/img/cover/39-1.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-31</div><div class="title">2.1.2 BFS中的多源BFS-双端队列BFS-最小步数模型</div></div></a></div><div><a href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="蓝桥杯备赛 树状数组与线段树"><img class="cover" src="https://picbed.dreamgo.fun/img/cover/22.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-06</div><div class="title">蓝桥杯备赛 树状数组与线段树</div></div></a></div><div><a href="/2023/04/06/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="算法基础课1 基础算法"><img class="cover" src="https://picbed.dreamgo.fun/img/cover/3.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-06</div><div class="title">算法基础课1 基础算法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="card-info-avatar"></div><div class="avatar-img"><img src="https://picbed.dreamgo.fun/img/avatar/a1.webp" onerror="this.onerror=null;this.src='https://picbed.dreamgo.fun/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">沧月倾</div><div class="author-info__description">为自己的人生负责</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/homeofzhixiang"><i class="fab fa-github"></i><span>🛴前往小家...</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><a class="faa-parent animated-hover"><svg class="faa-tada icon" style="height:25px;width:25px;fill:currentColor;position:relative;top:0px" aria-hidden="true"><use xlink:href="#icon-gonggao"></use></svg></a><span>公告栏</span></div><div class="announcement_content"><center>Welcome to ZX's blog!🍭🍭🍭</center></div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">背包问题模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AcWing-2-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">1. AcWing 2. 01背包问题 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C"><span class="toc-text">C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python"><span class="toc-text">python</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AcWing-3-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">2. AcWing 3. 完全背包问题  </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95"><span class="toc-text">朴素算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python-2"><span class="toc-text">python</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E8%BF%9B%E8%A1%8C%E5%8F%98%E5%BD%A2%E5%8C%96%E7%AE%80"><span class="toc-text">对状态方程进行变形化简</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python-3"><span class="toc-text">python</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96"><span class="toc-text">使用滚动数组优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python-4"><span class="toc-text">python</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-AcWing-4-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">3. AcWing 4. 多重背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95-2"><span class="toc-text">朴素算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-AcWing-5-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-II"><span class="toc-text">4. AcWing 5. 多重背包问题 II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-AcWing-9-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">5. AcWing 9. 分组背包问题 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95-3"><span class="toc-text">朴素算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96"><span class="toc-text">滚动数组优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7DP"><span class="toc-text">线性DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AcWing-898-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">1. AcWing 898. 数字三角形 </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%961%E2%80%94%E2%80%94%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="toc-text">优化1——滚动数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%962%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%9C%A8%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%9C"><span class="toc-text">优化2——直接在存储数据的数组存储结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AcWing-895-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">2. AcWing 895. 最长上升子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95-4"><span class="toc-text">朴素算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%8A%B6%E6%80%81"><span class="toc-text">输出状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AcWing-896-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-II"><span class="toc-text">3. AcWing 896. 最长上升子序列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-2"><span class="toc-text">C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python"><span class="toc-text">Python</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AcWing-897-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">4. AcWing 897. 最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-3"><span class="toc-text">C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-2"><span class="toc-text">Python</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AcWing-902-%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">4. AcWing 902. 最短编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-4"><span class="toc-text">C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-3"><span class="toc-text">Python</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-AcWing-899-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">5. AcWing 899. 编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-5"><span class="toc-text">C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-4"><span class="toc-text">Python</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4DP"><span class="toc-text">区间DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AcWing-282-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-text">AcWing 282. 石子合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-5"><span class="toc-text">Python</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88BP"><span class="toc-text">组合BP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E7%B1%BBDP"><span class="toc-text">计数类DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AcWing-900-%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86"><span class="toc-text">1. AcWing 900. 整数划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">思路一：转化为完全背包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-6"><span class="toc-text">Python</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C"><span class="toc-text">思路二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-7"><span class="toc-text">Python</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AcWing-1050-%E9%B8%A3%E4%BA%BA%E7%9A%84%E5%BD%B1%E5%88%86%E8%BA%AB"><span class="toc-text">2. AcWing 1050. 鸣人的影分身</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8DDP"><span class="toc-text">数位DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AcWing-338-%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-text">1. AcWing 338. 计数问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP"><span class="toc-text">状态压缩DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9"><span class="toc-text">状态压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP-2"><span class="toc-text">状态压缩DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AcWing-291-%E8%92%99%E5%BE%B7%E9%87%8C%E5%AE%89%E7%9A%84%E6%A2%A6%E6%83%B3"><span class="toc-text">1. AcWing 291. 蒙德里安的梦想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95-5"><span class="toc-text">朴素算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%8A%B6%E6%80%81%E7%9A%84%E4%BC%98%E5%8C%96%E5%86%99%E6%B3%95"><span class="toc-text">去除无效状态的优化写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-8"><span class="toc-text">Python</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AcWing-91-%E6%9C%80%E7%9F%ADHamilton%E8%B7%AF%E5%BE%84"><span class="toc-text">2. AcWing 91. 最短Hamilton路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8memset-f-0x3f-sizeof-f-%E6%9D%A5%E5%88%9D%E5%A7%8B%E4%B8%BA%E6%9E%81%E5%A4%A7%E5%80%BC"><span class="toc-text">为什么使用memset(f, 0x3f, sizeof f)来初始为极大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-9"><span class="toc-text">Python</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2DP"><span class="toc-text">树形DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AcWing-285-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A"><span class="toc-text">1. AcWing 285. 没有上司的舞会</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-text">记忆化搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-AcWing-901-%E6%BB%91%E9%9B%AA"><span class="toc-text">1. AcWing 901. 滑雪</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-10"><span class="toc-text">Python</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div><center> 垂头的时候一切都饱满了 <br/>
谁记得从前疯狂的燃烧  <br/>
每一个花瓣都是火焰✨<center/></div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://tzy1997.com/" title="唐志远の博客"><img src="https://lskypro.acozycotage.net/LightPicture/2022/12/4ab83cdce942463b.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://akilar.top/" title="Akilarの糖果屋"><img src="https://lskypro.acozycotage.net/LightPicture/2022/12/6bf1ed05796db59c.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://butterfly.js.org/" title="Butterfly"><img src="https://lskypro.acozycotage.net/LightPicture/2022/12/64cc6a7d508026e1.png" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://anzhiy.cn/" title="安知鱼"><img src="https://lskypro.acozycotage.net/LightPicture/2022/12/1b33fef8f5fb7e63.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.acozycotage.net/" title="Acozycotage"><img src="https://lskypro.acozycotage.net/LightPicture/2022/12/6a6fe6ebfd19c465.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://cdn.netdun.net/" title="网盾星球"><img src="https://lskypro.acozycotage.net/LightPicture/2022/12/70dee3f9d1ca10f3.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2023</b></span><span><b>&nbsp;&nbsp;By 沧月倾</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-NightSunnyn"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'http://twikoo.dreamgo.fun/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'http://twikoo.dreamgo.fun/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><canvas id="universe"></canvas><script defer src="/js/runtime.js"></script><script defer src="/js/universe.js"></script><script defer src="/js/windows.js"></script><script src="/js/sun_moon.js" async></script><script defer src="/js/cursor.js"></script><script defer src="/js/nav.js"></script><script defer data-pjax src="/js/cat.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script async src="//at.alicdn.com/t/c/font_3869443_whvn5c22z3.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script src="/"></script><script>//- let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '#web_bg',
  '.js-pjax'
]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.dreamgo.fun/categories/算法笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 蒟蒻の算法笔记 (13)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.dreamgo.fun/categories/record/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 随笔 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.dreamgo.fun/categories/机器学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 机器学习 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://www.dreamgo.fun/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #69e8f2}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'f1b52487749c4e358d7f84ab68914874';
  var gaud_map_key = '25e28ec1fcf06a0cf396a3c2fb76103a';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/23/hello-world/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://picbed.dreamgo.fun/img/cover/4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/23/hello-world/&quot;);" href="javascript:void(0);" alt="">Hello World</a><div class="blog-slider__text">Welcome to my blog!</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/23/hello-world/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/24/算法笔记-20230131-2-1-1-BFS中的Flood-Fill和最短路模型/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://picbed.dreamgo.fun/img/cover/14.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-24</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/24/算法笔记-20230131-2-1-1-BFS中的Flood-Fill和最短路模型/&quot;);" href="javascript:void(0);" alt="">2.1.1 BFS中的Flood Fill和最短路模型</a><div class="blog-slider__text">算法提高课 第二章搜索</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/24/算法笔记-20230131-2-1-1-BFS中的Flood-Fill和最短路模型/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/01/31/算法笔记-20230131-2-1-2-BFS中的多源BFS-双端队列BFS-最小步数模型/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://picbed.dreamgo.fun/img/cover/39-1.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-31</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/01/31/算法笔记-20230131-2-1-2-BFS中的多源BFS-双端队列BFS-最小步数模型/&quot;);" href="javascript:void(0);" alt="">2.1.2 BFS中的多源BFS-双端队列BFS-最小步数模型</a><div class="blog-slider__text">算法提高课 第二章搜索</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/01/31/算法笔记-20230131-2-1-2-BFS中的多源BFS-双端队列BFS-最小步数模型/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/02/28/2-2-3-DFS之迭代加深、双向DFS、IDA/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://picbed.dreamgo.fun/img/cover/11-1.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/02/28/2-2-3-DFS之迭代加深、双向DFS、IDA/&quot;);" href="javascript:void(0);" alt="">2.2.3 DFS之迭代加深、双向DFS、IDA*</a><div class="blog-slider__text">算法提高课 第二章搜索</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/02/28/2-2-3-DFS之迭代加深、双向DFS、IDA/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/02/23/2-2-1-DFS中的连通性和搜索顺序/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://picbed.dreamgo.fun/img/cover/45-1.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-23</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/02/23/2-2-1-DFS中的连通性和搜索顺序/&quot;);" href="javascript:void(0);" alt="">2.2.1 DFS中的连通性和搜索顺序</a><div class="blog-slider__text">算法提高课 第二章搜索</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/02/23/2-2-1-DFS中的连通性和搜索顺序/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/02/26/2-2-2-DFS之剪枝/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://picbed.dreamgo.fun/img/cover/18.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-26</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/02/26/2-2-2-DFS之剪枝/&quot;);" href="javascript:void(0);" alt="">2.2.2 DFS之剪枝</a><div class="blog-slider__text">算法提高课 第二章搜索</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/02/26/2-2-2-DFS之剪枝/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>